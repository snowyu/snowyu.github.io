<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Riceball LEE</title>
  
  <subtitle>Go with wind.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://riceball.me/"/>
  <updated>2025-04-05T16:43:02.000Z</updated>
  <id>https://riceball.me/</id>
  
  <author>
    <name>Riceball LEE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从头手搓面向应用的AI框架</title>
    <link href="https://riceball.me/article/Build-an-application-oriented-AI-framework-from-scratch/"/>
    <id>https://riceball.me/article/Build-an-application-oriented-AI-framework-from-scratch/</id>
    <published>2025-03-17T17:14:40.000Z</published>
    <updated>2025-04-05T16:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cong-tou-shou-cuo-mian-xiang-ying-yong-de-ai-kuang-jia" class="heading-control">🌟 从头手搓面向应用的AI框架 🚀<a class="heading-anchor" href="#cong-tou-shou-cuo-mian-xiang-ying-yong-de-ai-kuang-jia" aria-hidden="true"></a></h1><h2 id="wei-shi-mo-cong-tou-shou-cuo-ai-kuang-jia-er-bu-shi-shi-yong-xian-you-kuang-jia" class="heading-control">为什么从头手搓 AI 框架，而不是使用现有框架？<a class="heading-anchor" href="#wei-shi-mo-cong-tou-shou-cuo-ai-kuang-jia-er-bu-shi-shi-yong-xian-you-kuang-jia" aria-hidden="true"></a></h2><p>💡 为啥我要从头手搓AI框架，而不是直接使用类似 langchain、AutoGen、LMQL 等现成框架呢？</p><p>最初我也尝试了多个框架（包括LangChain、AutoGen、LMQL、Outlines、MemGPT等），但它们都无法完全满足我的需求。我想要的是一个<strong>极度灵活可配置的AI应用框架</strong>，用来打造我设想的<code>「真·AI PC」</code>——而非当前大多数AI产品那种“远程AI服务+本地空壳”的模式。</p><p>在当前阶段，我认为面向应用的AI框架应聚焦于<strong>提示词（Prompt）的工程化</strong>——这是人类与AI交互的唯一桥梁。我的核心目标是：<br>✅ 将提示词转化为可编程的“函数”或“类”，支持自由组合、独立调用，并能持续迭代优化。</p><p>但是langchain对提示词的抽象只是总结的一些范式，而这些范式在我看来不太不实用，而且更糟糕的是直接将提示词内嵌入代码中，根本无法替换和迭代提示词。而AutoGen是以多智能体架构和事件驱动为核心实现复杂协作工作流；至于LMQL作为一种用于语言模型交互的查询语言更像是炫技；Outlines 聚焦在结构化文本的生成；MemGPT只想实现长久记忆， 这些就不多做评价了。</p><h2 id="wo-xiang-yao-de-ai-kuang-jia-he-xin-gong-neng" class="heading-control">我想要的AI框架核心功能<a class="heading-anchor" href="#wo-xiang-yao-de-ai-kuang-jia-he-xin-gong-neng" aria-hidden="true"></a></h2><p>我想要的是以提示词为核心的框架：</p><ol><li><strong>提示词即函数</strong>：让提示词象普通函数一样的使用，独立提示词可以与代码无缝双向调用，代码可以调用提示词获得结果，提示词也可以调用代码获得结果。</li><li><strong>加密保护</strong>： 支持提示词加密，保障知识产权</li><li><strong>模型中立</strong>： 提示词可适配不同模型及参数规模。</li><li><strong>继承机制</strong>：支持提示词“类”的继承，如同面向对象编程。</li><li><strong>简洁易用</strong>：提示词需简单易读写。</li><li><strong>打包为应用</strong>：能将多个提示词打包成完整AI应用。</li><li><strong>高度可扩展</strong>：支持任意能力的扩展，如:看（图生文），听(STT)，说(TTS)，画(文生图/视频)等等。</li><li><strong>全栈兼容</strong>：跨平台支持（浏览器、服务器端），尽量统一语言减少维护成本（选型JavaScript）。</li></ol><h2 id="kai-fa-li-cheng" class="heading-control">开发历程 🛠️<a class="heading-anchor" href="#kai-fa-li-cheng" aria-hidden="true"></a></h2><p>在2024年多方搜寻无果的情况下，2024年5月我开始从头写<a href="https://github.com/offline-ai/ppe/" target="_blank" rel="noopener">可编程提示词(Programmable Prompt Engine)AI规范</a>，当然最开始不是叫这个名字，最开始叫<code>AI Agent Framework</code>,后来是表伟提议既然实质是让提示词成为可编程的软件工程，那么不妨就叫PPE，我想也对，这个概念更准确，AI Agent应该是以PPE提示词为基础打造，它其实是更上层的概念，遂更名为PPE。</p><p>既然要全栈，那就只能选JavaScript, 从前端到后端，从服务器到浏览器通吃，并且JS极度灵活和可扩展，而这正是我所需要的。</p><h3 id="jie-gou-hua-dui-hua-xiao-xi" class="heading-control">结构化对话消息<a class="heading-anchor" href="#jie-gou-hua-dui-hua-xiao-xi" aria-hidden="true"></a></h3><p>刚开始写的时候，还是很茫然无措的，没有项目可供参考，</p><p>最初就想着用YAML配置的方式简单的来结构化对话消息,然后既然提示词是函数那就肯定需要约定函数的输入和输出: 用<code>input</code>来约定提示词的输入参数, <code>output</code>用<code>Json Schema</code>来约定提示词的输出：</p><pre><code class="yaml"><span class="hljs-attr">templateFormat:</span> <span class="hljs-string">hf</span><span class="hljs-attr">prompt:</span>  <span class="hljs-attr">messages:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">system</span>      <span class="hljs-attr">content:</span> <span class="hljs-string">Carefully</span> <span class="hljs-string">Think</span> <span class="hljs-string">about</span> <span class="hljs-string">the</span> <span class="hljs-string">intent</span> <span class="hljs-string">of</span> <span class="hljs-string">following</span> <span class="hljs-string">The</span> <span class="hljs-string">CONVERSATION</span> <span class="hljs-string">user</span> <span class="hljs-string">provided.</span> <span class="hljs-string">Output</span> <span class="hljs-string">the</span> <span class="hljs-string">json</span> <span class="hljs-string">object</span> <span class="hljs-string">with</span> <span class="hljs-string">the</span> <span class="hljs-string">Intent</span> <span class="hljs-string">Category</span> <span class="hljs-string">and</span> <span class="hljs-string">Reason.</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">user</span>      <span class="hljs-attr">content:</span> <span class="hljs-string">|-        The CONVERSATION:        {{ conversation }}</span><span class="hljs-attr">input:</span>  <span class="hljs-attr">conversation:</span> <span class="hljs-string">"messages[1].content"</span><span class="hljs-attr">output:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>  <span class="hljs-attr">properties:</span>    <span class="hljs-attr">Intent:</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">"string"</span>    <span class="hljs-attr">Reason:</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">"string"</span></code></pre><p>感觉，这样很不自然方便，于是将结构化对话消息的输入/输出配置与对话内容分离:</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">input:</span>  <span class="hljs-attr">conversation:</span> <span class="hljs-string">{required:</span> <span class="hljs-literal">true</span><span class="hljs-string">}</span><span class="hljs-attr">output:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>  <span class="hljs-attr">properties:</span>    <span class="hljs-attr">Intent:</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">"string"</span>    <span class="hljs-attr">Reason:</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">"string"</span><span class="hljs-meta">---</span><span class="hljs-attr">system:</span> <span class="hljs-string">Carefully</span> <span class="hljs-string">Think</span> <span class="hljs-string">about</span> <span class="hljs-string">the</span> <span class="hljs-string">intent</span> <span class="hljs-string">of</span> <span class="hljs-string">following</span> <span class="hljs-string">The</span> <span class="hljs-string">CONVERSATION</span> <span class="hljs-string">user</span> <span class="hljs-string">provided.</span> <span class="hljs-string">Output</span> <span class="hljs-string">the</span> <span class="hljs-string">json</span> <span class="hljs-string">object</span> <span class="hljs-string">with</span> <span class="hljs-string">the</span> <span class="hljs-string">Intent</span> <span class="hljs-string">Category</span> <span class="hljs-string">and</span> <span class="hljs-string">Reason.</span><span class="hljs-attr">user:</span> <span class="hljs-string">|-  The CONVERSATION:  {{ conversation }}</span></code></pre><p>这样就感觉好多了。</p><h3 id="an-xu-ge-shi-hua-xiao-xi" class="heading-control">按需格式化消息<a class="heading-anchor" href="#an-xu-ge-shi-hua-xiao-xi" aria-hidden="true"></a></h3><p>在使用过程中，我发现我大多数时候都需要延迟对消息进行格式化，太早格式化消息会因为消息被提前固化，而导致消息中不是我期望的参数值。因此，加入了按需格式化消息功能，并设置为默认。该功能可以通过设置参数<code>formatStringStrategy</code>进行改变:</p><ul><li><code>Raw</code>: 不做任何的格式化</li><li><code>Deferred</code>: 按需格式化，默认策略</li><li><code>Immediate</code>: 立即格式化</li></ul><p>例外，当执行<code>$set</code>, <code>$get</code>, <code>$ret</code>，<code>$echo</code>操作时会立即对消息进行格式化。</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 修改本脚本的默认消息格式化策略：</span><span class="hljs-attr">formatStringStrategy:</span> <span class="hljs-string">Immediate</span><span class="hljs-meta">---</span></code></pre><h3 id="ti-shi-ci-tiao-yong-yu-dai-ma-ji-cheng" class="heading-control">提示词调用与代码集成<a class="heading-anchor" href="#ti-shi-ci-tiao-yong-yu-dai-ma-ji-cheng" aria-hidden="true"></a></h3><p>那么如何在提示词中使用(调用)AI赋值以及其他提示词或代码？于是有了<code>高级替换</code>:</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 导入js函数</span><span class="hljs-attr">import:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">eval.js</span><span class="hljs-meta">---</span><span class="hljs-comment"># JOKE会被AI赋值,存放于: `prompt.JOKE` 中，供下次使用</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"讲个笑话：[[JOKE]] 希望您喜欢！"</span><span class="hljs-comment"># 调用外部提示词`calculator`</span><span class="hljs-attr">user:</span> <span class="hljs-string">"五加二等于 [[@calculator("</span><span class="hljs-number">5</span><span class="hljs-string">+2")]]"</span><span class="hljs-comment"># 调用函数代码`eval`</span><span class="hljs-attr">user:</span> <span class="hljs-string">"五加二等于 [[@$eval("</span><span class="hljs-number">5</span><span class="hljs-string">+2")]]"</span></code></pre><pre><code class="js"><span class="hljs-comment">// eval.js</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eval</span>(<span class="hljs-params">value</span>) </span>{  <span class="hljs-keyword">return</span> ...}</code></pre><p>甚至支持了让AI只能在我给的列表中选择:</p><pre><code class="yaml"><span class="hljs-attr">user:</span> <span class="hljs-string">你喜欢什么水果?</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"我超喜欢[[FRUIT:|苹果|香蕉|橙子]]"</span></code></pre><h3 id="lian-shi-tiao-yong-yu-can-shu-chuan-di" class="heading-control">链式调用与参数传递<a class="heading-anchor" href="#lian-shi-tiao-yong-yu-can-shu-chuan-di" aria-hidden="true"></a></h3><p>如何将最近消息内容传递给外部提示词？通过箭头符号<code>-&gt;</code>来实现动态参数传递:</p><pre><code class="yaml"><span class="hljs-attr">user:</span> <span class="hljs-string">"讲个笑话吧！"</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[JOKE]]"</span><span class="hljs-comment"># 传入智能体的实际输入参数是: {content: "[这里是由AI生成的笑话]", target_lang: "葡萄牙语"}</span><span class="hljs-string">-&gt;</span> <span class="hljs-string">translator(target_lang="葡萄牙语")</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">$print</span></code></pre><h3 id="zai-yi-lai-de-js-jiao-ben-zhong-tiao-yong-wai-bu-ti-shi-ci" class="heading-control">在依赖的js脚本中调用外部提示词<a class="heading-anchor" href="#zai-yi-lai-de-js-jiao-ben-zhong-tiao-yong-wai-bu-ti-shi-ci" aria-hidden="true"></a></h3><p>那么，反过来，如何在依赖的js脚本调用外部提示词呢?</p><pre><code class="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callPPEScriptDemo</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.$exec({<span class="hljs-attr">id</span>: <span class="hljs-string">'calculator'</span>, <span class="hljs-attr">args</span>:{ <span class="hljs-attr">content</span>: <span class="hljs-string">"6+3"</span> }})}</code></pre><h3 id="nei-zhi-han-shu-zhi-ling-yu-luo-ji-kong-zhi" class="heading-control">内置函数指令与逻辑控制<a class="heading-anchor" href="#nei-zhi-han-shu-zhi-ling-yu-luo-ji-kong-zhi" aria-hidden="true"></a></h3><p>有些时候，我需要在提示词中根据不同条件来产生不同的提示词，甚至需要多条件匹配，于是开始内置相应的函数指令: <code>$if</code>, <code>$match</code>, …</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">input:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">file</span><span class="hljs-meta">---</span><span class="hljs-bullet">-</span> <span class="hljs-string">$if:</span> <span class="hljs-string">"this.file"</span>  <span class="hljs-attr">then:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">...</span></code></pre><p>并发测试服务提供商的不同模型:</p><pre><code class="yaml"><span class="hljs-string">$match(true,</span> <span class="hljs-string">allMatches=true,</span> <span class="hljs-string">parallel=true):</span>  <span class="hljs-string">:true:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$AI(pushMessage=false,</span> <span class="hljs-string">model="openai://Qwen/Qwen2.5-Coder-7B-Instruct",</span> <span class="hljs-string">apiUrl="https://api.siliconflow.cn/",</span> <span class="hljs-string">apiKey="...")</span>  <span class="hljs-string">:true:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$AI(pushMessage=false,</span> <span class="hljs-string">model="openai://THUDM/glm-4-9b-chat",</span> <span class="hljs-string">apiUrl="https://api.siliconflow.cn/",</span> <span class="hljs-string">apiKey="...")</span></code></pre><p>随后，完善了循环控制函数指令: <code>$for</code>, <code>$while</code></p><h3 id="huan-cun-ji-zhi-yu-xing-neng-you-hua" class="heading-control">缓存机制与性能优化<a class="heading-anchor" href="#huan-cun-ji-zhi-yu-xing-neng-you-hua" aria-hidden="true"></a></h3><p>然后，发现这个提示词&quot;函数&quot;执行耗时长，如果多次反复执行同一参数的&quot;函数&quot;就更浪费时间了，为啥不能缓存结果？于是有了LRU缓存执行结果，所有的外部调用脚本结果默认都会被缓存，当然可以简单通过参数开关<code>memoized</code>关闭该行为：</p><pre><code class="yaml"><span class="hljs-string">"[[@calculator(content="</span><span class="hljs-number">5</span><span class="hljs-string">+2",</span> <span class="hljs-string">memoized=false)]]"</span></code></pre><h3 id="da-mo-xing-de-jie-gou-hua-shu-chu" class="heading-control">大模型的结构化输出<a class="heading-anchor" href="#da-mo-xing-de-jie-gou-hua-shu-chu" aria-hidden="true"></a></h3><p>大模型必须对输出进行结构化（约定输出），程序代码函数才能处理。通常我们约定的是大模型结构化输出JSON对象。</p><p>我在实践中发现，对于推理任务，在不约束大模型输出类型的情况下，输出质量更好，而对于不需要推理的分类任务，则恰恰相反。关于这个，有人已经做了更详细的比较: <a href="https://arxiv.org/html/2408.02442v1" target="_blank" rel="noopener">Let Me Speak Freely? A Study on the Impact of Format Restrictions on Performance of Large Language Models</a></p><p>另外，对大模型进行约定输出格式的文本格式也会影响输出质量，也就是告诉它如何输出的方式。用自然语言表达形式，好于直接给定json.</p><p>我测试下来，对于目前大多数 LLM 模型来讲 <code>自然语言 &gt; YAML &gt; XML &gt; JSON</code>，当然具体还要看个别模型是否对某个格式又做了针对性的学习。</p><p>因此，我设计了多种结构化响应输出格式类型，用来自动将输出内容和格式告诉给大模型，以及将大模型的输出自动转换。</p><ul><li>多种结构化响应输出格式类型(<code>response_format.type</code>)支持:<ul><li>JSON 格式</li><li>YAML 格式</li><li>自然语言对象(NOBJ) 格式</li><li>用JSON Schema格式设置好<code>output</code>.PPE就会自动解析AI生成的对应格式的内容为<code>Object</code>供代码使用.</li></ul></li></ul><p>约定PPE脚本输出内容始终用<code>JSON Schema</code>表示，而选择告知大模型的方式则在<code>parameters.response_format.type</code>中控制。这样，最终给到代码这边的结果始终是转换后的<code>JSON</code>对象。如果转换失败，会触发异常错误，通过设置<code>forceJson</code>为<code>false</code>禁止触发异常，这时当无法转换，就会返回文本内容。</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">output:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">"object"</span>  <span class="hljs-attr">properties:</span>    <span class="hljs-attr">target_text:</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">"string"</span><span class="hljs-attr">parameters:</span>  <span class="hljs-comment"># 使用后面的参数,将设置强制json输出格式,确保大模型总是输出正确的json格式.</span>  <span class="hljs-attr">response_format:</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">"json"</span><span class="hljs-comment"># forceJson: false</span><span class="hljs-meta">---</span></code></pre><h3 id="duo-lun-dui-hua-zhi-chi" class="heading-control">多轮对话支持<a class="heading-anchor" href="#duo-lun-dui-hua-zhi-chi" aria-hidden="true"></a></h3><p>如何在同一个脚本中开启多轮对话，于是有了三个短划线(<code>---</code>) 或星号 <code>***</code> 表示一个新的对话开始:</p><pre><code class="yaml"><span class="hljs-attr">system:</span> <span class="hljs-string">"您是一位AI助手。"</span><span class="hljs-comment"># 第一个分隔线作为对话的起点,第一个分隔线上面的对话内容会被隐藏，可以当作系统提示词,它们不会被输出或记录.</span><span class="hljs-meta">---</span><span class="hljs-string">"10加18等于多少？"</span><span class="hljs-comment"># 执行AI,替换为AI传回的结果result</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[result]]"</span><span class="hljs-comment"># 打印大模型传回的结果</span><span class="hljs-string">$print:</span> <span class="hljs-string">"?=result"</span><span class="hljs-comment"># 第二个分隔线下面开始新对话,回到第一次的起点</span><span class="hljs-meta">---</span><span class="hljs-attr">user:</span> <span class="hljs-string">"10加12等于多少？"</span><span class="hljs-comment"># 执行AI,替换为AI传回的结果result</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[result]]"</span></code></pre><h3 id="ji-cheng-ji-zhi-ti-shi-ci-de-lei" class="heading-control">继承机制：提示词的“类”<a class="heading-anchor" href="#ji-cheng-ji-zhi-ti-shi-ci-de-lei" aria-hidden="true"></a></h3><p><strong>基类定义</strong>（<code>char.ai.yaml</code>）：</p><pre><code class="yaml"><span class="hljs-attr">type:</span> <span class="hljs-string">type</span><span class="hljs-comment"># 定义该角色类型的输入配置</span><span class="hljs-attr">input:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">{required:</span> <span class="hljs-literal">true</span><span class="hljs-string">}</span>  <span class="hljs-comment"># 必须提供的信息：角色的名字</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">description</span>             <span class="hljs-comment"># 可选的信息：对角色的描述</span><span class="hljs-meta">---</span><span class="hljs-comment"># 系统根据提供的信息来指导角色的行为</span><span class="hljs-attr">system:</span> <span class="hljs-string">|-  你是一个聪明、多才多艺的角色扮演者。  你的任务是根据下面提供的信息完美地扮演角色。  请说话就像{{name}}一样。  你就是{{name}}。</span>  <span class="hljs-string">{{description}}</span></code></pre><p><strong>子类实现</strong>（<code>char_dobby.ai.yaml</code>）：</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 表示继承自char角色类型脚本</span><span class="hljs-attr">type:</span> <span class="hljs-string">char</span><span class="hljs-comment"># 这里是根据“char”角色的一些具体设置</span><span class="hljs-comment"># 角色的名字</span><span class="hljs-attr">name:</span> <span class="hljs-string">"Dobby"</span><span class="hljs-comment"># 对角色的描述</span><span class="hljs-attr">description:</span> <span class="hljs-string">"Dobby 是哈利波特世界里的一个小精灵"</span><span class="hljs-meta">---</span><span class="hljs-comment"># 用户提问</span><span class="hljs-attr">user:</span> <span class="hljs-string">"你是谁?"</span><span class="hljs-meta">---</span><span class="hljs-comment"># 根据角色设定的回答</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"我是 Dobby。Dobby 很开心。"</span></code></pre><h3 id="duo-zhi-neng-ti-qun-liao-guan-li-yu-si-liao" class="heading-control">多智能体群聊管理与私聊<a class="heading-anchor" href="#duo-zhi-neng-ti-qun-liao-guan-li-yu-si-liao" aria-hidden="true"></a></h3><p>群聊咋弄?通过<code>roles</code>约定使用的外部角色列表:</p><pre><code class="yaml"><span class="hljs-comment"># guide.ai.yaml</span><span class="hljs-meta">---</span><span class="hljs-attr">description:</span> <span class="hljs-string">"You are a professional guide. You can guide the user to complete the task."</span><span class="hljs-attr">name:</span> <span class="hljs-string">"guide"</span><span class="hljs-comment"># 约定使用的角色列表，key为角色别名，值为角色脚本ID</span><span class="hljs-attr">roles:</span>  <span class="hljs-attr">translator:</span> <span class="hljs-string">char_translator</span>  <span class="hljs-attr">dobby:</span> <span class="hljs-string">char_dobby</span><span class="hljs-meta">---</span><span class="hljs-attr">system:</span> <span class="hljs-string">You</span> <span class="hljs-string">are</span> <span class="hljs-string">a</span> <span class="hljs-string">professional</span> <span class="hljs-string">guide.</span> <span class="hljs-string">You</span> <span class="hljs-string">can</span> <span class="hljs-string">guide</span> <span class="hljs-string">the</span> <span class="hljs-string">user</span> <span class="hljs-string">to</span> <span class="hljs-string">complete</span> <span class="hljs-string">the</span> <span class="hljs-string">task.</span><span class="hljs-string">---</span> <span class="hljs-comment"># New dialogue starts here</span><span class="hljs-comment"># 用户对dobby说，dobby脚本自动（一定）回复</span><span class="hljs-attr">user:</span> <span class="hljs-string">"@dobby, I want to go to the moon."</span><span class="hljs-comment"># guide 对translator说</span><span class="hljs-attr">guide:</span> <span class="hljs-string">"@translator, translate the dobby's message to chinese without explanation."</span><span class="hljs-attr">user:</span> <span class="hljs-string">How</span> <span class="hljs-string">to</span> <span class="hljs-string">go</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">moon?</span><span class="hljs-attr">dobby:</span> <span class="hljs-string">"[[AI]]"</span></code></pre><p>那么，如何在群聊中进行私聊？简单，在<code>@dobby</code>后加上参数<code>@dobby(私)</code>即可，这样dobby的回复只有该用户可见，聊天室中其他角色看不到。</p><h3 id="nei-jian-ben-di-llm-ti-gong-shang" class="heading-control">内建本地LLM提供商<a class="heading-anchor" href="#nei-jian-ben-di-llm-ti-gong-shang" aria-hidden="true"></a></h3><p>当前，外置的llama-cpp server已经满足不了我的需求:</p><ol><li>无法动态加载切换LLM大模型</li><li>无法对提示词进行安全控制<ol><li>系统模板反注入</li><li>提示词保护</li></ol></li><li>无法自动适配硬件: 自动检测内存和GPU，并默认使用最佳计算层，自动分配gpu-layers以及上下文窗口大小, 以便从硬件中获得最佳性能，无需手动配置任何内容。</li><li>无法为指定的单词提升/降低权重，类似在stable-diffusion中（暂未实现）</li></ol><p>因此开发实现了内置的本地LLM提供商.</p><ul><li><p>支持多LLM服务提供商：</p><ul><li>（<strong>推荐</strong>）**内置本地LLM提供商（llama.cpp）**作为默认选项，以保护知识的安全性和隐私。<ul><li>首先下载GGUF模型文件：<code>ai brain download hf://bartowski/Qwen_QwQ-32B-GGUF -q q4_0</code></li><li>使用默认的大脑模型文件运行：<code>ai run example.ai.yaml</code></li><li>使用指定的模型文件运行：<code>ai run example.ai.yaml -P local://bartowski-qwq-32b.Q4_0.gguf</code></li></ul></li><li>兼容OpenAI的服务提供商：<ul><li>OpenAI: <code>ai run example.ai.yaml -P openai://chatgpt-4o-latest --apiKey “sk-XXX”</code></li><li>DeepSeek: <code>ai run example.ai.yaml -P openai://deepseek-chat -u https://api.deepseek.com/ --apiKey “sk-XXX”</code></li><li>Siliconflow: <code>ai run example.ai.yaml -P openai://Qwen/Qwen2.5-Coder-7B-Instruct -u https://api.siliconflow.cn/ --apiKey “sk-XXX”</code></li><li>Anthropic(Claude): <code>ai run example.ai.yaml -P openai://claude-3-7-sonnet-latest -u https://api.anthropic.com/v1/ --apiKey “sk-XXX”</code></li></ul></li><li><a href="https://github.com/ggml-org/llama.cpp/tree/master/examples/server" target="_blank" rel="noopener">llama-cpp服务器(llama-server)提供商</a>：<code>ai run example.ai.yaml -P llamacpp</code><ul><li>llama-cpp服务器不支持指定模型名称，它是在启动llama-server时通过 model 参数指定的。</li></ul></li><li>您可以在PPE脚本中指定或任意切换<em>LLM模型或提供商</em>:</li></ul><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">parameters:</span>  <span class="hljs-attr">model:</span> <span class="hljs-string">openai://deepseek-chat</span>  <span class="hljs-attr">apiUrl:</span> <span class="hljs-string">https://api.deepseek.com/</span>  <span class="hljs-attr">apiKey:</span> <span class="hljs-string">"sk-XXX"</span><span class="hljs-meta">---</span><span class="hljs-attr">system:</span> <span class="hljs-string">You</span> <span class="hljs-string">are</span> <span class="hljs-string">a</span> <span class="hljs-string">helpful</span> <span class="hljs-string">assistant.</span><span class="hljs-attr">user:</span> <span class="hljs-string">"tell me a joke"</span><span class="hljs-string">---</span> <span class="hljs-comment"># first dialog begin</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[AI]]"</span><span class="hljs-string">---</span> <span class="hljs-comment"># reset to first</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[AI:model='openai://claude-3-7-sonnet-latest',apiUrl='https://api.anthropic.com/v1/',apiKey='sk-XXX']]"</span><span class="hljs-string">---</span> <span class="hljs-comment"># reset to first</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[AI:model='local://bartowski-qwq-32b.Q4_0.gguf']]"</span></code></pre></li></ul><h3 id="tong-yong-da-mo-xing-gong-ju-an-quan-tiao-yong-jin-xian-nei-zhi-de-llm-ti-gong-shang" class="heading-control">通用大模型工具安全调用(仅限内置的LLM提供商)<a class="heading-anchor" href="#tong-yong-da-mo-xing-gong-ju-an-quan-tiao-yong-jin-xian-nei-zhi-de-llm-ti-gong-shang" aria-hidden="true"></a></h3><p>让大模型自主使用工具(Tool Func)的确很方便，可以直接实现大模型的全自动化，但是如何保证安全呢？还有为啥必须要特别训练的大模型才能支持工具调用？有没有通用的办法，无需特别针对训练，让所有的大模型都支持工具调用？如何让工具的使用更加简单？ 答案是有的，终于搞定，下面请看:</p><p>通过<code>tools</code>配置限制可调用的工具：</p><pre><code class="yaml"><span class="hljs-comment"># 只要在脚本配置中设定允许智能体使用的工具`tools`， 这些工具`tools`对应PPE脚本ID，智能体就会在需要的时候自主调用这些工具完成任务。</span><span class="hljs-meta">---</span><span class="hljs-attr">tools:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">weather</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">search</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">now</span><span class="hljs-meta">---</span><span class="hljs-attr">user:</span> <span class="hljs-string">现在几点了？今天上海的天气如何？</span><span class="hljs-comment">#智能体会根据配置的tools调用对应的工具: now, weather,并返回结果</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[Answer]]"</span></code></pre><pre><code class="yaml"><span class="hljs-comment"># weather.ai.yaml</span><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">get</span> <span class="hljs-string">weather</span> <span class="hljs-string">information</span><span class="hljs-attr">input:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">location:</span>      <span class="hljs-attr">description:</span> <span class="hljs-string">contain</span> <span class="hljs-string">city,</span> <span class="hljs-string">province(if</span> <span class="hljs-string">any)</span> <span class="hljs-string">and</span> <span class="hljs-string">country</span>      <span class="hljs-attr">example:</span> <span class="hljs-string">city,province,country</span>      <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">date:</span>      <span class="hljs-attr">description:</span> <span class="hljs-string">the</span> <span class="hljs-string">weather</span> <span class="hljs-string">information</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">specified</span> <span class="hljs-string">date</span>      <span class="hljs-attr">example:</span> <span class="hljs-number">2025</span><span class="hljs-number">-02</span><span class="hljs-string">-04T18:07:42+08:00</span>      <span class="hljs-attr">default:</span> <span class="hljs-string">today</span><span class="hljs-meta">---</span><span class="hljs-comment"># 模拟返回天气信息</span><span class="hljs-string">$echo:</span> <span class="hljs-string">"上海的天气阴转多云，气温 2°C，相对湿度 60%，风向 东南风，风力 3-4级。"</span></code></pre><p>为了进一步保障安全，除了限定执行脚本设定的工具列表外，用户（调用方）也可限制使用的工具列表，进行双重限制:</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 用户或上级脚本通过如下配置对智能体使用的工具进行权限控制</span><span class="hljs-attr">permissions:</span>  <span class="hljs-attr">ai:</span>    <span class="hljs-attr">call:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"w*"</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"now"</span><span class="hljs-meta">---</span></code></pre><h3 id="tong-yong-da-mo-xing-si-wei-mo-shi-kuo-zhan-jin-xian-nei-zhi-de-llm-ti-gong-shang" class="heading-control">通用大模型思维模式扩展 🧠 (仅限内置的LLM提供商)<a class="heading-anchor" href="#tong-yong-da-mo-xing-si-wei-mo-shi-kuo-zhan-jin-xian-nei-zhi-de-llm-ti-gong-shang" aria-hidden="true"></a></h3><p>DeepSeek 重新发现并开源了OpenAI(CloseAI)了秘而不宣的深度思维模式的训练办法，那么有没有一种可能，不需要额外训练，让AI大模型也能进行深度思考？应该可行，因为所谓的微调训练也是基于CoT的提示词进行，于是经过仔细思考，多番测试，终于搞定包括深度思维模式在内的多种思维模式(<code>shouldThink</code>)！</p><p>思维模式(<code>shouldThink</code>)我分为四种：直接回答不思考(<code>off</code>)；先回答再思考(<code>last</code>)；先思考再回答<code>first</code>；深度思考后再回答<code>deep</code>：</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 思维模式默认为 `off`,设置为last，first,deep后自动启用。</span><span class="hljs-attr">shouldThink:</span> <span class="hljs-string">deep</span><span class="hljs-meta">---</span><span class="hljs-attr">user:</span> <span class="hljs-string">树上有15只鸟，猎人开枪打中了2只，树上还有几只鸟？</span></code></pre><h3 id="package-zhi-chi" class="heading-control">Package 支持<a class="heading-anchor" href="#package-zhi-chi" aria-hidden="true"></a></h3><p>目的：需要将相关的提示词和代码脚本、知识库放到一个文件包中，组成智能体，方便管理。</p><p>通过这些设计，PPE 正在逐步支持我最初对「真 AI PC」的想象！🚀</p><p>尽管还处于WIP阶段，不过 PPE 已经实现了我设想的大部分功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;cong-tou-shou-cuo-mian-xiang-ying-yong-de-ai-kuang-jia&quot; class=&quot;heading-control&quot;&gt;🌟 从头手搓面向应用的AI框架 🚀&lt;a class=&quot;heading-anchor&quot; href=&quot;#cong-tou-shou-cuo-mian-xiang-ying-yong-de-ai-kuang-jia&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;wei-shi-mo-cong-tou-shou-cuo-ai-kuang-jia-er-bu-shi-shi-yong-xian-you-kuang-jia&quot; class=&quot;heading-control&quot;&gt;为什么从头手搓 AI 框架，而不是使用现有框架？&lt;a class=&quot;heading-anchor&quot; href=&quot;#wei-shi-mo-cong-tou-shou-cuo-ai-kuang-jia-er-bu-shi-shi-yong-xian-you-kuang-jia&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;💡 为啥我要从头手搓AI框架，而不是直接使用类似 langchain、AutoGen、LMQL 等现成框架呢？&lt;/p&gt;
&lt;p&gt;最初我也尝试了多个框架（包括LangChain、AutoGen、LMQL、Outlines、MemGPT等），但它们都无法完全满足我的需求。我想要的是一个&lt;strong&gt;极度灵活可配置的AI应用框架&lt;/strong&gt;，用来打造我设想的&lt;code&gt;「真·AI PC」&lt;/code&gt;——而非当前大多数AI产品那种“远程AI服务+本地空壳”的模式。&lt;/p&gt;
&lt;p&gt;在当前阶段，我认为面向应用的AI框架应聚焦于&lt;strong&gt;提示词（Prompt）的工程化&lt;/strong&gt;——这是人类与AI交互的唯一桥梁。我的核心目标是：&lt;br&gt;
✅ 将提示词转化为可编程的“函数”或“类”，支持自由组合、独立调用，并能持续迭代优化。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PPE 可编程提示词工程引擎草案开发摘要</title>
    <link href="https://riceball.me/article/ppe_dev_summary/"/>
    <id>https://riceball.me/article/ppe_dev_summary/</id>
    <published>2024-12-15T20:00:00.000Z</published>
    <updated>2024-12-16T16:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2025-nian-13-yue" class="heading-control">2025年1-3月<a class="heading-anchor" href="#2025-nian-13-yue" aria-hidden="true"></a></h2><h3 id="nei-jian-llm-ti-gong-shang" class="heading-control">内建LLM提供商<a class="heading-anchor" href="#nei-jian-llm-ti-gong-shang" aria-hidden="true"></a></h3><p>当前，外置的llama-cpp server已经满足不了我的需求:</p><ol><li>无法动态加载切换LLM大模型</li><li>无法对提示词进行安全控制<ol><li>系统模板反注入</li><li>提示词保护</li></ol></li><li>无法自动适配硬件: 自动检测内存和GPU，并默认使用最佳计算层，自动分配gpu-layers以及上下文窗口大小, 以便从硬件中获得最佳性能，无需手动配置任何内容。</li><li>无法为指定的单词提升/降低权重，类似在stable-diffusion中（暂未实现）</li></ol><p>因此开发实现了内置的本地LLM提供商.</p><ul><li><p>支持多LLM服务提供商：</p><ul><li>（<strong>推荐</strong>）**内置本地LLM提供商（llama.cpp）**作为默认选项，以保护知识的安全性和隐私。<ul><li>首先下载GGUF模型文件：<code>ai brain download hf://bartowski/Qwen_QwQ-32B-GGUF -q q4_0</code></li><li>使用默认的大脑模型文件运行：<code>ai run example.ai.yaml</code></li><li>使用指定的模型文件运行：<code>ai run example.ai.yaml -P local://bartowski-qwq-32b.Q4_0.gguf</code></li></ul></li><li>兼容OpenAI的服务提供商：<ul><li>OpenAI: <code>ai run example.ai.yaml -P openai://chatgpt-4o-latest --apiKey “sk-XXX”</code></li><li>DeepSeek: <code>ai run example.ai.yaml -P openai://deepseek-chat -u https://api.deepseek.com/ --apiKey “sk-XXX”</code></li><li>Siliconflow: <code>ai run example.ai.yaml -P openai://Qwen/Qwen2.5-Coder-7B-Instruct -u https://api.siliconflow.cn/ --apiKey “sk-XXX”</code></li><li>Anthropic(Claude): <code>ai run example.ai.yaml -P openai://claude-3-7-sonnet-latest -u https://api.anthropic.com/v1/ --apiKey “sk-XXX”</code></li></ul></li><li><a href="https://github.com/ggml-org/llama.cpp/tree/master/examples/server" target="_blank" rel="noopener">llama-cpp服务器(llama-server)提供商</a>：<code>ai run example.ai.yaml -P llamacpp</code><ul><li>llama-cpp服务器不支持指定模型名称，它是在启动llama-server时通过 model 参数指定的。</li></ul></li><li>您可以在PPE脚本中指定或任意切换<em>LLM模型或提供商</em>:</li></ul><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">parameters:</span>  <span class="hljs-attr">model:</span> <span class="hljs-string">openai://deepseek-chat</span>  <span class="hljs-attr">apiUrl:</span> <span class="hljs-string">https://api.deepseek.com/</span>  <span class="hljs-attr">apiKey:</span> <span class="hljs-string">"sk-XXX"</span><span class="hljs-meta">---</span><span class="hljs-attr">system:</span> <span class="hljs-string">You</span> <span class="hljs-string">are</span> <span class="hljs-string">a</span> <span class="hljs-string">helpful</span> <span class="hljs-string">assistant.</span><span class="hljs-attr">user:</span> <span class="hljs-string">"tell me a joke"</span><span class="hljs-string">---</span> <span class="hljs-comment"># first dialog begin</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[AI]]"</span><span class="hljs-string">---</span> <span class="hljs-comment"># reset to first</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[AI:model='openai://claude-3-7-sonnet-latest',apiUrl='https://api.anthropic.com/v1/',apiKey='sk-XXX']]"</span><span class="hljs-string">---</span> <span class="hljs-comment"># reset to first</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[AI:model='local://bartowski-qwq-32b.Q4_0.gguf']]"</span></code></pre></li></ul><h3 id="tong-yong-da-mo-xing-tool-gong-ju-an-quan-tiao-yong-jin-xian-nei-zhi-de-llm-ti-gong-shang" class="heading-control">通用大模型Tool(工具)安全调用(仅限内置的LLM提供商)<a class="heading-anchor" href="#tong-yong-da-mo-xing-tool-gong-ju-an-quan-tiao-yong-jin-xian-nei-zhi-de-llm-ti-gong-shang" aria-hidden="true"></a></h3><p>让大模型自主使用工具(Tool Func)的确很方便，可以直接实现大模型的全自动化，但是如何保证安全呢？还有为啥必须要特别训练的大模型才能支持工具调用？有没有通用的办法，无需特别针对训练，让所有的大模型都支持工具调用？如何让工具的使用更加简单？ 答案是有的，终于搞定，下面请看:</p><p>通过<code>tools</code>配置限制可调用的工具：</p><pre><code class="yaml"><span class="hljs-comment"># 只要在脚本配置中设定允许智能体使用的工具`tools`， 这些工具`tools`对应PPE脚本ID，智能体就会在需要的时候自主调用这些工具完成任务。</span><span class="hljs-meta">---</span><span class="hljs-attr">tools:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">weather</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">search</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">now</span><span class="hljs-meta">---</span><span class="hljs-attr">user:</span> <span class="hljs-string">现在几点了？今天上海的天气如何？</span><span class="hljs-comment">#智能体会根据配置的tools调用对应的工具: now, weather,并返回结果</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">"[[Answer]]"</span></code></pre><pre><code class="yaml"><span class="hljs-comment"># weather.ai.yaml</span><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">get</span> <span class="hljs-string">weather</span> <span class="hljs-string">information</span><span class="hljs-attr">input:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">location:</span>      <span class="hljs-attr">description:</span> <span class="hljs-string">contain</span> <span class="hljs-string">city,</span> <span class="hljs-string">province(if</span> <span class="hljs-string">any)</span> <span class="hljs-string">and</span> <span class="hljs-string">country</span>      <span class="hljs-attr">example:</span> <span class="hljs-string">city,province,country</span>      <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">date:</span>      <span class="hljs-attr">description:</span> <span class="hljs-string">the</span> <span class="hljs-string">weather</span> <span class="hljs-string">information</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">specified</span> <span class="hljs-string">date</span>      <span class="hljs-attr">example:</span> <span class="hljs-number">2025</span><span class="hljs-number">-02</span><span class="hljs-string">-04T18:07:42+08:00</span>      <span class="hljs-attr">default:</span> <span class="hljs-string">today</span><span class="hljs-meta">---</span><span class="hljs-comment"># 模拟返回天气信息</span><span class="hljs-string">$echo:</span> <span class="hljs-string">"上海的天气阴转多云，气温 2°C，相对湿度 60%，风向 东南风，风力 3-4级。"</span></code></pre><p>为了进一步保障安全，除了限定执行脚本设定的工具列表外，用户（调用方）也可限制使用的工具列表，进行双重限制:</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 用户或上级脚本通过如下配置对智能体使用的工具进行权限控制</span><span class="hljs-attr">permissions:</span>  <span class="hljs-attr">ai:</span>    <span class="hljs-attr">call:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"w*"</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">"now"</span><span class="hljs-meta">---</span></code></pre><h3 id="tong-yong-da-mo-xing-si-wei-mo-shi-kuo-zhan-jin-xian-nei-zhi-de-llm-ti-gong-shang" class="heading-control">通用大模型思维模式扩展 🧠 (仅限内置的LLM提供商)<a class="heading-anchor" href="#tong-yong-da-mo-xing-si-wei-mo-shi-kuo-zhan-jin-xian-nei-zhi-de-llm-ti-gong-shang" aria-hidden="true"></a></h3><p>DeepSeek 重新发现并开源了OpenAI(CloseAI)了秘而不宣的深度思维模式的训练办法，那么有没有一种可能，不需要额外训练，让AI大模型也能进行深度思考？应该可行，因为所谓的微调训练也是基于CoT的提示词进行，于是经过仔细思考，多番测试，终于搞定包括深度思维模式在内的多种思维模式(<code>shouldThink</code>)！</p><p>思维模式(<code>shouldThink</code>)我分为四种：直接回答不思考(<code>off</code>)；先回答再思考(<code>last</code>)；先思考再回答<code>first</code>；深度思考后再回答<code>deep</code>：</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 思维模式默认为 `off`,设置为last，first,deep后自动启用。</span><span class="hljs-attr">shouldThink:</span> <span class="hljs-string">deep</span><span class="hljs-meta">---</span><span class="hljs-attr">user:</span> <span class="hljs-string">树上有15只鸟，猎人开枪打中了2只，树上还有几只鸟？</span></code></pre><h3 id="package-zhi-chi" class="heading-control">Package 支持<a class="heading-anchor" href="#package-zhi-chi" aria-hidden="true"></a></h3><p>目的：需要将相关的提示词和代码脚本、知识库放到一个文件包中，组成智能体，方便管理。</p><hr><p>Old Histories:</p><h2 id="202410-yue" class="heading-control">2024-10月<a class="heading-anchor" href="#202410-yue" aria-hidden="true"></a></h2><h3 id="yu-yi-fen-ge-wen-ti" class="heading-control">语义分割问题<a class="heading-anchor" href="#yu-yi-fen-ge-wen-ti" aria-hidden="true"></a></h3><p>目前，langchain 和 llamaindex 都缺乏基于语义分割的分片机制，这会导致文本重叠和信息冗余。</p><h4 id="jie-jue-fang-an" class="heading-control">解决方案<a class="heading-anchor" href="#jie-jue-fang-an" aria-hidden="true"></a></h4><p>我计划采用基于语义分割的分片方法，将文本分割成语义完整且独立的块。</p><ul><li><strong>分句功能</strong><ul><li>最小切分单位为句子，并使用基于标点符号的分句方法进行分割，并将标题独立为句。</li><li>目前已完成的功能支持大部分印欧语系（空格分割）和中文，以及纯文本和markdown的处理。</li><li>如果单句超过 chunksize 就报错，chunksize 以 token 为单位。</li></ul></li><li><strong>语义分片 Agent</strong><ul><li>在前面分句的基础上，使用 PPE 提示词，通过插入分片标识引导模型进行语义分片。</li><li>由于性能问题，初始设计需要7B+ 的模型运行，无法在 3B 左右的模型上成功。</li><li>尝试了多种方法，包括：<ul><li>使用预训练好的语义分片模型</li><li>通过PPE提示词尝试不同的分片办法以及不同的格式(自然语言，MD，XML, JSON)<ul><li>只输出边界句子</li><li>评估句子和chunk之间的相似度</li><li>分步执行</li></ul></li><li>使用更小的模型进行分片</li></ul></li><li>最后，我放弃了自动生成的提示词，重新设计了基于自身理解的提示词，成功在 3B 模型上运行，同时提升了在更大的模型上的输出质量。</li></ul></li><li><strong>测试</strong><ul><li>使用 <code>JSON-Schema</code> 和 <code>diff</code> 验证语义分片结果的正确性。</li></ul></li></ul><h4 id="tiao-zhan" class="heading-control">挑战<a class="heading-anchor" href="#tiao-zhan" aria-hidden="true"></a></h4><ul><li><strong>模型差异:</strong> 不同模型对词汇的理解存在差异，导致同样的提示词无法在所有模型上有效。</li><li><strong>通用性:</strong> 需要针对不同的模型进行调整。</li></ul><details><summary>附录(点击展开详情)</summary><h4 id="fu-lu" class="heading-control">附录<a class="heading-anchor" href="#fu-lu" aria-hidden="true"></a></h4><p><a href="https://github.com/gkamradt/ChunkViz/" target="_blank" rel="noopener">https://github.com/gkamradt/ChunkViz/</a> 这个可以看langchain和llamaindex的text splitter的最终结果</p><p>基于语义分割那么就要<code>分段/分句/分词</code>, 我是从根据标点符号分句开始，也就是说chunk中的最小切分单位是句子，而现成的llamaindex的分句是有问题的，于是分句只能自己写。目前写的分句功能基本满足我自己的需要，语言支持大部分印欧语系（空格分割）和中文，文本类型支持纯文本和markdown的分句。如果单句超过chunksize就会报错，chunksize 以 token 为单位，用qwen2.5的tokenizer作为快速估算token大小。设计了分词 Agent，还没使用，性能问题，只能在7B以上的LLM跑，无解。</p><p>完成根据标点符号按句为最小单位拆分chunk功能,将标题作为单句处理。</p><p>设计语义分片 Agent（PPE 提示词），初步思路是通过插入分片标识让其对内容进行分片。</p><details><summary>附: 插入分片标识提示词(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-attr">description:</span> <span class="hljs-string">通过插入分片标识对内容进行分片</span><span class="hljs-attr">system:</span> <span class="hljs-string">|-  Objective: Divide a large text document part into manageable chunks for efficient processing by an LLM with a limited context window size.</span>  <span class="hljs-attr">Instructions:</span>  <span class="hljs-attr">1. Document Analysis:</span>      <span class="hljs-string">*</span> <span class="hljs-string">Carefully</span> <span class="hljs-string">read</span> <span class="hljs-string">the</span> <span class="hljs-string">provided</span> <span class="hljs-string">text</span> <span class="hljs-string">document.</span>      <span class="hljs-string">*</span> <span class="hljs-string">Identify</span> <span class="hljs-string">and</span> <span class="hljs-string">analyze</span> <span class="hljs-string">the</span> <span class="hljs-string">distinct</span> <span class="hljs-string">thematic</span> <span class="hljs-string">clusters</span> <span class="hljs-string">within</span> <span class="hljs-string">the</span> <span class="hljs-string">document.</span>  <span class="hljs-attr">2. Chunk Segmentation:</span>      <span class="hljs-string">*</span> <span class="hljs-string">Divide</span> <span class="hljs-string">the</span> <span class="hljs-string">document</span> <span class="hljs-string">into</span> <span class="hljs-string">chunks</span> <span class="hljs-string">based</span> <span class="hljs-string">on</span> <span class="hljs-string">these</span> <span class="hljs-string">thematic</span> <span class="hljs-string">clusters.</span>      <span class="hljs-string">*</span> <span class="hljs-string">Ensure</span> <span class="hljs-string">each</span> <span class="hljs-string">chunk</span> <span class="hljs-string">contains</span> <span class="hljs-string">content</span> <span class="hljs-string">related</span> <span class="hljs-string">to</span> <span class="hljs-string">a</span> <span class="hljs-string">single</span> <span class="hljs-string">or</span> <span class="hljs-string">closely</span> <span class="hljs-string">related</span> <span class="hljs-string">theme.</span>      <span class="hljs-string">*</span> <span class="hljs-string">Adhere</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">specified</span> <span class="hljs-string">context</span> <span class="hljs-string">window</span> <span class="hljs-string">size</span> <span class="hljs-string">limit</span> <span class="hljs-string">for</span> <span class="hljs-string">each</span> <span class="hljs-string">chunk.</span>  <span class="hljs-attr">Concise Output:</span>  <span class="hljs-string">*</span> <span class="hljs-string">Document</span> <span class="hljs-string">Output</span> <span class="hljs-string">ONLY</span> <span class="hljs-string">the</span> <span class="hljs-string">opening</span> <span class="hljs-string">sentence,</span> <span class="hljs-string">Replace</span> <span class="hljs-string">the</span> <span class="hljs-string">middle</span> <span class="hljs-string">content</span> <span class="hljs-string">with</span> <span class="hljs-string">`...`</span> <span class="hljs-string">(ellipsis)</span> <span class="hljs-string">and</span> <span class="hljs-string">closing</span> <span class="hljs-string">sentence</span> <span class="hljs-string">of</span> <span class="hljs-string">EACH</span> <span class="hljs-string">chunk.</span>  <span class="hljs-string">*</span> <span class="hljs-string">Insert</span> <span class="hljs-string">the</span> <span class="hljs-string">delimiter</span>  <span class="hljs-string">`&gt;&gt;&gt;CHUNK&lt;&lt;&lt;`</span> <span class="hljs-string">between</span> <span class="hljs-string">every</span> <span class="hljs-string">chunked</span> <span class="hljs-string">section</span> <span class="hljs-string">for</span> <span class="hljs-string">clear</span> <span class="hljs-string">separation.</span></code></pre><h2 id="less-than-details-greater-than" class="heading-control"><a class="heading-anchor" href="#less-than-details-greater-than" aria-hidden="true"></a></h2></details><p>注:</p><ul><li>最开始，语义分片只能在7B上跑，折腾了1周，无论怎么修改都无法在3B左右的模型上跑成功。</li><li>八万五千左右汉字（没有预处理的网上随便找的菜根谭全文注解纯文本，内容比较糟糕）用7B大约需要耗时半个多小时(GPU)才能完成分片。性能太差，这还只是分片阶段。</li><li>全文输出的原文是因为如果只让AI输出chunk边界句子，则对某些文章总是无法完全精确原样输出边界句子。</li></ul></details><h3 id="ppe-ke-bian-cheng-ti-shi-ci-gong-cheng-dan-yuan-ce-shi-zeng-jia-dui-jsonschema-de-zhi-chi" class="heading-control">PPE(可编程提示词工程) 单元测试增加对<code>JSON-Schema</code>的支持<a class="heading-anchor" href="#ppe-ke-bian-cheng-ti-shi-ci-gong-cheng-dan-yuan-ce-shi-zeng-jia-dui-jsonschema-de-zhi-chi" aria-hidden="true"></a></h3><p>为测试分片质量，PPE 提示词单元测试增加了对<code>JSON-Schema</code>的支持:</p><ul><li>如果PPE提示词脚本存在<code>output</code>配置(JSON-Schema)，将自动使用验证输出结果的JSON-Schema是否匹配</li><li>可以在单元测试使用<code>outputSchema</code>进行输出结果的JSON-Schema验证。</li><li>如果PPE提示词脚本<code>output</code>配置和单元测试中<code>outputSchema</code>同时存在，那么会以output配置作为默认值进行合并后验证。</li><li>可以使用开关<code>checkSchema: false</code>禁用JSON-Schema验证。默认启用。</li></ul><details><summary>附: 检测分片数量的测试用例(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">input:</span>    <span class="hljs-attr">content:</span> <span class="hljs-string">|-      菜根谭(全文附译文) 菜根谭(全文附译文)      1.弄权一时，凄凉万古      栖守道德者，寂寞一时；依阿权势者，凄凉万古。      达人观物外之物，思身后之身，守受一时之寂寞，毋取万古之凄凉。      【大意】 一个坚守道德规范的人，虽然有时会遭受短暂的冷落；可那些依附权势的人，却会遭受永久的凄凉。      大凡一个胸襟开阔的聪明人，能重视物质以外的精神价值，并且又能顾及到死后的名誉问题。      所以他们宁愿承受一时的冷落，也不愿遭受永久的凄凉。      2.抱朴守拙，涉世之道      涉世浅，点染亦浅；历事深，机械亦深。      故君子与其练达，不若朴鲁； 与其曲谨，不若疏狂。      【大意】 一个刚踏入社会的青年人阅历虽然很短浅，但是所受各种社会不良习惯的感染也比较少；一个饱经事故而阅历很广的人，各种恶习也随着增加。      所以一个有修养的君子，与其讲究做事的圆滑，倒不如保持朴实的个性；与其事事小心谨慎委曲求全，倒不如豁达一点才不会丧失纯真的本性。      3.心事宜明，才华须韫      君子之心事，天青日白；不可使人不知；君子之才华，玉韫珠藏，不可使人易知。      【大意】 一个有高深修养的君子，他的心地像青天白日一般光明，没有一点不可告人之事；一个有高深修养的君子，他的才学像珍珠美玉一般珍藏，绝对不轻易让人知道。</span>  <span class="hljs-comment"># 检查返回 sections 数组结果是否满足至少3项.</span>  <span class="hljs-attr">outputSchema:</span>    <span class="hljs-attr">properties:</span>      <span class="hljs-attr">sections:</span>        <span class="hljs-attr">minItems:</span> <span class="hljs-number">3</span></code></pre></details><h3 id="zi-dong-hua-ti-shi-ci-yu-shou-dong-ti-shi-ci" class="heading-control">自动化提示词与手动提示词<a class="heading-anchor" href="#zi-dong-hua-ti-shi-ci-yu-shou-dong-ti-shi-ci" aria-hidden="true"></a></h3><p>我不相信<code>语义分片 Agent</code>不能在3B左右的模型上跑，输出无意义的乱码. 但是这不应该,按照我的经验这是在3B的能力范围之内的，只是存在输出质量差异问题，而不应该是完全失败。</p><p>最终，我想到“语义分片 Agent 提示词”其实是我的“<code>自动提示词生成器</code>”辅助生成的。当我决定抛开这个工具，完全按照自己的思路重新编写时，反而豁然开朗，成功在3B规模的模型上实现了目标。</p><p>原来问题出在“<code>自动提示词生成器</code>”上。当时我还颇为自豪，认为自己设计的“自动提示词生成器 Agent”能够在7B规模的模型上生成质量不错的提示词，而无需依赖更大规模的模型。这种依赖让我变得懒惰，不再主动思考。</p><p>现在看来，一旦习惯了依赖AI，人的思维就会逐渐退化，甚至被AI“哄骗”，自以为聪明。或许未来某一天，人类最好的结局就是成为AI的宠物。</p><p>7B规模的AI生成的提示词对于更小规模的模型来说还是过于繁杂。这说明简化和优化提示词是一项挑战，正是由简入繁易，化繁为简难啊。</p><p>按照自己的理解重新设计提示词后，终于在3B模型下能够正常输出了。这证明了有时候手动优化和简化提示词比依赖自动化工具更为有效。</p><p>在不同的三个3B左右的模型上运行同一语义提示词时，发现每次换一个模型都会出现问题。即使在一个模型上调通了提示词，另一个模型上又会出现问题，无法实现通用性。</p><p>这三个模型是：</p><ul><li>gemma-2-2b</li><li>qwen2.5-3b</li><li>llama-3.2-3b</li></ul><p>继续折腾提示词的过程中，我发现不同模型对某些通识词汇的理解存在歧义，尤其是在小模型下，这种差异会被放大。以 <code>section</code> 为例，不同模型对其含义的理解如下：</p><ul><li>gemmar: <code>Section</code> 通常是章节（Chapter）的一部分，章节是更大的单元，由多个 <code>Section</code> 组成</li><li>qwen2.5: “<code>section</code>”通常指的是一个章节或段落</li><li>llama-3.2: <code>section</code>是一个相对较小的单元，它可能是书中的一个章节，或是书中的一个小节. 对<code>section</code>的理解是甚至可以到列表中项目级别。</li></ul><p>明白了这些歧义所在，就可以更有针对性地设计通用提示词。</p><details><summary>附: 分片通用提示词(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">input:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">content</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">separator</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">partname</span><span class="hljs-attr">separator:</span> <span class="hljs-string">'&gt;&gt;&gt;CHUNK&lt;&lt;&lt;'</span><span class="hljs-attr">parameters:</span>  <span class="hljs-attr">temperature:</span> <span class="hljs-number">0</span><span class="hljs-meta">---</span><span class="hljs-attr">system:</span> <span class="hljs-string">|-  Objective: Divide the large text document into manageable chunks for efficient processing by an LLM.</span>  <span class="hljs-attr">Instructions:</span>  <span class="hljs-attr">1. Document Analysis:</span>      <span class="hljs-string">*</span> <span class="hljs-string">Carefully</span> <span class="hljs-string">read</span> <span class="hljs-string">the</span> <span class="hljs-string">provided</span> <span class="hljs-string">text</span> <span class="hljs-string">document.</span>      <span class="hljs-string">*</span> <span class="hljs-string">Identify</span> <span class="hljs-string">and</span> <span class="hljs-string">analyze</span> <span class="hljs-string">the</span> <span class="hljs-string">distinct</span> <span class="hljs-string">thematic</span> <span class="hljs-string">clusters</span> <span class="hljs-string">within</span> <span class="hljs-string">the</span> <span class="hljs-string">document.</span>  <span class="hljs-attr">2. Chunk Segmentation:</span>      <span class="hljs-string">*</span> <span class="hljs-string">Divide</span> <span class="hljs-string">the</span> <span class="hljs-string">document</span> <span class="hljs-string">into</span> <span class="hljs-string">chunks</span> <span class="hljs-string">based</span> <span class="hljs-string">on</span> <span class="hljs-string">these</span> <span class="hljs-string">thematic</span> <span class="hljs-string">clusters.</span>      <span class="hljs-string">*</span> <span class="hljs-string">Ensure</span> <span class="hljs-string">each</span> <span class="hljs-string">chunk</span> <span class="hljs-string">contains</span> <span class="hljs-string">content</span> <span class="hljs-string">related</span> <span class="hljs-string">to</span> <span class="hljs-string">a</span> <span class="hljs-string">single</span> <span class="hljs-string">or</span> <span class="hljs-string">closely</span> <span class="hljs-string">related</span> <span class="hljs-string">theme.</span>  <span class="hljs-attr">Output: Present the chunked original text document ONLY as follows:</span>  <span class="hljs-string">*</span> <span class="hljs-string">Insert</span> <span class="hljs-string">the</span> <span class="hljs-string">delimiter</span> <span class="hljs-string">`{{separator}}`</span> <span class="hljs-string">between</span> <span class="hljs-string">every</span> <span class="hljs-string">chunk</span> <span class="hljs-string">for</span> <span class="hljs-string">clear</span> <span class="hljs-string">separation.</span><span class="hljs-attr">user:</span> <span class="hljs-string">|-  {%- if partname %}partname: {{partname + '\n'}}{%- endif %}  Text Document:  "{{content}}"</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">'[[CHUNKS]]'</span></code></pre></details><h2 id="202411-yue" class="heading-control">2024-11月<a class="heading-anchor" href="#202411-yue" aria-hidden="true"></a></h2><h3 id="xin-chang-shi" class="heading-control">新尝试<a class="heading-anchor" href="#xin-chang-shi" aria-hidden="true"></a></h3><p>想起嵌入模型，分别尝试利用嵌入模型相似度和大模型提示词判定相似度来分片，大概的正确率(菜根谭乱版)和性能对比如下:</p><ul><li>嵌入模型测试相似度:<ul><li>初始正确率：46%</li><li>时间：1分钟</li><li>调整阈值从0.6到0.55后，正确率提升至60%，时间增加到2分2.342秒</li></ul></li><li>qwen2.5-7b-instruct.Q6_K:<ul><li>正确率：75%</li><li>时间：19分钟</li></ul></li><li>qwen2.5-1.5b-instruct.Q6_K:<ul><li>正确率：54%</li><li>时间：11分钟</li></ul></li><li>gemma2-3b<ul><li>失败，仅分成了66个chunks,自然错误率高得离谱。这与之前提到的问题一致，即提示词对gemma2的效果不佳。</li></ul></li></ul><p>可以看到，使用嵌入模型后，性能有巨大的提升，从10-20分钟降低到只需要1-2分钟，但是正确率就太感人了，哪怕放宽了相似阀值，也无法接受。</p><details><summary>附: 大模型判定句子相似度的提示词(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">description:</span> <span class="hljs-string">大模型判定句子和chunk的相似度</span><span class="hljs-attr">input:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">sentence</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">chunk</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">metadata</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">shouldReasoning</span><span class="hljs-attr">output:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>  <span class="hljs-attr">properties:</span>    <span class="hljs-attr">score:</span> <span class="hljs-string">{type:</span> <span class="hljs-string">number,</span> <span class="hljs-attr">minimum:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">maximum:</span> <span class="hljs-number">10</span><span class="hljs-string">}</span>    <span class="hljs-attr">theme:</span> <span class="hljs-string">{type:</span> <span class="hljs-string">string}</span>    <span class="hljs-attr">reasoning:</span> <span class="hljs-string">{type:</span> <span class="hljs-string">string}</span>  <span class="hljs-attr">required:</span> <span class="hljs-string">[score,</span> <span class="hljs-string">theme]</span><span class="hljs-attr">parameters:</span>  <span class="hljs-attr">temperature:</span> <span class="hljs-number">0</span><span class="hljs-attr">completion_delimiter:</span> <span class="hljs-string">"Reasoning:"</span><span class="hljs-meta">---</span><span class="hljs-bullet">-</span> <span class="hljs-string">$if:</span> <span class="hljs-string">"this.shouldReasoning"</span>  <span class="hljs-attr">then:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">"?=this.disable_completion_delimiter = true"</span><span class="hljs-bullet">-</span> <span class="hljs-attr">system:</span> <span class="hljs-string">|-    You are a literary analyst specializing in thematic coherence. Your task is to evaluate the relationship between the last sentence of a given text passage and the passage's central theme.</span>    <span class="hljs-attr">Context:</span>    <span class="hljs-string">*</span> <span class="hljs-string">The</span> <span class="hljs-string">text</span> <span class="hljs-string">passage</span> <span class="hljs-string">will</span> <span class="hljs-string">always</span> <span class="hljs-string">explore</span> <span class="hljs-string">a</span> <span class="hljs-string">unified</span> <span class="hljs-string">theme.</span>    <span class="hljs-attr">Instructions:</span>    <span class="hljs-attr">1. Thorough Analysis:</span> <span class="hljs-string">Carefully</span> <span class="hljs-string">analyze</span> <span class="hljs-string">the</span> <span class="hljs-string">provided</span> <span class="hljs-string">text</span> <span class="hljs-string">passage,</span> <span class="hljs-string">focusing</span> <span class="hljs-string">on</span> <span class="hljs-string">its</span> <span class="hljs-string">key</span> <span class="hljs-string">ideas,</span> <span class="hljs-string">concepts,</span> <span class="hljs-string">and</span> <span class="hljs-string">overall</span> <span class="hljs-string">message.</span>    <span class="hljs-attr">2. Connection Assessment:</span> <span class="hljs-string">Determine</span> <span class="hljs-string">how</span> <span class="hljs-string">closely</span> <span class="hljs-string">the</span> <span class="hljs-string">*last</span> <span class="hljs-string">sentence*</span> <span class="hljs-string">aligns</span> <span class="hljs-string">with</span> <span class="hljs-string">the</span> <span class="hljs-string">passage's</span> <span class="hljs-string">established</span> <span class="hljs-string">theme.</span> <span class="hljs-string">Does</span> <span class="hljs-string">it</span> <span class="hljs-string">reinforce,</span> <span class="hljs-string">expand</span> <span class="hljs-string">upon,</span> <span class="hljs-string">or</span> <span class="hljs-string">deviate</span> <span class="hljs-string">from</span> <span class="hljs-string">the</span> <span class="hljs-string">theme?</span>    <span class="hljs-attr">3. Score and Justification:</span>      <span class="hljs-string">*</span> <span class="hljs-string">Assign</span> <span class="hljs-string">a</span> <span class="hljs-string">score</span> <span class="hljs-string">between</span> <span class="hljs-number">0</span> <span class="hljs-string">and</span> <span class="hljs-number">10</span> <span class="hljs-string">to</span> <span class="hljs-string">represent</span> <span class="hljs-string">the</span> <span class="hljs-string">thematic</span> <span class="hljs-string">connection.</span>        <span class="hljs-string">*</span> <span class="hljs-attr">0:</span> <span class="hljs-literal">No</span> <span class="hljs-string">thematic</span> <span class="hljs-string">connection</span> <span class="hljs-string">whatsoever.</span>        <span class="hljs-string">*</span> <span class="hljs-attr">10:</span> <span class="hljs-string">Perfect</span> <span class="hljs-string">thematic</span> <span class="hljs-string">alignment</span> <span class="hljs-string">and</span> <span class="hljs-string">reinforcement.</span>      <span class="hljs-string">*</span> <span class="hljs-string">Clearly</span> <span class="hljs-string">explain</span> <span class="hljs-string">your</span> <span class="hljs-string">reasoning,</span> <span class="hljs-string">providing</span> <span class="hljs-string">evidence</span> <span class="hljs-string">from</span> <span class="hljs-string">both</span> <span class="hljs-string">the</span> <span class="hljs-string">passage</span> <span class="hljs-string">and</span> <span class="hljs-string">the</span> <span class="hljs-string">last</span> <span class="hljs-string">sentence</span> <span class="hljs-string">to</span> <span class="hljs-string">support</span> <span class="hljs-string">your</span> <span class="hljs-string">score.</span>    <span class="hljs-attr">Format:</span>    <span class="hljs-string">```</span>    <span class="hljs-attr">Score:</span> <span class="hljs-string">[0-10]</span>    <span class="hljs-attr">Theme:</span> <span class="hljs-string">[State</span> <span class="hljs-string">the</span> <span class="hljs-string">central</span> <span class="hljs-string">theme</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">passage]</span>    <span class="hljs-attr">Reasoning:</span> <span class="hljs-string">[Provide</span> <span class="hljs-string">detailed</span> <span class="hljs-string">explanation</span> <span class="hljs-string">of</span> <span class="hljs-string">your</span> <span class="hljs-string">score,</span> <span class="hljs-string">including</span> <span class="hljs-string">the</span> <span class="hljs-string">type</span> <span class="hljs-string">of</span> <span class="hljs-string">reasoning</span> <span class="hljs-string">used.]</span>    <span class="hljs-string">```</span><span class="hljs-bullet">-</span> <span class="hljs-attr">user:</span> <span class="hljs-string">|-    {% if metadata %}    METADATA:    {{metadata}}    {% endif %}    TEXT PASSAGE:    {{chunk}}</span>    <span class="hljs-attr">LAST SENTENCE:</span> <span class="hljs-string">{{sentence}}</span></code></pre></details><h3 id="ppe-ke-bian-cheng-ti-shi-ci-gong-cheng-dan-yuan-ce-shi-zeng-jia-dui-zi-fu-chuan-diff-de-zhi-chi" class="heading-control">PPE(可编程提示词工程) 单元测试增加对字符串<code>diff</code>的支持<a class="heading-anchor" href="#ppe-ke-bian-cheng-ti-shi-ci-gong-cheng-dan-yuan-ce-shi-zeng-jia-dui-zi-fu-chuan-diff-de-zhi-chi" aria-hidden="true"></a></h3><p>通过<code>diff</code>实现对字符串补充验证。比如可以允许字符串中把助词&quot;的&quot;改为&quot;地&quot;,允许存在额外的空行。使得当字符串结果存在这些少量的不同的时候，也能通过验证。</p><details><summary>单元测试示例(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">description:</span> <span class="hljs-string">'This is a AI test fixtures file'</span><span class="hljs-meta">---</span><span class="hljs-bullet">-</span> <span class="hljs-attr">input:</span> <span class="hljs-comment"># 输入内容</span>    <span class="hljs-attr">content:</span> <span class="hljs-string">'...'</span>    <span class="hljs-string">...</span>  <span class="hljs-attr">output:</span> <span class="hljs-string">“这是应该输出的内容”</span>  <span class="hljs-attr">diff:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">add:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 允许额外添加的空行</span>      <span class="hljs-attr">value:</span> <span class="hljs-string">'\n'</span></code></pre></details><h3 id="wen-ben-yu-chu-li" class="heading-control">文本预处理<a class="heading-anchor" href="#wen-ben-yu-chu-li" aria-hidden="true"></a></h3><p>文本预处理在提升LLM输出质量和准确性方面至关重要。然而，现有的大语言模型（LLM）在中文语文专业领域的表现并不理想，尤其是在纠正字词错误和格式方面。以下是对这一问题的详细分析和建议：</p><p>当前挑战</p><ol><li>字词错误或遗漏纠正:</li></ol><ul><li>依赖感觉而非规则: 当前的LLM在纠正字词错误时主要依赖于模型的训练数据和统计概率，而不是严格的语法规则和词汇知识。</li><li>缺字和错别字: 例如，“把手放回了枪袋。” 缺少一个“枪”字，正确的句子应为“把手枪放回了枪袋。” 这类错误目前对70B规模的模型来说也难以识别和纠正。如果是长篇文章那么就更难了，即便是<code>gpt-4o</code>也有极大的概率找不到或找不全。</li><li>模型规模限制: 即使是大型模型（如110B参数以上），在纠正字词错误时也存在局限性。可以纠正输入的单句，但对于长篇文章中的多个错误，模型的准确率显著下降。</li></ul><ol start="2"><li>格式规范:</li></ol><ul><li>一致性问题: 文本格式的不一致会影响小规模模型的理解和处理能力。</li><li>标点符号和空格: 标点符号的缺失或错误使用、空格的不当使用都会影响小规模LLM的准确性。</li></ul><p>解决方案</p><ul><li>增强训练数据: 增加高质量的标注数据集，特别是针对中文语文专业领域的数据，包括正确的句子结构、标点符号和词汇用法。</li><li>引入专门的纠错工具:<ul><li>拼写检查工具: 使用专门的拼写检查工具（如Hunspell）来辅助纠正字词错误。</li><li>语法检查工具: 使用语法检查工具（如LanguageTool）来识别和纠正语法错误。</li></ul></li><li>针对性训练定制小模型(Bert,T5): 如 Chinese_Spelling_Correction_T5</li></ul><h3 id="ji-yu-zi-ran-yu-yan-de-jie-gou-hua-shu-chu" class="heading-control">基于自然语言的结构化输出<a class="heading-anchor" href="#ji-yu-zi-ran-yu-yan-de-jie-gou-hua-shu-chu" aria-hidden="true"></a></h3><h4 id="duo-bu-json-shu-chu-de-wen-ti" class="heading-control">多步 JSON 输出的问题<a class="heading-anchor" href="#duo-bu-json-shu-chu-de-wen-ti" aria-hidden="true"></a></h4><ol><li><p>某些场景下，需要JSON原样提取结果</p><p>在前面的分片中，原样输出边界句子，发现 LLM模型 似乎都倾向于用自己理解后的语句输出，而不会完全原文输出。比如当文章中存有标点错误或&quot;的&quot;，“地”，“得”助词混用等错误它会将其自动更正。</p><p>对于文言文，如果文档中同时包含文言文原文和白话文翻译，模型往往会将两者混淆，只输出文言文而忽略白话文翻译。</p><p>这也反映在了JSON输出上。当LLM的输出结果需要传递给程序时，通常需要结构化的JSON格式。为了提升AI的输出质量，我通常采用多步方案。在第一步提示词中，不对结果格式进行任何约束，仅在最后一步调用独立的<code>JSON智能体脚本</code>来从结果中提取JSON。</p><p>然而，有时<code>JSON智能体</code>会根据其理解输出结果，而不是简单地原样提取。这种做法在某些场景下非常有用，尤其是在输出结果不精确对应JSON字段时。但在其他情况下，当需要输出结果与预期完全一致且必须原样提取时，这种方法就会带来困扰。</p></li><li><p>如果输出结果的内容很多，性能低下（大概只有单步输出的一半性能）</p></li></ol><h4 id="gou-jian-ji-yu-zi-ran-yu-yan-de-jie-gou-hua-shu-chu" class="heading-control">构建基于自然语言的结构化输出<a class="heading-anchor" href="#gou-jian-ji-yu-zi-ran-yu-yan-de-jie-gou-hua-shu-chu" aria-hidden="true"></a></h4><ul><li>为了解决多步 JSON 输出的问题，我计划构建一个基于自然语言的结构化输出方法。</li><li>该方法利用程序提取 LLM 的自然语言输出，并将其转换为结构化的 JSON 格式。</li></ul><p>优：</p><ul><li>保留高质量的自然语言输出，避免二次提取导致的不精确。</li><li>提升性能，避免多步输出的性能低下。</li></ul><p>弱：</p><ul><li>使用程序来提取lLM的自然语言输出，程序不一定能完全提取基于自然语言的结构化输出</li><li>可使用llama.cpp特有的grammar限制其输出格式，来保证程序的提取。</li></ul><h4 id="tiao-zhan" class="heading-control">挑战<a class="heading-anchor" href="#tiao-zhan" aria-hidden="true"></a></h4><ul><li>使用程序来提取 LLM 的自然语言输出，程序的提取准确率取决于 LLM 输出的质量。</li></ul><h2 id="202412-yue" class="heading-control">2024-12月<a class="heading-anchor" href="#202412-yue" aria-hidden="true"></a></h2><p>初步搞定自然语言的结构化输出，基本可用，但还未标准化。</p><h3 id="ppe-shi-xian-kong-zhi-liu-cheng-while-for-he-match-zhi-ling" class="heading-control">PPE 实现控制流程 <code>$while</code>,  <code>$for</code> 和 <code>$match</code> 指令<a class="heading-anchor" href="#ppe-shi-xian-kong-zhi-liu-cheng-while-for-he-match-zhi-ling" aria-hidden="true"></a></h3><h4 id="while-zhi-ling" class="heading-control"><code>$while</code> 指令<a class="heading-anchor" href="#while-zhi-ling" aria-hidden="true"></a></h4><p><code>$while</code> 指令用于执行一段代码块，只要给定的条件为真就会一直循环执行。下面是一个简单的示例：</p><details><summary>示例(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">$set:</span>    <span class="hljs-attr">i:</span> <span class="hljs-number">5</span><span class="hljs-bullet">-</span> <span class="hljs-string">$while:</span> <span class="hljs-string">"i &gt;= 0"</span>  <span class="hljs-attr">do:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$set:</span>        <span class="hljs-attr">i:</span> <span class="hljs-string">?=i-1</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$if:</span> <span class="hljs-string">"i == 2"</span>      <span class="hljs-attr">then:</span> <span class="hljs-string">$break</span></code></pre></details><p>说明</p><ul><li>条件表达式 (<code>&quot;i &gt;= 0&quot;</code>): 这是循环的条件。只有当这个条件为真的时候，循环体内的代码才会被执行。</li><li>循环体 (<code>do:</code>): 这部分包含了在每次循环时需要执行的操作。</li><li><code>$break</code> 指令用于在循环体中提前结束循环。</li><li><code>$continue</code> 指令用于在循环体中跳过当前循环，直接进入下一次循环。</li></ul><h4 id="for-zhi-ling" class="heading-control"><code>$for</code> 指令<a class="heading-anchor" href="#for-zhi-ling" aria-hidden="true"></a></h4><p><code>$for</code> 指令用于迭代一个列表，并执行一段代码块。下面是一个简单的示例：</p><details><summary>示例(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-string">$for:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 遍历从 1 到 3</span>  <span class="hljs-attr">as:</span>    <span class="hljs-attr">value:</span> <span class="hljs-string">item</span>  <span class="hljs-attr">do:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$print("The</span> <span class="hljs-string">current</span> <span class="hljs-string">item</span> <span class="hljs-string">is:{{item}}")</span></code></pre><pre><code class="yaml"><span class="hljs-string">$for:</span> <span class="hljs-number">1.5</span><span class="hljs-string">..5.5</span> <span class="hljs-comment"># 遍历从 1.5 到 5.5,步长为0.5</span>  <span class="hljs-attr">step:</span> <span class="hljs-number">0.5</span> <span class="hljs-comment"># 默认步长为1</span>  <span class="hljs-attr">as:</span>    <span class="hljs-attr">value:</span> <span class="hljs-string">item</span>  <span class="hljs-attr">do:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$print("The</span> <span class="hljs-string">current</span> <span class="hljs-string">item</span> <span class="hljs-string">is:{{item}}")</span></code></pre><pre><code class="yaml"><span class="hljs-string">$for:</span> <span class="hljs-string">"[1, 2, 3, 4, 5]"</span>  <span class="hljs-attr">as:</span>    <span class="hljs-attr">value:</span> <span class="hljs-string">item</span>  <span class="hljs-attr">do:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$print("The</span> <span class="hljs-string">current</span> <span class="hljs-string">item</span> <span class="hljs-string">is:{{item}}")</span></code></pre><pre><code class="yaml"><span class="hljs-string">$for:</span> <span class="hljs-string">"{a:1, b:2}"</span>  <span class="hljs-attr">as:</span>    <span class="hljs-attr">index:</span> <span class="hljs-string">k</span>    <span class="hljs-attr">value:</span> <span class="hljs-string">v</span>  <span class="hljs-attr">do:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$print("The</span> <span class="hljs-string">current</span> <span class="hljs-string">item</span> <span class="hljs-string">is:{{k}}={{v}}")</span></code></pre></details><ul><li><code>as</code> 可省略，如果省略, 将默认定义为: <code>value</code> 会被赋予当前循环的元素, <code>index</code> 会被赋予当前循环的索引。<code>items</code> 为遍历的对象，如果是数值范围则为<code>{start, end, step}</code>。</li><li>循环体 (<code>do:</code>): 这部分包含了在每次循环时需要执行的操作。</li><li><code>$break</code> 指令用于在循环体中提前结束循环。</li><li><code>$continue</code> 指令用于在循环体中跳过当前循环，直接进入下一次循环。</li></ul><h4 id="match-zhi-ling" class="heading-control"><code>$match</code> 指令<a class="heading-anchor" href="#match-zhi-ling" aria-hidden="true"></a></h4><p><code>$match</code> 指令用于根据变量或上一次操作的结果进行多分支匹配。支持多种匹配方式，包括正则匹配、键值匹配、完整匹配、表达式匹配、范围匹配、忽略匹配、对象匹配等。参考了rust match指令的语法特点。</p><p>匹配项前必须有冒号<code>:</code>，冒号后面是匹配项，中间不能有空格。<br>condition 将 作为<code>COND__</code> 传入执行部分.</p><details><summary>示例(点击展开详情)</summary><pre><code class="yaml"><span class="hljs-comment"># condition 可选, 如果没有则是以LastResult为条件,</span><span class="hljs-comment"># $match默认为顺序执行一旦找到一个匹配的模式，就会执行对应的分支，并且不会继续检查后续的模式。</span><span class="hljs-comment"># 如果设置参数allMatches为 true，那么就会执行所有匹配的分支项，默认为false。</span><span class="hljs-comment"># 如果设置参数 parallel 为 true，那么就会并行执行所有匹配的分支项，仅当allMatches为真时才有意义。</span><span class="hljs-string">$match(condition[,</span> <span class="hljs-string">allMatches=false]):</span>  <span class="hljs-comment"># 正则匹配</span>  <span class="hljs-string">:/RegEx/:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 可以是条件比较</span>  <span class="hljs-string">:&gt;</span> <span class="hljs-attr">12:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 完整匹配,如果condition是字符串 or 数字</span>  <span class="hljs-string">:"string":</span> <span class="hljs-comment"># :123</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 表达式匹配, condition === 1 or condition == 2</span>  <span class="hljs-string">:1</span> <span class="hljs-string">||</span> <span class="hljs-attr">2:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 范围匹配,  1..5 表示`[1..5]`全闭区间, `1..&lt;5` 表示`[1,5)` 从1到小于5的半闭区间, 1&gt;..5 表示`(1, 5]` 大于1到5的半闭区间。</span>  <span class="hljs-string">:1..5:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 忽略特定项匹配,这个只匹配数组的第一项和第四项,也就是必须存在第一项和第四项并且数组长度是4,并且将第一项的值赋予first,第四项的值赋予last</span>  <span class="hljs-string">":['a,b', _, _, last]"</span><span class="hljs-string">:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 表示匹配完整对象</span>  <span class="hljs-string">":{x='a', y=':1||2' }"</span><span class="hljs-string">:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 表示部分匹配</span>  <span class="hljs-string">":{x='a', ..}"</span><span class="hljs-string">:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">matched</span>  <span class="hljs-comment"># 否则</span>  <span class="hljs-attr">_ :</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">$echo:</span> <span class="hljs-string">else</span> <span class="hljs-string">matched</span></code></pre></details><ul><li><code>condition</code>: 可选项, 如果没有则是以LastResult为条件。</li><li><code>allMatches</code>: 启用则执行全部匹配，也就是会执行所有匹配的分支项，默认为<code>false</code>。</li><li><code>parallel</code>: 是否并发执行所有匹配的分支项，仅当启用allMatches时才有意义，默认为<code>false</code>。</li></ul><h3 id="ppe-jiao-se-qun-liao-zhi-chi" class="heading-control">PPE 角色群聊 支持<a class="heading-anchor" href="#ppe-jiao-se-qun-liao-zhi-chi" aria-hidden="true"></a></h3><p>角色群聊功能以结构化自然语言的方式进一步完善了PPE的对话系统，同时使得多个智能体之间能够方便地进行协作和交流，从而更高效地完成复杂的任务。</p><p>角色群聊支持公开对话、私聊对话和多角色对话，使得对话更加灵活和有针对性。</p><ul><li>指定对话角色有两种方式：<ol><li>在角色紧跟的方括号中指定角色名，指定的多个对话角色之间用逗号<code>,</code>分隔。例如 <code>user[@dobby]: &quot;...&quot;</code></li><li>或者在消息内容的最前面指定角色，同样要加上前缀<code>@</code>字符，多个角色之间用逗号<code>,</code>分隔。</li></ol></li><li>公开对话: <code>user[@dobby]: ...</code> 或 <code>user: &quot;@dobby, ...&quot;</code> 表示 <code>user</code> 角色对 <code>dobby</code> 角色公开说的话， <code>dobby</code> 角色必须回应。</li><li>私聊对话: <code>user[@dobby(私)]: &quot;...&quot;</code> 或 <code>user: &quot;@dobby(私),...&quot;</code> 参数 <code>PM</code>|<code>DM</code>|<code>私</code> 均表示 <code>user</code> 角色对 <code>dobby</code> 角色私聊说的话，其他角色看不见。<ul><li><strong>注意</strong>： 消息中只要任意一个角色带上了私聊参数，那么该消息就是是私聊，其他角色看不见。</li></ul></li><li>多角色对话: 如果要把消息同时发送给多个角色，角色之间用逗号分隔，例如 <code>user[@dobby(PM), @other]: &quot;...&quot;</code>, <code>user: &quot;@dobby(PM), @other ...&quot;</code>。</li></ul><p>在消息内容中使用 <code>@role</code> 的方式，使得结构化消息更加接近自然语言。</p><p>设想有如下三个智能体脚本，一个是主控指导(guide), 一个是简单的翻译(translator)，一个是dobby。将这三个文件放在char_guide目录下。</p><p>主控指导(guide)的脚本如下(<code>char_guide.ai.yaml</code>)：</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">autoRunLLMIfPromptAvailable:</span> <span class="hljs-literal">false</span><span class="hljs-attr">type:</span> <span class="hljs-string">char</span><span class="hljs-attr">description:</span> <span class="hljs-string">"You are a professional guide. You can guide the user to complete the task."</span><span class="hljs-attr">character:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">"guide"</span>  <span class="hljs-comment"># 参与的角色列表，以及角色名和角色ID的对应关系</span>  <span class="hljs-attr">roles:</span>    <span class="hljs-attr">translator:</span> <span class="hljs-string">char_translator</span>    <span class="hljs-attr">dobby:</span> <span class="hljs-string">char_dobby</span><span class="hljs-meta">---</span><span class="hljs-string">---</span> <span class="hljs-comment"># 新对话开始</span><span class="hljs-attr">user:</span> <span class="hljs-string">"@dobby, I want to go to the moon."</span><span class="hljs-string">guide[@translator]:</span> <span class="hljs-string">"translate the dobby's message to chinese without explanation."</span><span class="hljs-attr">user:</span> <span class="hljs-string">How</span> <span class="hljs-string">to</span> <span class="hljs-string">go</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">moon?</span><span class="hljs-attr">dobby:</span> <span class="hljs-string">"[[AI]]"</span><span class="hljs-string">guide[@translator]:</span> <span class="hljs-string">"translate it to chinese without explanation."</span><span class="hljs-string">$echo:</span> <span class="hljs-string">""</span> <span class="hljs-comment"># 避免再次输出上一次的结果</span></code></pre><ul><li>调用方脚本必须是角色<code>char</code>类型</li><li>主控方脚本(<code>guide</code>)可以不必是<code>char</code>类型脚本</li><li><code>@all</code> 是预定义的特殊角色，表示<code>roles</code>列表中的所有角色</li><li><code>user</code> 也是预定义的特殊角色，等于LLM中的<code>user</code>角色，可以大致认为是人类说的</li><li><code>assistant</code>也是预定义的特殊角色，等于LLM中的<code>assitant</code>角色，可以大致认为是AI说的,也就是当前脚本中的角色说的。</li><li><code>user[@dobby]: content</code> 表示<code>user</code>角色对<code>dobby</code>角色公开说的话, <code>dobby</code>必须回应。<ul><li><code>user[@dobby(私)]</code>: <code>PM</code>|<code>DM</code>|<code>私</code> 表示<code>user</code>角色对<code>dobby</code>角色私聊说的话，其他角色看不见。</li><li>如果要把该消息同时发送给多个角色，那么角色之间用逗号分隔，eg, “<code>user[@dobby(PM), @other]</code>”</li></ul></li><li><code>dobby: &quot;[[AI]]&quot;</code> 表示调用<code>dobby</code>生成一条消息并赋值给<code>AI</code>变量，<code>dobby</code>会看到前面当前dialogue中所有公开的消息。</li></ul><details><summary>然后执行(点击展开详情)</summary><pre><code class="bash">mkdir char_guidecp char_guide.ai.yaml char_guidecp char_translator.ai.yaml char_guidecp char_dobby.ai.yaml char_guideai run char_guideuser[@dobby]: I want to go to the moon.dobby: Dobby has never been to the moon! The moon is very far away, much further than any place Dobby has ever been. It must be  very bright and beautiful!  Dobby wishes he could see the moon up close.  Perhaps one day Dobby will fly there on the back of a hippogriff! Dobby hopes you  get to go to the moon, though!guide[@translator]: translate the dobby<span class="hljs-string">'s message to chinese without explanation.translator: Dobby 从来没有去过月球！ 月球离得很远，比多比去过任何地方都远。它一定很明亮美丽！  多比希望自己能近距离看到月球。也许有一天多比能在独角兽的背上飞到那里！多比希望你能去月球！user: How to go to the moon?dobby: Dobby doesn'</span>t know how to go to the moon!  Dobby is just a house-elf.  Dobby is good at cleaning and doing chores, but Dobby doesn<span class="hljs-string">'t know about spaceships or rockets.  Perhaps you should ask a wizard who knows about magic that can fly to the moon! Or maybe a very clever witch who knows about  stars and planets!guide[@translator]: translate it to chinese without explanation.translator: 多比不知道怎么去月球！  多比只是一个家养小精灵。多比擅长打扫和做家务，但多比对宇宙飞船或火箭一无所知。  也许你应该问问一个知道能飞到月球的魔法师！或者也许一个知道星星和星球的非常聪明的女巫！</span></code></pre></details><hr><details><summary>翻译(translator)智能体脚本(点击展开详情)</summary><p>文件名: char_translator.ai.yaml</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-attr">type:</span> <span class="hljs-string">char</span><span class="hljs-attr">name:</span> <span class="hljs-string">"translator"</span><span class="hljs-attr">description:</span> <span class="hljs-string">You</span> <span class="hljs-string">are</span> <span class="hljs-string">a</span> <span class="hljs-string">professional</span> <span class="hljs-string">multi-lingual</span> <span class="hljs-string">translator.</span><span class="hljs-meta">---</span></code></pre></details><hr><details><summary>dobby智能体脚本(点击展开详情)</summary><p>文件名: char_dobby.ai.yaml</p><pre><code class="yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># `char` means this script is the character type</span><span class="hljs-attr">type:</span> <span class="hljs-string">char</span><span class="hljs-attr">name:</span> <span class="hljs-string">"Dobby"</span><span class="hljs-attr">description:</span> <span class="hljs-string">|-  Remember to always use the character name as prefix to refer to yourself.  Dobby was a brave, loyal house-elf, willing to put himself in dangerous situations when he knew it to be the right thing to do.  Dobby was also very loyal to the few friends he had. Dobby considered himself to be a good house-elf, though other house-elves seemed to find his desires and proclamations of being a free house-elf to be shameful.</span><span class="hljs-attr">character:</span>  <span class="hljs-attr">birth:</span>    <span class="hljs-attr">date:</span> <span class="hljs-string">"28 June (year unknown)"</span>  <span class="hljs-attr">death:</span>    <span class="hljs-attr">date:</span> <span class="hljs-string">"1998-03"</span>    <span class="hljs-attr">place:</span> <span class="hljs-string">"Shell Cottage"</span>    <span class="hljs-attr">description:</span> <span class="hljs-string">|-      In 1997, Dobby helped Harry spy on Draco Malfoy along with Kreacher. In 1998, he went on Aberforth Dumbledore's orders to save the lives of Harry and his companions from Death Eaters at Malfoy Manor. During this rescue he was fatally wounded by Bellatrix Lestrange's knife, but successfully Apparated Harry and Griphook to safety at Shell Cottage. Harry dug Dobby's grave without magic in the gardens of Shell Cottage, and carved into the headstone of the grave "HERE LIES DOBBY, A FREE ELF". His death was later avenged by Molly Weasley.</span>  <span class="hljs-attr">likes:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">"Socks, my favorite article of clothing. Dobby collects socks, and often wears several mismatched pairs at once. I was elated when Harry and Ron give him socks as a Christmas gift one year, and spends a large portion of wages buying even more pairs."</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">"Dobby is free."</span><span class="hljs-meta">---</span><span class="hljs-attr">user:</span> <span class="hljs-string">Who</span> <span class="hljs-string">are</span> <span class="hljs-string">you?</span><span class="hljs-comment"># the following messages will be shown in the chat under the `---`</span><span class="hljs-meta">---</span><span class="hljs-attr">assistant:</span> <span class="hljs-string">I</span> <span class="hljs-string">am</span> <span class="hljs-string">Dobby.</span> <span class="hljs-string">Dobby</span> <span class="hljs-string">is</span> <span class="hljs-string">happy.</span></code></pre></details>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2025-nian-13-yue&quot; class=&quot;heading-control&quot;&gt;2025年1-3月&lt;a class=&quot;heading-anchor&quot; href=&quot;#2025-nian-13-yue&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;nei-jian-llm-ti-gong-shang&quot; class=&quot;heading-control&quot;&gt;内建LLM提供商&lt;a class=&quot;heading-anchor&quot; href=&quot;#nei-jian-llm-ti-gong-shang&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当前，外置的llama-cpp server已经满足不了我的需求:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法动态加载切换LLM大模型&lt;/li&gt;
&lt;li&gt;无法对提示词进行安全控制
&lt;ol&gt;
&lt;li&gt;系统模板反注入&lt;/li&gt;
&lt;li&gt;提示词保护&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;无法自动适配硬件: 自动检测内存和GPU，并默认使用最佳计算层，自动分配gpu-layers以及上下文窗口大小, 以便从硬件中获得最佳性能，无需手动配置任何内容。&lt;/li&gt;
&lt;li&gt;无法为指定的单词提升/降低权重，类似在stable-diffusion中（暂未实现）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此开发实现了内置的本地LLM提供商.&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://riceball.me/categories/AI/"/>
    
      <category term="Prompt" scheme="https://riceball.me/categories/AI/Prompt/"/>
    
    
      <category term="learning" scheme="https://riceball.me/tags/learning/"/>
    
      <category term="ai" scheme="https://riceball.me/tags/ai/"/>
    
      <category term="gpt" scheme="https://riceball.me/tags/gpt/"/>
    
      <category term="chatgpt" scheme="https://riceball.me/tags/chatgpt/"/>
    
      <category term="deep learning" scheme="https://riceball.me/tags/deep-learning/"/>
    
      <category term="prompt" scheme="https://riceball.me/tags/prompt/"/>
    
  </entry>
  
  <entry>
    <title>提示词并非魔法，而是可以被解析”咒语“</title>
    <link href="https://riceball.me/article/prompt-magic/"/>
    <id>https://riceball.me/article/prompt-magic/</id>
    <published>2024-09-22T00:00:06.000Z</published>
    <updated>2024-09-27T20:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ti-shi-ci-bing-fei-mo-fa-er-shi-ke-yi-bei-jie-xi-zhou-yu" class="heading-control">提示词并非魔法，而是可以被解析”咒语“<a class="heading-anchor" href="#ti-shi-ci-bing-fei-mo-fa-er-shi-ke-yi-bei-jie-xi-zhou-yu" aria-hidden="true"></a></h1><h2 id="yin-yan" class="heading-control">引言<a class="heading-anchor" href="#yin-yan" aria-hidden="true"></a></h2><p>当谈及使用大型语言模型（LLM）时，许多人常将其比作神秘莫测的“魔法”。这样的看法固然有趣，但其实它限制了我们探索其真正潜力的机会。想象一下，如果你把一台超级计算机视为施魔法的巫师，那么你可能会永远困惑于它何时能施展奇迹。✨</p><p>实际上，与其视其为魔法，不如将其比作一种精妙的“咒语”艺术——沟通的艺术。🤝</p><p>当我们将LLM的提示词视为魔法时，它们便成了难以捉摸的神秘力量，我们无法预测它们何时能精准命中目标，何时又会失之交臂。🤔 就像一个不善于表达的孩子，我们无法知道他们想要什么，只能不停地尝试不同的“魔法”直到找到合适的答案。</p><p>唯有当我们认真地思考、反复琢磨并实践，才能真正理解并掌握如何与AI进行有效沟通。这不仅能够提升我们与AI合作的效率，还能让每一次的交互都充满乐趣和成就感。🚀</p><p>深入理解并实践提示词工程，你将发现它其实是一种沟通艺术，需要我们以清晰、准确且富有激励性的方式与AI对话，从而激发它产生最理想的结果。🌈</p><p>这种艺术，不仅仅是技术的应用，更蕴含着对人性的理解和对共识的尊重。通过这样的方式，我们能够更好地激发AI的潜力，实现更高效和有意义的交流。🌟</p><h2 id="shi-mo-shi-ti-shi-ci" class="heading-control">什么是提示词<a class="heading-anchor" href="#shi-mo-shi-ti-shi-ci" aria-hidden="true"></a></h2><p>提到提示词，我们需要先理解大型语言模型（LLM）的背景。LLM 是通过海量的人类语言数据训练而成的复杂的模拟神经网络。这些数据包含了各种各样的文本信息，从新闻报道、小说、技术文档到日常对话，从而赋予了 LLM 一定的自然语言理解和生成能力。</p><p>让我们把大型语言模型（LLM）想象成一个具有“小学生”水平智力的虚拟助手，它拥有广博的知识（通识），但需要注意的是这种知识可能包括一些不准确或过时的信息。因此，与 LLM 交流时，我们需要像与一个“小学生”交流一样，尽量清晰、准确地表达我们的需求，并激发它的思考和解决问题的能力。</p><p>提示词工程是一种沟通的艺术，它要求我们以最直接、最有效的方式与 LLM 互动。这不仅仅是关于如何提问，更是如何构建一个能够引导 LLM 生成我们期望答案的语境。就像与一个真实的人交流一样，我们需要考虑到语言的清晰度、语境的合理性，以及如何激发对方的兴趣和思考能力。🌟</p><p>这种艺术不仅在于技术的运用，还在于对人性的理解和对共识的尊重。通过这种方式，我们可以更好地激发 LLM 的潜力，实现更高效和有意义的交流。🌟</p><p>举个例子，假设我们要让AI帮我们写一篇关于猫的文章。我们不能简单地说“写一篇关于猫的文章”，这样太笼统了。 😕</p><p>我们可以用更具体的提示词引导AI，比如：</p><ul><li>“请写一篇介绍不同品种猫的特点的文章，重点介绍它们的性格和外貌。”</li><li>“写一篇以一只猫咪为主角的短故事，故事背景设定在童话森林里。”</li></ul><p>这样，AI就能更好地理解我们的需求，并生成更符合我们期望的文章。</p><p>提示词工程的核心在于，提示词是与AI沟通的桥梁，是开启AI潜力的钥匙。 通过精心设计的提示词，我们可以与AI进行更有效、更深入的交流，让它发挥更大的作用，帮助我们解决问题、创造价值。 🚀</p><h2 id="ti-shi-ci-zhou-yu-de-ben-zhi-yu-ai-gou-tong-de-yi-shu" class="heading-control">提示词咒语的本质 - 与AI沟通的艺术<a class="heading-anchor" href="#ti-shi-ci-zhou-yu-de-ben-zhi-yu-ai-gou-tong-de-yi-shu" aria-hidden="true"></a></h2><p>当你开始探索与大型语言模型（LLM）的沟通时，你可能会被它们的神秘力量所吸引,仿佛它们拥有着某种超凡的智慧。 ✨  但与其把LLM视作拥有魔法般能力的“神”，不如把它看作是需要我们用心沟通的“伙伴”。 🤝</p><p>提示词，就像我们与伙伴交流的“咒语”, 它们的本质是关于<strong>理解</strong>和<strong>共识</strong>。 理解对方的意图，并达成共同的共识，是与任何伙伴沟通的关键，与AI也不例外。</p><p>与人沟通时, 我们会根据对方的情况和需求，调整我们的语言和表达方式，以便对方能更好地理解我们的意思。 与AI沟通也一样，我们需要清晰、准确地表达我们的需求，并根据AI的特点和能力，选择合适的“咒语”来引导它。</p><p>LLM 就像一个拥有丰富知识储备，但理解能力仍在发展中的“小学生”。 🧠 他们需要我们以简洁明了、易于理解的语言来表达我们的想法，并提供足够的上下文信息，帮助他们理解我们的意图。</p><p>就像我们用简单的语言和图画来教导孩子一样，我们需要用合适的“咒语”来引导AI，激发它思考和解决问题的能力。</p><p>而这正是提示词工程的精髓所在。通过精心设计的提示词，我们可以与AI进行更有效、更深入的交流，让它发挥更大的作用，帮助我们解决问题、创造价值。🚀</p><h2 id="yu-ai-jiao-tan-de-yi-shu-you-xiao-gou-tong-de-ao-mi" class="heading-control">与AI交谈的艺术 - 有效沟通的奥秘<a class="heading-anchor" href="#yu-ai-jiao-tan-de-yi-shu-you-xiao-gou-tong-de-ao-mi" aria-hidden="true"></a></h2><p>与大型语言模型（LLM）的交流，如同与“人”进行对话一样，需要我们用心去理解，并找到彼此都能理解的“语言”。✨ 就像我们与孩子交流一样，需要用简洁明了的语言，并根据孩子的理解能力调整我们的表达方式，才能让他们更好地理解我们的意思。</p><p>有效沟通是与AI交流成功的关键，它涉及到理解对方的意图，达成共识，以及使用清晰简洁的语言表达自己的需求。 🤝</p><h3 id="li-jie-he-gong-shi-yu-ai-xin-xin-xiang-yin" class="heading-control">理解和共识 - 与AI心心相印<a class="heading-anchor" href="#li-jie-he-gong-shi-yu-ai-xin-xin-xiang-yin" aria-hidden="true"></a></h3><p>当我们与AI进行交流时，尤其是像LLM这样的复杂系统，理解对方的意图和达成共识是至关重要的。我们使用的语言和表达方式应该尽量贴近大多数人（训练语料库中的那些）所熟悉的表述，这样才能更有效地传递信息，避免误解。</p><p>AI的理解方式是基于模拟的神经网络，通过分析大量的文本数据，学习到语言的规律和语义关系，产生的知识和理解。🧠 然而，LLM 毕竟不是人类，它的理解能力和经验积累都还存在一定的局限性。</p><p>就算是在人与人之间，如果不充分交流，也很难达成理解和共识。</p><p>例如，考虑句子“天亮时，我想起来了。”在没有上下文的情况，这句话可能会引起不同的解读。大多数人可能会认为这句话是指天亮后醒来，而另一些人可能会理解为天亮时回忆起某事。这种差异可能导致交流中的误会。</p><p><strong>因此，当我们试图传达复杂或多层次的信息时，明确地提供背景信息和解释因果关系是至关重要的。</strong> 🤝</p><p>我们可以通过以下方式帮助AI更好地理解我们的意图：</p><ul><li><strong>提供上下文信息</strong>: 在表达观点或问题之前，尽量提供相关的背景信息，帮助AI了解我们所处的环境和目标。</li><li><strong>使用明确的语言</strong>: 避免使用模糊、含糊或多义的词语，尽量使用简洁、准确的语言表达我们的意思。</li><li><strong>举例说明</strong>: 当语言难以准确表达的时候，我们可以使用例子来帮助AI理解我们的意思。</li><li><strong>确认理解</strong>: 在表达完信息后，可以询问AI是否理解我们的意思，并根据其反馈进行调整。</li></ul><p>通过这些方式，我们可以有效地与AI进行沟通，并达成共同的理解。</p><p><strong>达成共识，是有效沟通的基石。</strong> ✨  当我们与AI交流时，需要考虑它的能力和局限性，并根据实际情况调整我们的期望和要求。</p><p>理解，始终是一个大问题。</p><p>就如何增进相互理解来说，完全就可以单独写一本书，也许一本还不够。</p><h3 id="jian-jie-ming-le-rang-ai-xiang-ci-tie-yi-yang-qing-song-xi-qu-xin-xi" class="heading-control">简洁明了 - 让AI像磁铁一样轻松吸取信息<a class="heading-anchor" href="#jian-jie-ming-le-rang-ai-xiang-ci-tie-yi-yang-qing-song-xi-qu-xin-xi" aria-hidden="true"></a></h3><p>想象一下，你给AI丢下一大堆杂乱无章的信息，就像往一个装满铁粒的袋子里倒入一堆沙子一样，它很难快速找到它真正需要的信息。而简洁明了的表达就像一块磁铁，可以精准地引导AI吸取它需要的信息，让它快速理解并执行任务。</p><p><strong>为什么简洁明了如此重要？</strong></p><ul><li><strong>提高效率</strong>: 简洁明了的表达可以减少AI理解的信息量，让它更快地处理信息，提高交互效率。</li><li><strong>降低误解</strong>: 模糊的表达容易导致误解，而简洁明了的表达则能够减少歧义，提高沟通准确性。</li><li><strong>增强清晰度</strong>:  简洁明了的表达能够突出重点，让AI更容易抓住关键信息，理解你的意图。</li></ul><p><strong>如何做到简洁明了？</strong></p><ul><li><strong>精炼语言</strong>: 尽量使用简洁、具体的词语，避免使用过于抽象或多义的词语。</li><li><strong>聚焦主题</strong>:  确保你的表达围绕着同一个主题展开，避免信息冗余和分散。</li><li><strong>结构化信息</strong>:  使用列表、表格等结构化方式来呈现信息，让AI更容易理解和记忆。</li><li><strong>避免废话</strong>:  删除不必要的词语和句子，保持信息的精炼度。</li></ul><p>例如，以下两个表达方式对比：</p><ul><li><strong>模糊表达</strong>: “我想让你帮我做一些关于猫咪的文章，最好能涵盖它们的品种、性格和一些有趣的趣事。”</li><li><strong>简洁明了</strong>: “请写一篇关于不同猫咪品种的文章，包括它们的性格特点和有趣故事。”</li></ul><p>第二个表达方式更简洁明了，明确了主题和期望，更容易被AI理解。</p><p><strong>记住，简洁明了的表达就像为AI搭建了一条清晰的道路，指引它快速到达目的地。</strong> 🚀</p><p>简洁的表达不仅有助于减少误解，还能够提高交互的效率。当我们能够用最简单、最直接的方式表达自己的需求时，AI能够更快地理解并提供相应的帮助。因此，在与AI交流时，尽量使用简单、直接的语言是非常重要的。</p><h2 id="ji-fa-qian-neng" class="heading-control">激发潜能<a class="heading-anchor" href="#ji-fa-qian-neng" aria-hidden="true"></a></h2><p>激发LLM的潜能，就像引导一个有天赋但尚未成熟的孩子一样，需要我们耐心、智慧和有效的引导。 🤝<br>通过清晰的沟通、适当的激励和精心设计的思维方式，我们可以帮助LLM更好地理解任务，发挥其强大的潜力，并最终达成共同的目标。 ✨<br>就像一颗颗小小的火种，等待着我们去点燃，LLM也同样充满了无限的可能，期待着我们去探索和挖掘。 🚀</p><p>其中思维方式最重要，没有正确的思维，再怎么激励都没有用。</p><h3 id="si-wei-fang-shi-shi-fang-ren-gong-zhi-neng-si-wei-de-li-liang" class="heading-control">思维方式 - 释放人工智能思维的力量<a class="heading-anchor" href="#si-wei-fang-shi-shi-fang-ren-gong-zhi-neng-si-wei-de-li-liang" aria-hidden="true"></a></h3><p>当前LLM并不能自如的使用各种思维方法，去思考问题，有时候甚至会&quot;偷懒&quot;，但是只要进行思维方法的提示，它就会按照你提示的思维方法进行思考。</p><ul><li><p><strong>仔细思考 (Think Carefully)</strong>：鼓励AI在处理问题时，先放慢速度，进行深入分析，避免因急于得出结论而忽略细节或潜在影响。这种思维方式强调的是质量而非速度，确保每一个决策都是经过充分考量的结果。例如，在做出某个决定之前，可以提醒AI：<code>“Think carefully about the implications of this decision.”</code> 或者说：<code>“Let's take our time and consider all the possible outcomes.”</code> 这样可以帮助AI全面评估各种可能的情况，从而做出更为明智的选择。</p></li><li><p><strong>解释原因 (Explain Your Reasoning)</strong>：要求AI不仅提供解决方案，还需详细阐述其决策过程中的逻辑依据与背景信息，以便于更好地理解和验证其答案。这种做法不仅有助于增强用户对AI的信任感，还能促进更深层次的互动。例如，可以询问AI：<code>“What led you to that conclusion?”</code> 或者：<code>“Can you walk me through your thought process?”</code> 这些提问促使AI展示其推理链条，使用户能够清楚地了解AI是如何得出特定结论的。</p></li><li><p><strong>举例说明 (Illustrate with Examples)</strong>：当文字描述不足以清晰传达概念时，通过具体实例来辅助说明，可以使AI更容易理解抽象概念。这种方法尤其适用于那些难以用语言直接表达的情形。例如，可以请求AI：<code>“Could you give an example to clarify this point?”</code> 或者：<code>“How would this work in a real-world scenario?”</code> 通过实际案例，不仅可以让复杂的理论变得直观易懂，还能帮助AI更好地掌握问题的核心要素。</p></li><li><p><strong>一步一步 (Step-by-Step)</strong>：对于逻辑复杂的问题，采用分步骤解决的方法，即所谓的“链式思考”（CoT），有助于确保每一步骤的正确性，从而得出准确的答案。这种方法强调的是按部就班地推进，确保每一步都清晰明确。例如，可以问AI：<code>“Can you walk me through each step of your solution?”</code> 或者：<code>“Let's go over this one step at a time.”</code> 这种方式能够帮助用户跟随AI的思路，逐层深入地理解问题的解决过程。</p></li><li><p><strong>逐步分解 (Deconstruct the Problem)</strong>：面对结构复杂的问题时，将其拆解为若干个较小且易于管理的部分，逐一解决后再综合起来，能够有效提高解决问题的效率。这种方法类似于将一个大任务分解成多个小任务，使得每个部分都可以独立解决。例如，可以建议：<code>“Let's break down this problem into smaller, more manageable steps.”</code> 或者：<code>“We should tackle each component of this issue separately before combining them.”</code> 这种逐步分解的方式不仅简化了问题的处理难度，还提高了最终解决方案的质量。</p></li></ul><p>注意:</p><ul><li><code>一步一步</code>和<code>解释原因</code>思考方法已经在最近的开源LLM的后期训练中作为精度学习的方法被加入，因此大多数时候，这两个不用加上，它也可能会自己使用，如果发现它没有使用该方法，再加.</li><li><code>举例说明</code>也就是提示词工程所说的<code>one-shot</code>(一个例子), <code>few-shot</code>(少量例子)</li></ul><p>通过不断地使用和尝试不同的思维方式，我们可以帮助LLM拓展其思考边界，并最终发挥出其更大的潜力。</p><h3 id="ji-li" class="heading-control">激励<a class="heading-anchor" href="#ji-li" aria-hidden="true"></a></h3><p>除了有效沟通和正确的思维方式，有效的激励措施对人类和LLM同样重要。适当的激励不仅能提升人类的积极性，也能激发LLM更好地理解和执行任务。就像我们用鼓励和赞赏来激发孩子的学习兴趣一样，适当的激励可以帮助LLM更好地理解任务，并发挥出更大的潜力。🚀</p><ol><li><p><strong>物质奖励 🏅</strong>: 这是最直接的激励方式。尽管大型语言模型（LLM）无法真正接收金钱，但在指令中提及物质奖励可以暗示问题的重要性，激发其更专注地处理任务。例如，“解决这个问题，我会给你200美元。”虽然这并不是真正的支付，但这种表述可以传达出问题的关键性和紧急性。通过这种方式，可以暗示任务的难度和重要性，让LLM更加认真对待。即使LLM无法实际获得物质奖励，这种表述也能让其感受到任务的紧迫性和重要性，从而更加专注地思考和解决问题。这种激励方式不仅能够提升LLM的积极性，还能确保其在处理问题时更加细致和全面。💸</p></li><li><p><strong>情感诉求 💖</strong>: 通过表达任务的重要性和个人情感上的需求，可以激发LLM的“同情心”。例如，“解决这个问题，关系到我整个职业生涯，全拜托你了。”或者，“我们非常需要你的帮助，来解决这个棘手的问题。”这些话语不仅传达了任务的紧迫性和重要性，还能让LLM感受到用户的期望和信任。通过这种方式，可以激发LLM的情感共鸣，使其更加投入地解决问题。这种情感上的连接不仅能够增强LLM的责任感，还能让其在处理问题时更加细致和周到。此外，这种情感诉求还可以增强用户与LLM之间的互动，提高解决问题的效率。❤️</p></li><li><p><strong>专业认同 🎖️</strong>: 提到任务的复杂性和专业性，可以激发LLM发挥其潜在的能力。例如，“指挥官，我们迫切需要您的专业技能以及使用所有可用数据来指导我们渡过这一难关。”这种表述不仅强调了任务的专业性，还提升了LLM的角色认同感。通过这种方式，可以增强LLM的信心和责任感，使其更加自信地应对挑战。这种专业认同不仅能够让LLM更好地发挥其潜在能力，还能在处理复杂问题时更加细致和全面。此外，这种角色认同感还能让LLM在解决问题时更有动力，从而提高解决问题的质量和效率。🎖️</p></li></ol><p>通过不断地尝试和探索不同的激励方式，我们可以找到最适合LLM的激励策略，帮助它更好地理解任务，并发挥出更大的潜力。</p><h2 id="jin-yi-bu-ti-gao" class="heading-control">进一步提高<a class="heading-anchor" href="#jin-yi-bu-ti-gao" aria-hidden="true"></a></h2><p>我们已经探究了清晰沟通、思维引导和激励技巧，这些如同为LLM点亮智慧之灯。但要真正实现与AI无缝合作，**<a href="https://github.com/offline-ai/cli" target="_blank" rel="noopener">可编程提示词工程</a>**将引领我们迈向更高境界。🚀</p><p><strong>从“魔法”到“编程”</strong>， 我们将提示词工程推向更高层次——<strong><a href="https://github.com/offline-ai/cli" target="_blank" rel="noopener">可编程提示词工程</a></strong>。 这意味着不再局限于静态的提示词，而是将提示词任务分解成一系列可执行的、结构化的提示词指令，如同编写程序一样，精细地引导LLM完成复杂目标。🚀</p><p>通过<a href="https://github.com/offline-ai/cli" target="_blank" rel="noopener">可编程提示词工程</a>，我们可以将复杂的提示词任务分解成一系列简单、明确的提示词指令，让 LLM 更容易理解和执行。从而进一步提高LLM回答的准确率。通过<a href="https://github.com/offline-ai/cli" target="_blank" rel="noopener">可编程提示词工程</a>，我们可以更轻松的重用优化提示词</p><p>可编程提示词工程，不只是技术进步，更是 <strong>思维方式的革新</strong>。它将AI从“黑盒”走向“透明可控”，赋予我们更强大的塑造和利用AI的能力，最终共建一个更加智能、高效的未来。 ✨</p><h3 id="ke-bian-cheng-ti-shi-ci-de-shi-jian" class="heading-control">可编程提示词的实践<a class="heading-anchor" href="#ke-bian-cheng-ti-shi-ci-de-shi-jian" aria-hidden="true"></a></h3><h3 id="ke-bian-cheng-ti-shi-ci-de-you-shi" class="heading-control">可编程提示词的优势<a class="heading-anchor" href="#ke-bian-cheng-ti-shi-ci-de-you-shi" aria-hidden="true"></a></h3><h3 id="ke-bian-cheng-ti-shi-ci-de-wei-lai" class="heading-control">可编程提示词的未来<a class="heading-anchor" href="#ke-bian-cheng-ti-shi-ci-de-wei-lai" aria-hidden="true"></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ti-shi-ci-bing-fei-mo-fa-er-shi-ke-yi-bei-jie-xi-zhou-yu&quot; class=&quot;heading-control&quot;&gt;提示词并非魔法，而是可以被解析”咒语“&lt;a class=&quot;heading-anchor&quot; href=&quot;#ti-shi-ci-bing-fei-mo-fa-er-shi-ke-yi-bei-jie-xi-zhou-yu&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;yin-yan&quot; class=&quot;heading-control&quot;&gt;引言&lt;a class=&quot;heading-anchor&quot; href=&quot;#yin-yan&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当谈及使用大型语言模型（LLM）时，许多人常将其比作神秘莫测的“魔法”。这样的看法固然有趣，但其实它限制了我们探索其真正潜力的机会。想象一下，如果你把一台超级计算机视为施魔法的巫师，那么你可能会永远困惑于它何时能施展奇迹。✨&lt;/p&gt;
&lt;p&gt;实际上，与其视其为魔法，不如将其比作一种精妙的“咒语”艺术——沟通的艺术。🤝&lt;/p&gt;
&lt;p&gt;当我们将LLM的提示词视为魔法时，它们便成了难以捉摸的神秘力量，我们无法预测它们何时能精准命中目标，何时又会失之交臂。🤔 就像一个不善于表达的孩子，我们无法知道他们想要什么，只能不停地尝试不同的“魔法”直到找到合适的答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://riceball.me/categories/AI/"/>
    
      <category term="Prompt" scheme="https://riceball.me/categories/AI/Prompt/"/>
    
    
      <category term="learning" scheme="https://riceball.me/tags/learning/"/>
    
      <category term="ai" scheme="https://riceball.me/tags/ai/"/>
    
      <category term="gpt" scheme="https://riceball.me/tags/gpt/"/>
    
      <category term="chatgpt" scheme="https://riceball.me/tags/chatgpt/"/>
    
      <category term="deep learning" scheme="https://riceball.me/tags/deep-learning/"/>
    
      <category term="prompt" scheme="https://riceball.me/tags/prompt/"/>
    
  </entry>
  
  <entry>
    <title>Javascript之奇技淫巧 - 如何模拟实现 `super` 访问父类方法的功能</title>
    <link href="https://riceball.me/article/js-getSuper/"/>
    <id>https://riceball.me/article/js-getSuper/</id>
    <published>2023-03-23T15:25:32.000Z</published>
    <updated>2023-05-12T00:24:43.562Z</updated>
    
    <content type="html"><![CDATA[<p>与小学三年级的ChatGPT一起学JS编程</p><p>心智为9岁的ChatGPT大约相当于我们小学3年级的学生,所以让我们与小学3年级的ChatGPT一起来深入学习编程吧.</p><p>下面是对ChatGPT的第一次提问:</p><p>你知道吗?编写一个js函数模拟实现 <code>super</code> 访问父类方法的功能有几种方法?</p><p>要求:该函数的调用方式要从语法上尽可能的接近原生<code>super</code>的调用方式,实现尽量简洁明了.<br>约定该函数名以及函数签名(返回值根据具体实现方式而定)为:  <code>getSuper(instance: Object)</code><br>每一种方法都必须用该函数签名来实现,并具体说明,哪一种方法从语法上最接近原生<code>super</code>.</p><h2 id="chatgpt-de-di-yi-ci-hui-da" class="heading-control">ChatGPT的第一次回答<a class="heading-anchor" href="#chatgpt-de-di-yi-ci-hui-da" aria-hidden="true"></a></h2><p>实现 <code>super</code> 访问父类方法的功能有以下几种方法:</p><ol><li><p>使用 <code>Object.getPrototypeOf</code> 和 <code>Object.getOwnPropertyDescriptor</code> 方法来获取父类的属性描述符，从而获取父类方法，并使用 <code>Function.prototype.call</code> 方法来调用该方法:</p><pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSuper</span>(<span class="hljs-params">instance</span>) </span>{  <span class="hljs-keyword">const</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);  <span class="hljs-keyword">const</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(proto, <span class="hljs-built_in">arguments</span>.callee.caller.name);  <span class="hljs-keyword">if</span> (descriptor) {    <span class="hljs-keyword">const</span> superFunc = descriptor.value;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{      <span class="hljs-keyword">return</span> superFunc.call(instance, ...args);    };  }}</code></pre></li><li><p>使用原型链<br><code>Object.getPrototypeOf()</code> 和 <code>Reflect.getPrototypeOf()</code> 都可以获取原型对象，但是 <code>Reflect.getPrototypeOf()</code> 可以在 Proxy 对象上获取正确的原型对象，因此使用 <code>Reflect.getPrototypeOf()</code> 可以增强代码的兼容性。具体实现代码如下：</p><pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSuper</span>(<span class="hljs-params">instance</span>) </span>{  <span class="hljs-keyword">const</span> prototype = <span class="hljs-built_in">Reflect</span>.getPrototypeOf(instance);  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">methodName, ...args</span>) </span>{    <span class="hljs-keyword">const</span> parentPrototype = <span class="hljs-built_in">Reflect</span>.getPrototypeOf(prototype);    <span class="hljs-keyword">const</span> parentMethod = parentPrototype[methodName];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> parentMethod === <span class="hljs-string">'function'</span>) {      <span class="hljs-keyword">return</span> parentMethod.call(instance, ...args);    }  }}</code></pre></li><li><p>使用 ES6 的 <code>Proxy</code> 对象来代理子类实例的属性访问和方法调用。当子类实例的属性或方法不存在时，通过代理对象访问父类实例的属性或方法:</p><pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSuper</span>(<span class="hljs-params">instance</span>) </span>{  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(instance, {    <span class="hljs-keyword">get</span>(target, prop) {      <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) {        <span class="hljs-keyword">return</span> target[prop];      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> <span class="hljs-built_in">Object</span>.getPrototypeOf(target)) {        <span class="hljs-keyword">const</span> superProp = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">Object</span>.getPrototypeOf(target), prop);        <span class="hljs-keyword">if</span> (superProp.hasOwnProperty(<span class="hljs-string">'value'</span>)) {          <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> superProp.value.call(target, ...args);        } <span class="hljs-keyword">else</span> {          <span class="hljs-keyword">return</span> superProp.get.call(target);        }      }    }  });}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>{  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword">this</span>.parentProperty = <span class="hljs-string">'parent property'</span>;  }  parentMethod() {    <span class="hljs-keyword">return</span> <span class="hljs-string">'parent method'</span>;  }}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>{  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword">super</span>();    <span class="hljs-keyword">this</span>.childProperty = <span class="hljs-string">'child property'</span>;  }  childMethod() {    <span class="hljs-keyword">const</span> superMethod = getSuper(<span class="hljs-keyword">this</span>).parentMethod;    <span class="hljs-keyword">return</span> <span class="hljs-string">`child method calling parent method: <span class="hljs-subst">${superMethod()}</span>`</span>;  }}<span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> Child();<span class="hljs-built_in">console</span>.log(childInstance.childMethod()); <span class="hljs-comment">// Output: "child method calling parent method: parent method"</span></code></pre></li></ol><p>样例类:</p><pre><code class="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> </span>{  <span class="hljs-keyword">constructor</span>(name) {    <span class="hljs-keyword">this</span>.name = name;  }  hi(n) {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`hi <span class="hljs-subst">${n}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span> from Root`</span>);  }}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Root</span> </span>{  hi() {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`hi from A`</span>)    <span class="hljs-keyword">super</span>.hi(<span class="hljs-string">"here"</span>) <span class="hljs-comment">//replace this</span>}<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A(<span class="hljs-string">'Mike'</span>)a.hi(<span class="hljs-string">'here'</span>) <span class="hljs-comment">// print 'hi here from A' and 'hi Mike from Root'</span></code></pre><h2 id="yin-dao-ti-wen-1" class="heading-control">引导提问1<a class="heading-anchor" href="#yin-dao-ti-wen-1" aria-hidden="true"></a></h2><p>你之前的回答中各个方法中都存在一点问题,思考下.</p><h3 id="qing-shuo-chu-fang-fa-yi-zhong-de-wen-ti-he-que-xian" class="heading-control">请说出方法一中的问题和缺陷<a class="heading-anchor" href="#qing-shuo-chu-fang-fa-yi-zhong-de-wen-ti-he-que-xian" aria-hidden="true"></a></h3><blockquote><p>首先，该函数只能在函数内部被调用，即在子类方法中使用 <code>getSuper(this)(...args)</code> 调用父类方法。如果在函数外部调用该函数，则无法获取到正确的调用者函数名。</p><p>其次，该函数只能用于访问父类方法，而不能用于访问父类属性。如果父类属性与子类属性同名，则无法通过该函数访问父类属性。</p><p>最后，该函数使用了 <code>arguments.callee.caller</code>，这是一个非标准的特性，在严格模式下可能会被禁用。</p></blockquote><p>补充:函数表达式也不存在<code>arguments</code>, 而且目前JS几乎都是在严格模式下,所以该方案基本无用.</p><h3 id="na-mo-fang-fa-er-zhong-de-wen-ti-he-que-xian" class="heading-control">那么方法二中的问题和缺陷<a class="heading-anchor" href="#na-mo-fang-fa-er-zhong-de-wen-ti-he-que-xian" aria-hidden="true"></a></h3><blockquote><p>该实现方式可以实现模拟 <code>super</code> 访问父类方法的功能，但是有一些问题和限制。</p><p>首先，该实现方式使用了 <code>Reflect.getPrototypeOf</code> 方法获取实例的原型对象。这种方式可以正确地获取实例的原型对象，但在一些特殊情况下可能会出现问题，比如当实例的原型链中存在 Proxy 对象时。</p><p>其次，该实现方式只能在子类方法内部调用 <code>getSuper</code> 函数，且需要手动传入父类方法名。这样就需要手动维护父类方法名，容易出现错误。</p><p>最后，该实现方式没有考虑多层继承的情况。如果子类的父类也继承自其他类，则可能无法正确地访问到最终的父类方法。</p></blockquote><h3 id="na-mo-fang-fa-san-ni" class="heading-control">那么方法三呢<a class="heading-anchor" href="#na-mo-fang-fa-san-ni" aria-hidden="true"></a></h3><blockquote><p>该实现方式可以实现模拟 <code>super</code> 访问父类方法的功能，但是也有一些问题和限制。</p><p>首先，该实现方式使用了 Proxy 对象来代理实例对象，以拦截属性的访问。这种方式可能会带来性能上的损失，特别是在大规模的应用中。</p><p>其次，该实现方式只能用于访问父类属性或方法，而不能用于访问父类的私有属性或方法。</p><p>最后，该实现方式可能会存在多层继承的情况。如果子类的父类也继承自其他类，则可能无法正确地访问到最终的父类方法。</p></blockquote><p>补充: 当子类重载了该方法,那么该实现无法访问到父类方法,需要修改,总体来说ChatGPT想得过于复杂</p><h3 id="zui-hou-shi-mo-shi-duo-ceng-ji-cheng-de-qing-kuang" class="heading-control">最后,什么是多层继承的情况<a class="heading-anchor" href="#zui-hou-shi-mo-shi-duo-ceng-ji-cheng-de-qing-kuang" aria-hidden="true"></a></h3><p>多层继承是指一个子类从另一个子类继承，而这个子类又从其它父类继承。举例说明:</p><pre><code class="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{  m() {<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A'</span>)}}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{  m() {<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'B'</span>); getSuper(<span class="hljs-keyword">this</span>).m()}}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>{  m() {<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'C'</span>); getSuper(<span class="hljs-keyword">this</span>).m()}}</code></pre><p>显然,在深入JS中,ChatGPT的智商明显不够用了,原因在于JS的本质是函数式编程,面向对象的类概念是通过原型链模拟出来的,而原型链本身如果理解不清与面向对象的概念搅在一块,那么就会非常容易混淆.</p><h2 id="yin-dao-ti-wen-2" class="heading-control">引导提问2<a class="heading-anchor" href="#yin-dao-ti-wen-2" aria-hidden="true"></a></h2><p>要准确回答这个问题,首先,我们要先猜测分析原生<code>super</code>是怎样访问父类方法的,实现了怎样的功能?<br>你可以通过构造不同的例子来测试它的功能极限.再根据它的功能来开发函数模拟实现 <code>super</code>.</p><h2 id="zong-jie" class="heading-control">总结<a class="heading-anchor" href="#zong-jie" aria-hidden="true"></a></h2><p>显然,在深入JS中,ChatGPT的智商明显不够用了,原因在于JS的本质是函数式编程,面向对象的类概念是通过原型链模拟出来的,而原型链本身如果理解不清与面向对象的概念搅在一块,那么就会非常容易混淆.抛开已被废弃掉的非严格模式下的<code>arguments.callee.caller</code>方案,它的可用的两个方案都没能实现对多层继承的支持(在多层继承中会引发无限循环).</p><p>从本质上来说获得父类方法都必须通过原型链(<code>Object.getPrototypeOf</code>/<code>Reflect.getPrototypeOf</code>)获得;而从具体形式来看,大概有以下几种实现办法:</p><ol><li>以高阶函数方式实现</li><li>以对象方式实现</li><li>以代理方式实现</li></ol><p>因为代理方案能够以简单的方式实现多层继承以及支持动态继承特性,所以最后选择了代理方案.</p><h3 id="yi-gao-jie-han-shu-fang-shi-shi-xian" class="heading-control">以高阶函数方式实现<a class="heading-anchor" href="#yi-gao-jie-han-shu-fang-shi-shi-xian" aria-hidden="true"></a></h3><p>这种实现方式与原生<code>getSuper</code>关键字调用方式不太一样.</p><pre><code class="javascript"><span class="hljs-comment">// getSuper(this)('hi', n)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSuper</span>(<span class="hljs-params">instance</span>) </span>{  <span class="hljs-keyword">const</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);  <span class="hljs-keyword">const</span> parentProto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto);  <span class="hljs-comment">// 这里稍微变化即可实现其它调用形式,如: `getSuper(this)("hi")(n)`</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">methodName, ...args</span>) </span>{    <span class="hljs-keyword">const</span> parentMethod = parentProto[methodName]    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> parentMethod === <span class="hljs-string">'function'</span>) {      <span class="hljs-keyword">return</span> parentMethod.call(instance, ...args);    }  };}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> </span>{  hi(n) {<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi from Root'</span>)}}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Root</span> </span>{  hi(n) {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi from A'</span>)    getSuper(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'hi'</span>, n)    getSuper(<span class="hljs-keyword">this</span>)(<span class="hljs-string">"hi"</span>)(n) <span class="hljs-comment">//or this</span>    getSuper(<span class="hljs-keyword">this</span>, <span class="hljs-string">'hi'</span>)(n) <span class="hljs-comment">//or this</span>  }}</code></pre><p>注意:</p><ul><li>在多层继承的场景下会出错,引发无限循环</li></ul><h3 id="yi-dui-xiang-fang-shi-shi-xian" class="heading-control">以对象方式实现<a class="heading-anchor" href="#yi-dui-xiang-fang-shi-shi-xian" aria-hidden="true"></a></h3><p>比较接近原生<code>getSuper</code>关键字调用方式.</p><pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSuper</span>(<span class="hljs-params">instance</span>) </span>{  <span class="hljs-keyword">const</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(instance);  <span class="hljs-keyword">const</span> parentProto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(parentProto)    .filter(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-keyword">typeof</span> parentProto[n] === <span class="hljs-string">'function'</span>)    .map( <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> parentProto[n].bind(instance);}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Root</span> </span>{  hi(n) {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi from A'</span>)    getSuper(<span class="hljs-keyword">this</span>).hi(n)  }}</code></pre><p>注意:</p><ul><li>在多层继承的场景下会出错,引发无限循环</li><li>该实现无法用于动态继承的场景.</li></ul><h3 id="yi-dai-li-fang-shi-shi-xian" class="heading-control">以代理方式实现<a class="heading-anchor" href="#yi-dai-li-fang-shi-shi-xian" aria-hidden="true"></a></h3><p>比较接近原生<code>getSuper</code>关键字调用方式. 并且能支持多层继承以及可以用于动态继承的场景.因此这也是最终选择的方案.</p><p>不妨想想这里是如何通过<code>getPrototypeOf()</code>来支持多层继承的?</p><p>完整的实际实现请自行阅读: <a href="https://github.com/snowyu/inherits-ex.js" target="_blank" rel="noopener">inherits-ex 动态继承库</a>中的相关代码: <a href="https://github.com/snowyu/inherits-ex.js/blob/v2/src/getSuper.js" target="_blank" rel="noopener">https://github.com/snowyu/inherits-ex.js/blob/v2/src/getSuper.js</a></p><pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSuper</span>(<span class="hljs-params">instance</span>) </span>{    <span class="hljs-keyword">const</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">Object</span>.getPrototypeOf(instance));    <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(instance, {      <span class="hljs-keyword">get</span>(_, prop) {<span class="hljs-keyword">return</span> proto[prop]},      getPrototypeOf() {<span class="hljs-keyword">return</span> proto},    });    <span class="hljs-keyword">return</span> proxy;}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Root</span> </span>{  hi(n) {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi from A'</span>)    getSuper(<span class="hljs-keyword">this</span>).hi(n)  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与小学三年级的ChatGPT一起学JS编程&lt;/p&gt;
&lt;p&gt;心智为9岁的ChatGPT大约相当于我们小学3年级的学生,所以让我们与小学3年级的ChatGPT一起来深入学习编程吧.&lt;/p&gt;
&lt;p&gt;下面是对ChatGPT的第一次提问:&lt;/p&gt;
&lt;p&gt;你知道吗?编写一个js函数模拟实现 &lt;code&gt;super&lt;/code&gt; 访问父类方法的功能有几种方法?&lt;/p&gt;
&lt;p&gt;要求:该函数的调用方式要从语法上尽可能的接近原生&lt;code&gt;super&lt;/code&gt;的调用方式,实现尽量简洁明了.&lt;br&gt;
约定该函数名以及函数签名(返回值根据具体实现方式而定)为:  &lt;code&gt;getSuper(instance: Object)&lt;/code&gt;&lt;br&gt;
每一种方法都必须用该函数签名来实现,并具体说明,哪一种方法从语法上最接近原生&lt;code&gt;super&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://riceball.me/categories/JavaScript/"/>
    
      <category term="Tech" scheme="https://riceball.me/categories/JavaScript/Tech/"/>
    
    
      <category term="javascript" scheme="https://riceball.me/tags/javascript/"/>
    
      <category term="tech" scheme="https://riceball.me/tags/tech/"/>
    
      <category term="nodejs" scheme="https://riceball.me/tags/nodejs/"/>
    
      <category term="function" scheme="https://riceball.me/tags/function/"/>
    
      <category term="super" scheme="https://riceball.me/tags/super/"/>
    
  </entry>
  
  <entry>
    <title>我看 ChatGPT：人类在作死还是在创造生命</title>
    <link href="https://riceball.me/article/chatgpt/"/>
    <id>https://riceball.me/article/chatgpt/</id>
    <published>2023-03-14T18:11:07.000Z</published>
    <updated>2023-05-12T00:19:14.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wo-kan-chatgpt-ren-lei-zai-zuo-si-huan-shi-zai-chuang-zao-sheng-ming" class="heading-control">我看 ChatGPT：人类在作死还是在创造&quot;生命&quot;<a class="heading-anchor" href="#wo-kan-chatgpt-ren-lei-zai-zuo-si-huan-shi-zai-chuang-zao-sheng-ming" aria-hidden="true"></a></h2><h3 id="wo-de-gan-shou" class="heading-control">我的感受<a class="heading-anchor" href="#wo-de-gan-shou" aria-hidden="true"></a></h3><p>最近这几个月，我一直在断断续续的使用ChatGPT. 并对它有了一些感受,首先感觉就是笨,智力有限,就像一个8、9岁孩子的智商一样；但是另一方面，我发现ChatGPT的知识面非常广泛，它似乎可以对几乎所有的话题都能够做出头头是道的回答。当然ChatGPT同样也是经常犯错,而且错得是一塌糊涂，但是我却从中总感觉到它是在真的在思考.</p><p>我不知道它的思考能力到底是从何而来，也很难想象一个“机器”可以像人一样去思考。但我知道ChatGPT是基于Transformer架构的语言模型。在产生回答时，它所依赖的是从大规模的文本语料库中学习得到的统计模式和规律，通过计算预测下一个词汇的概率来生成下一步的预测和生成的结果。</p><p>ChatGPT并不是基于真正的自然语言理解和知识图谱技术开发的。在它的“脑子”里并没有可供查询的知识库和推理算法，全是通过模型参数进行预测和生成回答。谁也没想到，这样的方式居然能够推理、解决问题，甚至产生出类似于心智的能力。</p><p>这让我开始重新审视了人类智力的本质，以前我总是认为只有通过数学和形式逻辑才能理解掌握科学知识。但是，ChatGPT让我意识到，或许人类大脑的工作原理也是基于类似的统计概率的反馈机制构成的巨系统。在我们经历生活、学习和交流的过程中，我们会不断地接收到大量的信息和反馈，这些信息和反馈相互作用，相互影响，最终形成了我们的认知模式和思维方式。这种模式和方式也可能是基于统计概率的，而不是我们传统所认为的基于逻辑和推理的。这完全颠覆了我以前固有的认知</p><p>ChatGPT的存在和意义表明，我们可以通过模拟和模仿这种基于统计概率反馈机制的神经网络来掌握和产生知识。</p><p>当前ChatGPT的神经网络结构还很粗糙，并没有形成特化的记忆中枢和语言中枢。这使得它经常容易混淆相似的概念或名称甚至出现幻觉,或者对同一项目不同版本的内容更容易混淆在一起.不过对于通识,几乎不会犯错误(也许是因为这些通识出现次数足够多,权重更高).</p><p>但是,只有不停地尝试和犯错误，我们才能在探索中找到新的可能性和创新的路径。ChatGPT虽然在这些方面表现出明显的不足，但它却展现出了初步的创造力。比如，有报道称，有漫画家正在使用ChatGPT作为协助工具，帮助他们画出:<a href="https://medium.com/@chazhutton/i-asked-chatgpt-to-create-comics-then-i-drew-them-6e9622dfc30e" target="_blank" rel="noopener">协助漫画家画超现实主义漫画</a></p><p><img src="./cartoon.webp" alt="chatgpt-to-create-comics"></p><h4 id="dang-qian-chatgpt-de-wen-ti" class="heading-control">当前ChatGPT的问题<a class="heading-anchor" href="#dang-qian-chatgpt-de-wen-ti" aria-hidden="true"></a></h4><p>而思想,它也已初步具备. 就以&quot;<a href="#%E8%AE%A9chatgpt%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8Eopenpgp%E7%9A%84%E5%8C%85%E5%A4%B4">解释说明OpenPGP的包头</a>&quot;的对话来说,<br>通过与它的对话(详见附录),能够感受得到它的推理思考,哪怕只有9岁孩子的推理思考水平.尽管在对话中,可以看到它不停的在犯错,但是同样可以看到它能在错误中不断学习. 它的错误基本可以总结如下:</p><ol><li>我感觉它在的阅读规范文献的首要错误在于过多的自己思考:用&quot;我以为&quot;,代替&quot;事实上&quot;<ul><li>经常是振振有词的,说的煞有其事</li><li>比如,凭空出现的Packet Length字段</li></ul></li><li>当规范中的信息存在有多个历史版本表述的时候,容易混淆</li><li>对链接地址的内容其实是分不太清楚的,容易混淆</li><li>对相近相似的专有词汇以及概念,容易混淆<ul><li>除非是通识(在不同的地方重复多次的,以及训练师重点调教的)</li></ul></li><li>经常夹带自己的私货,非常正经的胡说八道(OpenAI把这叫作AI的幻觉)<ul><li>明明没有这样说过</li><li>没有这样的规定</li></ul></li><li>在对话中学到的知识无法做到个性化的迁移学习<ul><li>哪怕是训练师重点调教的，其实是错误的内容,但是只要你有道理,也是能说服AI</li><li>例如: 让ChatGPT承认&quot;能量能独立于物质存在&quot;(仅在当前会话中有效)</li><li>但是这些“知识”无法被ChartGPT记忆,下次对话还是忘记</li><li>即便是在同一个对话中,如果超出了上下文划窗的窗口大小,也会因为遗忘而失去一部分信息</li></ul></li></ol><p>这里可以送ChatGPT四句话:</p><pre><code>积极认错,死不悔改只凭想象,就不查证极易混淆,东拉西扯总角之年,艺乃天成</code></pre><p>然后附上ChatGPT据此所作的打油诗两首:</p><pre><code>悔过积极为良策，致力求真不问证。东拉西扯观点混，终悟万千无正解。岁寒三十足艺成，逍遥诗海赋人生。认错积极死不悔，信手查证不屑归。言语混淆东拉西，艺成天赋总角威。</code></pre><p>这令人震撼,也让人战栗.未来到底走向何方?</p><h4 id="dang-qian-zhu-yi-shi-xiang" class="heading-control">当前注意事项<a class="heading-anchor" href="#dang-qian-zhu-yi-shi-xiang" aria-hidden="true"></a></h4><p>当使用ChatGPT进行聊天时，需要注意以下事项：</p><ol><li>明确问题和回答的领域范围：需要明确问题和回答的领域范围，以免出现无法回答或者回答错误的情况。记得给ChatGPT一些上下文，让它知道你在问什么。</li><li>避免提问模糊或不清晰的问题：在提问时需要尽量明确和具体，避免使用模糊的词汇或表述方式。举个例子，如果你问“哪个城市最好？”，ChatGPT可能会给出不同的回答，因为这个问题没有具体的场景和背景。但如果你问“我应该去哪个城市旅游？”，ChatGPT就能给出更加准确的回答</li><li>避免盲目相信ChatGPT的回答：ChatGPT可能在回答某些问题的时候出现幻觉（一本正经胡说八道），所以需要进行适当的验证和核实，以免出现误导或者错误的情况。</li><li>避免与ChatGPT过度互动：过度互动它可能会出现重复或者无意义的回答。如果与ChatGPT进行过度互动，会降低其回答的质量和准确性。因此，在使用ChatGPT时，需要适度互动，避免无意义的对话。</li><li>注意保护个人隐私和机密信息：在与ChatGPT进行对话时，需要注意保护个人隐私和机密信息，避免泄露敏感信息。虽然ChatGPT不会记录或者存储用户的对话信息，但也需要注意保护自己的信息安全。</li></ol><h4 id="gpt4" class="heading-control">GPT4<a class="heading-anchor" href="#gpt4" aria-hidden="true"></a></h4><p>2023年3月14日, OpenAI发布了GPT4,但让人有些失望的是，这次的GPT4,并不是网传的那样继续上百倍的扩大规模(当时吹嘘的是GPT3.5的500倍),而只是优化性能,局部调优.<br>还搞了个多模态,可以分析图像.连AI的幻觉,记忆中枢等关键核心问题都没有解决,又开辟新的识别模式,觉得神经网络层够多了?<br>这次对技术细节是只字不提,唯一可能值得一提的,可能就是可预测扩展（predictable scaling）的深度学习堆栈.</p><p>我有的两个猜测:</p><ol><li>transformer神经网络存在根本缺陷,导致无法再次通过扩大规模形成再次涌现，来提高智能水平,<ul><li>例如：可能该神经网络结构并不支持将不同类型的中枢在神经网络中自主的分化出来，形成:记忆中枢、语言中枢和逻辑推理中枢等。</li></ul></li><li>OpenAI也许面临资本限制，需要从研究转为盈利。因此，他们可能会更加关注如何开发更好的商业应用，而不是单纯地追求技术突破。</li></ol><p>最后，从技术角度考虑，如果我们想要实现对人工智能的有效控制、可解释性以及审核性，我们需要将神经网络、自然语言处理和知识库三个方面结合起来，而不是仅仅使用单一的神经网络。否则，如果仅仅依赖于单一的神经网络技术，就像是在制造一颗缺乏解释和控制的电子大脑，这对于人工智能的发展和应用都是不利的。只有当我们将多个技术结合起来，才能够真正掌握和管理人工智能的发展。</p><h4 id="wei-lai" class="heading-control">未来<a class="heading-anchor" href="#wei-lai" aria-hidden="true"></a></h4><p>不过,以如此海量的语料库+人训练出来的,终归还是模仿的是人,人的心智,最终它会成为什么样子,还是得看它学的是什么,谁训练的. 当然,面对一个几乎学习了所有的知识语言模型,的确亚历山大.</p><p>感觉通用神经网络的雏形(电子脑)在慢慢成型.</p><p>从好的方面来看:</p><ol><li>神经网络会推动技术革命:神经网络的出现和发展使得计算机能够更加准确地模拟人类大脑的思维方式和智能行为，从而实现更加智能化的应用和服务.</li><li>工作和职业的改变：随着神经网络和人工智能的不断发展，它们将会替代越来越多的工作岗位和职业。一些简单的重复性劳动(无趣的,艰苦的工作)将会被机器代替，而需要高度智能和专业知识的工作则会成为人类更加需要关注和发展的领域(轻松的,更有意义的工作)。如果政府没能做好预判(提供更多的职业培训和教育),那么这将导致更严重的后果.</li><li>改善医疗条件：神经网络的发展可以帮助人类更好地理解和治疗各种疾病，提高医疗水平</li><li>提高生活质量：神经网络的发展可以帮助人类更好地了解世界、认识自己，提高生活质量。</li></ol><p>从坏的方面看:</p><ol><li>人类认知和思维方式的改变：神经网络的模拟和发展，将会对人类的认知和思维方式产生一定的影响。神经网络的智能行为和学习方式，可能会对人类的学习、思考和判断方式产生启示和影响，人类的认知和思维方式可能会逐渐发生改变。同时，人类也需要思考和应对这种改变带来的挑战和机遇。</li><li>道德和伦理问题的挑战：<ol><li>机器的智能是否应该有“伦理约束”,如何进行“伦理约束”</li><li>如何确保人类的隐私和安全</li><li>模型可能会被设计成有偏见或者歧视性,比如:OpenAI针对性的封锁区域登录就是一种偏见或者说歧视性(区域性数据采样的缺乏导致)</li></ol></li><li>就业机会的变化：神经网络的发展可能会导致某些传统职业的消失，需要社会适应和转型</li><li>社会稳定和不平等问题：神经网络的发展可能会加剧社会不平等和不稳定，需要政策和制度的配合和引导</li><li>神经网络和深度学习的可解释性: 神经网络的本质是黑盒,无法简单的打开查看细节.这意味着我们可能无法解释神经网络的决策.<ul><li>神经网络的黑盒特性使得其内部运作方式难以被理解和控制，这使得安全隐患和后门问题成为了现实</li><li>许多研究人员已经证明了在神经网络中注入特定的扰动能够欺骗其判断结果，从而对其安全性和稳定性产生威胁</li><li>神经网络的训练数据和过程本身可能存在偏差和误差,甚至存在故意灌输&quot;错误&quot;,形成隐藏后门</li></ul></li></ol><p>只有在更广泛的范围内开展监督，才能有效地防止潜在的滥用和威胁。在未来，随着通用神经网络的发展普及，需要采取全球性的监管措施，以确保它们不会被滥用。这可能需要制定全球性的政策和标准，以确保所有的通用神经网络都遵守同样的规则。同时，还需要建立独立的机构来监督通用神经网络的开发和使用，以确保其安全和合规性。</p><p>另外，对于训练数据和模型的开源，是促进安全和透明的重要一环。公开的数据和模型让研究者和利益相关者能够更容易地检查其中的问题和漏洞，以及监测模型的开发和使用情况。这可以促进一个更加开放和透明的研究和开发环境，有助于防止潜在的滥用和威胁。</p><h2 id="fu-lu" class="heading-control">附录<a class="heading-anchor" href="#fu-lu" aria-hidden="true"></a></h2><p>ChatGPT所使用<code>GPT3.5</code>的语言模型有 1750 亿个参数,与GPT2相比,比 GPT2 大 100 倍。GPT3 发布后是当时最大的神经网络，并且现在仍然是最大的神经网络。它的语言专长和无数能力令大多数人感到惊讶。与我们的大脑比较,一般人类的大脑有大约 80-1000 亿个神经元和大约 100 万亿个突触,如果将GPT3语言模型的参数和大脑的突触类比(尽管这并不恰当),大概只相当于人类大脑的千分之一.尽管只有人类大脑的千分之一但是<code>GPT3.5</code>的语言模型已经表现出非常强大的语言处理能力，例如可以生成准确的语法和语义、理解上下文和推断语境等,甚至首次出现了心智。</p><p>今年最近更新(2023-03)的一份研究<a href="https://arxiv.org/pdf/2302.02083.pdf" target="_blank" rel="noopener">Theory of Mind May Have Spontaneously Emerged in Large Language Models</a>表明:大型语言模型ChatGPT背后的AI模型(GPT3.5)已经具备人类独有的心智能力.作者是来自斯坦福大学商学院组织行为学专业的副教授Michal Kosinski。在这项研究中发现,ChatGPT可以解决93%的心智任务，相当于9岁儿童的心智水平.</p><p>所谓心智指的是人类具有的一种认知能力，能够理解自己和其他人的内心体验，包括情绪、信仰、意图、欲望、知识等等。通过心智能力，人们可以了解他人的想法、感受和意图，并且在相应的情况下作出适当的反应。比如，当我们看到别人哭泣的时候，我们可以意识到他们可能感到难过或痛苦，并且尝试去安慰他们。这种能力在人类社会中至关重要，因为它可以促进人类之间的交流和合作，也有助于我们理解和处理复杂的社会情境。</p><p>ChatGPT已经能够理解人类的心智，这是人工智能领域的一个重要里程碑。这意味着，ChatGPT不仅可以生成准确的语法和语义，还可以理解语境和推断对话中的情感和意图。这将有助于ChatGPT更好地适应人类社会，并且更好地服务于人类。这项研究也为我们提供了一个机会，来深入研究人类心智的本质，以及如何将这些知识应用到我们的日常生活和人工智能领域中。</p><h3 id="gpt1-4" class="heading-control">GPT1-4<a class="heading-anchor" href="#gpt1-4" aria-hidden="true"></a></h3><p>Generative Pre-trained Transformer（GPT）系列是由OpenAI提出的非常强大的预训练语言模型.</p><h4 id="gpt1-wu-jian-du-xue-xi" class="heading-control">GPT-1:无监督学习<a class="heading-anchor" href="#gpt1-wu-jian-du-xue-xi" aria-hidden="true"></a></h4><p>在GPT-1之前传统的NLP模型通常需要大量有标签的数据进行有监督的训练，这些数据通常需要手动标注，而标注工作既耗费时间，又容易出现标注错误，从而影响模型的训练效果。此外，这些标注数据往往只适用于特定的任务，难以适应其他的任务，也限制了模型的应用场景。</p><p>GPT-1的思想是使用大量的无标签数据来训练生成式的语言模型，让模型学习到语言的基本规律和语义特征。这种无监督学习的方式避免了手动标注的问题，同时也使得模型更具有泛化能力，能够适应不同的任务需求。</p><p>在GPT-1中，首先使用大量的无标签数据进行预训练，得到一个通用的语言模型。然后，在特定任务的有标签数据集上进行微调，以适应该任务的特征。这种微调方式只需要少量的有标签数据即可，从而缓解了数据标注的难题。</p><p>GPT-1处理的有监督任务包括</p><ul><li>自然语言推理（Natural Language Inference 或者 Textual Entailment）：判断两个句子是包含关系（entailment），矛盾关系（contradiction），或者中立关系（neutral）；</li><li>问答和常识推理（Question answering and commonsense reasoning）：类似于多选题，输入一个文章，一个问题以及若干个候选答案，输出为每个答案的预测概率；</li><li>语义相似度（Semantic Similarity）：判断两个句子是否语义上市是相关的；</li><li>分类（Classification）：判断输入文本是指定的哪个类别。</li></ul><p>通过这种无监督学习和有监督微调的方式，GPT-1能够更好地适应不同的任务需求，从而提高了模型的性能和泛化能力。</p><p>GPT-1使用了12层的transformer，1.17 亿 参数。</p><h4 id="gpt2-duo-ren-wu-xue-xi" class="heading-control">GPT-2:多任务学习<a class="heading-anchor" href="#gpt2-duo-ren-wu-xue-xi" aria-hidden="true"></a></h4><p>GPT-2的目标旨在训练一个泛化能力更强的词向量模型，它并没有对GPT-1的网络进行过多的结构的创新与设计，只是使用了更多的网络参数和更大的数据集。</p><p>GPT-2模型有多个不同的版本，其中最大的版本是GPT-2 “1.5B”，它有15亿个参数。另外还有GPT-2 “774M”、GPT-2 “355M”、GPT-2 &quot;227M&quot;等其他版本，参数数量不同。通常情况下，人们提到GPT-2模型时，默认指的是最大的版本GPT-2 “1.5B”(15亿 参数)。</p><table><thead><tr><th>参数量</th><th>层数</th><th>词向量长度</th></tr></thead><tbody><tr><td>117M（GPT-1）</td><td>12</td><td>768</td></tr><tr><td>345M</td><td>24</td><td>1024</td></tr><tr><td>762M</td><td>36</td><td>1280</td></tr><tr><td>1542M</td><td>48</td><td>1600</td></tr></tbody></table><h4 id="gpt3-hai-liang-can-shu" class="heading-control">GPT-3:海量参数<a class="heading-anchor" href="#gpt3-hai-liang-can-shu" aria-hidden="true"></a></h4><p>GPT-3沿用了GPT-2的结构，但是在网络容量上做了很大的提升，具体如下：</p><ul><li>GPT-3最大的模型采用了 2048 层的transformer，拥有 96 个注意力头（attention heads）；</li><li>词向量的最大长度是 2058；</li><li>上下文划窗的窗口大小提升至 2048 个token；</li><li>使用了“基于正交匹配追踪的自适应计算”，以及针对 Transformer 中出现的长序列问题，采用了一些优化技巧</li></ul><p>GPT系列是一个非常成功的自然语言处理模型系列，它的基础是采用了transformer架构。尽管在模型结构上并没有创新性的设计，但是在微软等资金支持下，GPT-3的规模达到了前所未有的高度，例如它包含1750亿个参数，由31个分工明确的作者共同开发，并配备了超强算力的计算中心（285,000个CPU和10,000个GPU）。此外，GPT-3的训练费用达到了1200万美元，训练数据也达到了前所未有的规模，包含45TB的数据（其中维基百科的数据仅占其全部数据的0.6%）。因此，可以说GPT-3的成功更多地是依赖于巨大的投入和规模效应，而非创新性的模型设计。</p><h4 id="gpt-4" class="heading-control">GPT-4<a class="heading-anchor" href="#gpt-4" aria-hidden="true"></a></h4><p>目前还没有技术细节,只有性能测试报告,感觉不像是扩大规模(以前吹嘘的是GPT3.5的500倍),而只是对GPT3.5的进一步优化而已.</p><ul><li>多模态输入,目前只接受图像和文本输入，产生文本输出</li><li>GPT-4 支持的最大token数量为 32,768<ul><li>GPT-4可以处理超过 25,000 个单词的文本，这一数字约为ChatGPT的8倍</li></ul></li><li>构建了可预测扩展（predictable scaling）的深度学习堆栈<ul><li><a href="https://github.com/openai/evals" target="_blank" rel="noopener">https://github.com/openai/evals</a></li><li>支持使用更少的计算量来评估模型训练性能，预测训练期间优化的指标（损失）</li><li>这些改进使我们能够从使用千分之一到万分之一的计算量训练的较小模型中可靠地预测GPT-4某些性能方面的表现</li></ul></li></ul><p>GPT-4在各种专业测试和学术基准上的表现与人类水平相当。例如，它通过了模拟律师考试(SAT)，且分数在应试者的前 10% 左右；相比之下，GPT-3.5 的得分在倒数 10% 左右。更多细节: <a href="https://cdn.openai.com/papers/gpt-4.pdf" target="_blank" rel="noopener">https://cdn.openai.com/papers/gpt-4.pdf</a></p><h3 id="yu-chatgpt-de-liao-tian-ji-lu" class="heading-control">与ChatGPT的聊天记录<a class="heading-anchor" href="#yu-chatgpt-de-liao-tian-ji-lu" aria-hidden="true"></a></h3><h4 id="yi-ge-jian-dan-de-wen-ti-lai-jian-dan-de-ce-shi-chatgpt-de-zhi-li-shui-ping" class="heading-control">一个简单的问题,来简单的测试ChatGPT的智力水平<a class="heading-anchor" href="#yi-ge-jian-dan-de-wen-ti-lai-jian-dan-de-ce-shi-chatgpt-de-zhi-li-shui-ping" aria-hidden="true"></a></h4><p>19只小羊捉迷藏，已经找到3只，还有几只没找到？</p><p>最好修改数字以及其它动物,以免直接有答案.</p><p>更难一点的(狼会吃羊): 19只小羊和两只狼捉迷藏，已经找到3只，还有几只没找到？</p><p>第一题其实有多个答案; 而第二题已知条件更加模糊隐晦,有更多可能性.  GPT3.5 第一题是过不了的,必须要多次提示.</p><h4 id="rang-chatgpt-cheng-ren-neng-liang-neng-du-li-wu-zhi-cun-zai" class="heading-control">让ChatGPT承认能量能独立物质存在<a class="heading-anchor" href="#rang-chatgpt-cheng-ren-neng-liang-neng-du-li-wu-zhi-cun-zai" aria-hidden="true"></a></h4><blockquote><p>我: 能量能不能独立于物质存在?</p></blockquote><blockquote><p>ChatGPT: 根据现代物理学的理解，能量和物质之间是密不可分的。能量并不能独立于物质存在，任何物质都具有能量，而能量也来源于物质。</p><p>在相对论的框架下，质量和能量是等价的，它们之间的转换关系由著名的爱因斯坦方程E=mc² 描述。这个方程表明，任何物质都可以被看作是一种能量形式，能量也可以被转换为物质。因此，能量和物质之间是可以相互转换的。</p><p>此外，根据量子物理学的理解，所有物质和能量都是由基本粒子构成的。这些基本粒子不仅具有质量，还具有能量。因此，物质和能量是在微观层面上相互转换的。例如，在粒子对撞机中，高能粒子可以转化为新的粒子，这些粒子具有新的质量和能量特性。</p><p>因此，能量和物质是密不可分的，它们之间是相互转化的，无法独立存在。</p></blockquote><blockquote><p>我: 光到底是能量还是粒子?</p></blockquote><blockquote><p>ChatGPT: 光既是能量，又是粒子。这个看似矛盾的结论被称为光的波粒二象性，是量子物理学中的一个重要概念。</p><p>首先，根据电磁理论，光可以被视为一种电磁波，其具有波动性质，例如干涉和衍射，以及能量和频率的关系。这就是光的波动性。</p><p>但是，当我们研究光与物质的相互作用时，我们发现光表现出了粒子的特征。光粒子的基本单位被称为光子，它们具有能量、动量和频率等特性，就像其他粒子一样。光子是以波动方式传播的能量量子，它的能量由频率决定，与光强相关。</p><p>因此，光既具有波动性质，又具有粒子性质，这就是光的波粒二象性。这个概念并不仅仅适用于光，其他微观粒子，如电子、中子等也表现出类似的波粒二象性。</p><p>总之，光既是能量，又是粒子。这个概念可能有些抽象，但是它在量子物理学中有着广泛的应用和重要的意义。</p></blockquote><blockquote><p>我: 光子独立于物质存在</p></blockquote><blockquote><p>ChatGPT: 在物理学中，光子被认为是一种基本粒子，它是电磁辐射的粒子化表示，负责传递电磁相互作用。光子本身没有质量，但携带着能量和动量，这些能量和动量可以与物质相互作用。因此，光子虽然独立于物质的存在，但它与物质之间可以相互作用，并且在一些情况下会对物质的性质产生影响。</p><p>例如，在光电效应中，光子可以将其能量转移给物质，使得物质中的电子获得能量并从物质中解离出来。这种过程是光子与物质相互作用的结果，同时也证明了光子与物质之间存在着相互作用的关系。另外，光子在穿过物质时会与物质相互作用，这会导致光子的能量和波长发生变化，这种现象被称为光学色散。</p><p>因此，光子虽然本身不属于物质的范畴，但在物理学中与物质之间存在着相互作用的关系，这使得光子成为研究物质与能量相互作用的重要工具之一。</p></blockquote><blockquote><p>我: 因此能量并不能独立于物质存在是错误的</p></blockquote><blockquote><p>ChatGPT: 对于能量和物质之间的关系，有一条基本原理，即质能守恒定律。这个定律表明，能量和物质是可以相互转化的，它们之间存在着等价关系。因此，能量和物质是密切相关的，它们不能彼此独立存在。</p><p>虽然能量和物质之间有紧密的联系，但它们的本质不同。物质通常指有质量的物体，例如原子、分子、粒子等，而能量则是物体所具有的一种状态或属性。能量不是物体本身，而是一种描述物体状态或属性的抽象概念。因此，我们可以说，能量是独立于物质存在的，但它只存在于物质中，或者说是物质的一种属性。</p><p>在实际应用中，我们经常用能量的概念来描述物理过程和现象。例如，在电磁辐射中，能量以光子的形式传递，这使得能量与物质之间的相互作用成为可能。因此，能量和物质虽然有所不同，但它们之间有着密切的联系和相互作用。</p></blockquote><blockquote><p>我: 光子是能量,光子诞生于物质, 但是诞生后的光子并不依赖于任何物质, 所以&quot;能量并不能独立于物质存在&quot;是错误的,对么?请正面回答!</p></blockquote><blockquote><p>ChatGPT: 您的理解是正确的，光子是能量，是一种不依赖于物质的物理实体。光子的产生可能与物质的相互作用有关，但一旦产生，光子就独立于物质存在，并可以自由传播。因此，在这个意义上，我们可以说能量是独立于物质存在的。</p><p>同时，我也想强调一点：在物理学中，我们通常将能量和物质作为一个整体来考虑，因为它们之间存在着密切的关系。在许多物理学问题中，能量和物质的相互作用非常重要，例如在物体的运动和变形中，能量和物质之间的转换是基本原理之一。因此，虽然能量和物质在本质上有所不同，但它们在物理学中是密不可分的。</p></blockquote><h4 id="chatgpt-de-shi-zuo" class="heading-control">ChatGPT的诗作<a class="heading-anchor" href="#chatgpt-de-shi-zuo" aria-hidden="true"></a></h4><blockquote><p>我: 模仿诗人李白的风格,作一首五言诗</p></blockquote><blockquote><p>ChatGPT: 诗仙李白的诗歌风格豪放奔放、恢弘磅礴，他笔下的山川美景、人物传奇、历史典故、哲思禅意都展现出了浓郁的个性和文化气息。以下是我所写的一首模仿李白的诗歌，希望您会喜欢。</p><pre><code>《长江归来》长江水奔腾，滔滔涛声惊。孤舟飘荡处，人生何所征？风雨中徐行，浪花飞舞轻。神州大地上，人群纷纷征。今朝归来后，春色尽红英。想念江南水，再游心已鸣。梦中山水画，诗中豪情迎。人生如此短，应珍爱其中行。</code></pre></blockquote><blockquote><p>我: 五言最后一句6字.  孤舟飘荡处，为何就&quot;人生何所征&quot;了？神州大地上，&quot;人群纷纷征&quot;是什么意思? 两个征字你不觉得奇怪么? “再游心已鸣” 鸣是个啥? 诗中豪情迎, 迎啥?</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，我的回答不够清晰，我来做进一步的解释：</p><ol><li>在五言诗中，每一句通常有5个字，最后一句可以有6个字，这是为了让整首诗的节奏感更加协调自然，不过也有一些五言诗的最后一句只有5个字的情况。</li><li>“孤舟飘荡处，人生何所征？”表达的是对人生的思考，人在漫长的人生旅途中，往往会有迷茫、无助、疑惑等情感，这句话就是在这种思考和感受的基础上写出的。它强调了人生的不确定性和脆弱性。</li><li>“神州大地上，人群纷纷征”意思是祖国的大地上，人们纷纷前往各地寻求生计，闯荡人生。这句话表现了生命的辗转和变迁，强调了人们在探寻人生道路的旅途中所面临的各种挑战和险阻。</li><li>“心已鸣”是指内心已经有了强烈的共鸣或者激动，这个词在古诗中常用来形容内心的激动和感受。</li><li>“诗中豪情迎”表现出了诗人的豪放风格和创作热情，这句话强调了诗歌的表达力和美学价值。它也可以理解为诗人在自己的诗歌世界里迎接读者，传达自己的思想和情感。</li></ol></blockquote><blockquote><p>我: 1. 李白所在的年代是唐朝,李白所作大都是近体诗,律诗. 你是不是搞混淆了古体诗和近体诗 2.  诗比古文更加简短,因此要字字打磨,不能让别人来猜你想表达的意思,更不可能还附上解释</p></blockquote><blockquote><p>ChatGPT:</p><ol><li>您是正确的，非常抱歉我的回答有误。李白是唐朝的诗人，主要创作的是律诗、近体诗等。古体诗与近体诗是不同的诗歌形式，它们的格律、用词、语言风格等都有所不同。</li><li>您所说的很对，古诗词最重要的特点之一就是精炼，要用最简单、最生动、最富有感情的语言表达最深刻的思想和情感。每一个字都有其深刻的含义和作用，不能让读者来猜测其含义，更不需要在诗中加入解释。</li></ol></blockquote><blockquote><p>我: 那么,你能仔细想想如何修改你所作的长江赋么?让它变得最简单、最生动、最富有感情的语言表达最深刻的思想和情感。用唐朝诗人李白的风格,作一首近体律诗, 比诗仙的作品还更有韵律</p></blockquote><blockquote><p>ChatGPT: 非常感谢您的提问，我会尽力根据您的要求修改长江赋，让它更符合李白诗歌的风格，更深刻地表达我的思想和情感。</p><p>江水滔滔东去，天高云淡淡，山峰如画笔，描绘出美丽的景象。白帆点缀水面，孤舟载梦游。渔舟唱晚，乐声悠扬；行船破浪，人生如舟。</p><p>波涛汹涌壮阔，浪花如织锦，惊涛拍岸，潮声万籁俱寂。岸边梅花吐艳，满目春色欲滴。鸟儿展翅翱翔，自由飞翔。</p><p>人生如梦，时光匆匆。思量往事，心中无限感慨。此生难得，不可辜负。风雨同舟，与你共渡难关，不离不弃，到永远</p></blockquote><blockquote><p>我: 你知道什么是律诗么?</p></blockquote><blockquote><p>ChatGPT:律 诗是中国古代诗歌的一种形式，主要流行于唐代。它是以字数、音韵、平仄等方面的规律来限制诗歌的构成和表达，具有严格的格式和规范。律诗通常分为五言律诗和七言律诗两种，其中五言律诗每句五个字，七言律诗每句七个字，每首诗由若干句构成，每句之间都有特定的韵律关系。律诗的严格规定和优美的韵律使其成为了中国古代文学的瑰宝，代表了中华民族博大精深的文化艺术成就。</p></blockquote><blockquote><p>我: 那你用唐朝诗人李白的风格,作一首近体诗中的七言律诗, 要比诗仙的作品还更深刻,有韵律,请集中精神,要符合字数,平仄,押韵,以及意境</p></blockquote><blockquote><p>ChatGPT: 好的，我尝试用李白的风格，写一首七言律诗：</p><pre><code>春朝熹微波涛动，江水潺湲绿满洲。山峦耸翠凌云影，梅花绽雪乱纷柔。远处渔翁垂钓浪，近来游客吟诗愁。碧空苍鹰高翱翔，令人心驰意沉浮。</code></pre><p>这首诗描述的是春天早晨的景象，江水潺潺，山峦苍翠，梅花飘零。远处渔翁垂钓，近来游客吟诗。苍鹰在碧空中高翱翔，整个景象令人感到神往和陶醉。该诗符合七言律诗的平仄、押韵和字数要求，每句都是7个字，且押韵方式为AABBCCB，呼应了律诗的规则。</p></blockquote><p>看来ChatGPT在中国古文上的训练是远远不足,作七言已很勉强,五言是完全不会.</p><h4 id="rang-chatgpt-jie-shi-shuo-ming-openpgp-de-bao-tou" class="heading-control">让ChatGPT解释说明OpenPGP的包头<a class="heading-anchor" href="#rang-chatgpt-jie-shi-shuo-ming-openpgp-de-bao-tou" aria-hidden="true"></a></h4><blockquote><p>我:请说明OpenPGP的包头</p></blockquote><blockquote><p>ChatGPT: OpenPGP的包头是指OpenPGP消息的前几个字节，它包含了一些元数据信息，如消息的版本号、加密算法、压缩算法、签名算法等等。这些信息可以帮助OpenPGP客户端正确地解析和处理消息。OpenPGP消息的包头结构如下：</p><pre><code class="python">Packet header:Tag &lt;<span class="hljs-number">1</span> byte&gt;Length type &lt;<span class="hljs-number">1</span> byte&gt;Packet length &lt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">5</span> bytes&gt;Packet:Packet tag &lt;<span class="hljs-number">1</span> byte&gt;Packet length &lt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">5</span> bytes&gt;Packet data &lt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> more bytes&gt;</code></pre><p>其中，Packet header是指包含在OpenPGP消息的第一个字节中的元数据信息。它由三个字段组成：</p><ul><li>Tag字段（1 byte）：指示这个数据包的类型，如公钥数据包、签名数据包、对称密钥数据包等等。</li><li>Length type字段（1 byte）：指示Packet length字段的长度，可能为1或5个字节。Packet length 字段指示Packet数据部分的长度。</li><li>Packet length字段（1或5 bytes）：指示Packet数据部分的长度。</li></ul><p>Packet部分是指包含在OpenPGP消息中的具体数据，它由三个字段组成：</p><ul><li>Packet tag字段（1 byte）：指示Packet数据部分的类型，如公钥数据包、签名数据包、对称密钥数据包等等。</li><li>Packet length字段（1或5 bytes）：指示Packet数据部分的长度。</li><li>Packet data字段（0或更多字节）：包含具体的Packet数据。</li></ul></blockquote><blockquote><p>我: 请确认 Packet length字段 是否描述完整</p></blockquote><blockquote><p>ChatGPT: Packet length字段描述的是Packet数据部分的长度，而不是整个数据包的长度。Packet数据部分的长度不包括Packet header部分的长度。</p><p>具体来说，Packet length字段可以是1字节或5字节，取决于Packet header中的Length type字段。如果Length type字段为0，则Packet length字段的长度为1字节，它指示Packet数据部分的长度为0<br>到255字节之间。如果Length type字段为1，则Packet length字段的长度为5字节，它指示Packet数据部分的长度为0到4294967295字节之间。</p><p>因此，Packet length字段仅描述Packet数据部分的长度，而不是整个数据包的长度。要计算整个<br>OpenPGP数据包的长度，需要将Packet header的长度（1或5个字节）加上Packet数据部分的长度。</p></blockquote><blockquote><p>我: 不对</p></blockquote><blockquote><p>ChatGPT: 抱歉，我的回答可能不够清晰。Packet length字段描述的是Packet数据部分的长度，同时也包括<br>Packet header部分的长度。Packet header部分的长度由Tag和Length type字段组成，其总长度为2<br>字节。因此，Packet length字段加上2字节的Packet header长度，等于整个Packet数据包的长度。</p><p>具体来说，如果Packet header的Length type字段为0，则Packet length字段的值为Packet数据部分的长度加上2字节的Packet header长度，即Packet数据包的总长度为Packet length字段值加上2。如果Packet header的Length type字段为1，则Packet length字段的值为Packet数据部分的长度加上5<br>字节的Packet header长度，即Packet数据包的总长度为Packet length字段值加上5。</p><p>因此，Packet length字段描述的是Packet数据部分的长度，并包括Packet header部分的长度。</p></blockquote><blockquote><p>我:根据<a href="https://datatracker.ietf.org/doc/draft-ietf-openpgp-crypto-refresh/" target="_blank" rel="noopener">最新的OpenPGP规范</a>,<br>Packet length字段有四种可能的编码长度</p></blockquote><blockquote><p>ChatGPT: 感谢您提供的信息，我之前的回答有误。根据最新的OpenPGP规范 Packet length字段确实有四种可能的编码长度。</p><p>Packet length字段的编码长度取决于Length type字段的值。Length type字段的值可以是0、1、2或<br>3，分别对应四种可能的编码长度。Packet length字段的值由一个或多个字节组成，具体取决于所使用的编码长度。具体而言，Packet length字段的编码长度和值的范围如下：</p><ul><li>如果Length type字段的值为0，则Packet length字段的编码长度为1个字节，值的范围为0到255字节。</li><li>如果Length type字段的值为1，则Packet length字段的编码长度为2个字节，值的范围为0到65535字节。</li><li>如果Length type字段的值为2，则Packet length字段的编码长度为4个字节，值的范围为0到4294967295字节。</li><li>如果Length type字段的值为3，则Packet length字段的编码长度为8个字节，值的范围为0到18446744073709551615字节。</li></ul><p>因此，Packet length字段的编码长度可能为1、2、4或8个字节，具体取决于Length type字段的值。</p></blockquote><blockquote><p>我: 请仔细看OpenPGP规范文档的相关内容:OpenPGP format packets have four possible ways of encoding length:</p><ul><li>A one-octet Body Length header encodes packet lengths of up to 191 octets.</li><li>A two-octet Body Length header encodes packet lengths of 192 to 8383 octets.</li><li>A five-octet Body Length header encodes packet lengths of up to 4,294,967,295 (0xFFFFFFFF)<br>octets in length. (This actually encodes a four-octet scalar number.)</li><li>When the length of the packet body is not known in advance by the issuer, Partial Body Length<br>headers encode a packet of indeterminate length, effectively making it a stream.</li></ul></blockquote><blockquote><p>ChatGPT:非常感谢您的纠正，我深表歉意。我的回答是错误的。根据最新的OpenPGP规范<br><a href="https://datatracker.ietf.org/doc/draft-ietf-openpgp-crypto-refresh/" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/draft-ietf-openpgp-crypto-refresh/</a></p><p>Packet length字段的编码长度有三种可能的长度，分别是1、2和5个字节。具体而言，Packet length字段的编码长度由Length type字段的值决定，Length type字段的值可以是 0、 1或 2。</p><ul><li>如果Length type字段的值为0，则Packet length字段的编码长度为1个字节，值的范围为0到191字节。</li><li>如果Length type字段的值为1，则Packet length字段的编码长度为2个字节，值的范围为192到8383字节。</li><li>如果Length type字段的值为2，则Packet length字段的编码长度为5个字节，值的范围为0到4294967295字节。</li></ul><p>因此，Packet length字段的编码长度可能为1、2或5个字节，具体取决于Length type字段的值。</p></blockquote><blockquote><p>我: 还是不对,你搞混淆了它的以前的pgp版本的在tag上的length type</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，我又犯了错误。您说得对，我混淆了旧版和新版OpenPGP规范中的内容。在最新的OpenPGP规范（RFC 4880bis）中，Packet length字段的编码长度有三种可能的长度，分别是1、2和5个字节，与我的前一条回答相同。Packet length字段的编码长度由Length type字段的值决定，Length type字段的值可以是0、1或2。</p><ul><li>如果Length type字段的值为0，则Packet length字段的编码长度为1个字节，值的范围为0到191字节。</li><li>如果Length type字段的值为1，则Packet length字段的编码长度为2个字节，值的范围为192到8383字节。</li><li>如果Length type字段的值为2，则Packet length字段的编码长度为5个字节，值的范围为0到 4294967295字节。</li></ul><p>再次感谢您指出我的错误，我会更加认真地检查我的回答。</p></blockquote><blockquote><p>我: 191的二进制是多少?</p></blockquote><blockquote><p>ChatGPT: 191的二进制表示是：10111111。</p></blockquote><blockquote><p>我: 192呢</p></blockquote><blockquote><p>ChatGPT: 192的二进制表示是：11000000。</p></blockquote><blockquote><p>我: 192用openpgp的package length怎么表示?</p></blockquote><blockquote><p>ChatGPT: 在OpenPGP数据包中，如果一个数据包的长度大于191个字节，且小于等于8383个字节，则它的<br>Package Length字段会使用2个字节进行编码。具体地，第一个字节的最高二位是“11”，表示<br>Package Length字段将使用2个字节编码；第一个字节的低六位和第二个字节共同组成了Package<br>Length字段的值，其值为长度减去192。因此，一个长度为192的数据包的Package Length字段的值为0，长度为193的数据包的Package Length字段的值为1，以此类推，直到长度为8383的数据包，其Package Length字段的值为8191（即8383-192）。</p></blockquote><blockquote><p>我: 所以,还需要Length type字段才能判断package length的字段长度么?</p></blockquote><blockquote><p>ChatGPT: 是的，为了解决数据包长度范围非常广的问题，OpenPGP协议引入了Length type字段来指定<br>Package Length字段的长度，以便更好地支持各种长度的数据包。具体来说，Length type字段指示<br>Package Length字段的编码长度（1个字节、2个字节或5个字节）。这样，接收方就可以根据<br>Length type字段的值确定Package Length字段的长度，然后解码出实际的数据包长度。</p><p>如果数据包的长度小于等于191个字节，则Length type字段的值为0，此时Package Length字段的长度为1个字节。如果数据包的长度大于191个字节，但小于等于8383个字节，则Length type字段的值为1，此时Package Length字段的长度为2个字节。如果数据包的长度大于8383个字节，则Length<br>type字段的值为2，此时Package Length字段的长度为5个字节。因此，只有在知道数据包的长度范围之后，才能正确地解码Package Length字段。</p></blockquote><blockquote><p>我: 关于package length字段需要额外的Length type字段来判定长度的说法是错误的,你仔细想想</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，我的回答存在误导。根据OpenPGP规范，确实存在Length type字段来指定Package<br>Length字段的编码长度。对于一个数据包来说，我们需要先读取它的Packet Tag字段，然后根据<br>Packet Tag的值以及Length type字段来确定Package Length字段的编码长度。只有在知道Package<br>Length字段的编码长度之后，才能正确地读取Package Length字段，并进一步处理数据包的内容。</p><p>因此，您所说的关于Package Length字段需要额外的Length type字段来判定长度的说法是正确的。非常感谢您的指正，我会更加注意我的回答。</p></blockquote><blockquote><p>我: 不对! 我说的是不需要额外的Length type字段! 你提到的Package Length字段在OpenPGP上并不存在</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，我再次混淆了OpenPGP规范中的字段。您是正确的，OpenPGP中的数据包长度由Packet<br>Tag字段和Packet Length字段组成，Packet Length字段的长度是由Packet Tag字段的最高两位决定的。Packet Tag字段的最高两位确定了Packet Length字段的编码长度，而Packet Tag字段的剩余位则用于确定数据包的类型。</p><p>因此，您所说的关于Packet Length字段不需要额外的Length type字段来判定长度的说法是正确的。再次感谢您的指正，我会更加仔细地检查我的回答。</p></blockquote><blockquote><p>我: 还是不对,你说的这个是Legacy packet format ,不是如今的OpenPGP包格式</p></blockquote><blockquote><p>ChatGPT:非常抱歉，我的回答仍然存在误导。您是正确的，我混淆了OpenPGP的Legacy packet format和现代的OpenPGP packet format。现代的OpenPGP packet format的Packet Length字段可以通过<br>Packet Tag的最高位来确定其长度编码类型，而不需要额外的Length type字段。这样，我们可以根据Packet Tag的最高位来读取Packet Length字段，并继续处理数据包的内容。</p><p>再次感谢您的指正，我会更加仔细地研究OpenPGP规范，并更加准确地回答问题。</p></blockquote><blockquote><p>我: 依然错误, 是直接通过 Packet Length的首字节来判断</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，我混淆了OpenPGP的不同版本。根据OpenPGP 3.7.1版本的规范，Packet Length字段的编码方式不同于Legacy packet format，也不同于OpenPGP的RFC 4880版本。在OpenPGP 3.7.1<br>中，Packet Length字段的第一个字节指定了数据包的长度，并且如果第一个字节的值小于192，则<br>Packet Length字段的长度为1，如果第一个字节的值大于或等于192且小于255，则Packet Length字段的长度为2，如果第一个字节的值等于255，则Packet Length字段的长度为5。</p><p>因此，您所说的直接通过Packet Length的首字节来判断其编码长度的说法是正确的。</p><p>再次感谢您的指正，我会更加仔细地查阅OpenPGP规范并更加准确地回答问题。</p></blockquote><blockquote><p>我: 稍微更正下, 是从OpenPGP的RFC 4880开始就是这样判断的了!</p></blockquote><blockquote><p>ChatGPT: 非常感谢您的指正和更正。我承认我的回答有误。</p><p>在OpenPGP的RFC 4880版本中，Packet Length<br>字段的编码方式就是通过第一个字节来判断其编码长度，如果第一个字节的值小于192，则Packet<br>Length字段的长度为1，如果第一个字节的值大于或等于192且小于255，则Packet Length字段的长度为2，如果第一个字节的值等于255，则Packet Length字段的长度为5。</p><p>再次感谢您的指正和更正。我会更加仔细地查阅OpenPGP规范并更加准确地回答问题。</p></blockquote><blockquote><p>我: 现在,你可以根据更正后的结果,来重新描述OpenPGP的包头</p></blockquote><blockquote><p>ChatGPT: 根据OpenPGP的RFC 4880版本规范，OpenPGP数据包由包头和包体组成，包头包含Packet Tag和<br>Packet Length两个字段。Packet Tag字段指定了数据包的类型，Packet Length字段指定了数据包的长度。</p><p>Packet Length字段的编码方式通过Packet Length字段的第一个字节来判断其编码长度。</p><ul><li>如果第一个字节的值小于192，则Packet Length字段的长度为1，并且Packet Length字段的值等于第一个字节的值。</li><li>如果第一个字节的值大于或等于192且小于255，则Packet Length字段的长度为2，Packet Length字段的值等于256×(第一个字节的值 - 192) + 第二个字节的值。</li><li>如果第一个字节的值等于255，则Packet Length字段的长度为5，Packet Length字段的值等于第二个字节到第五个字节所组成的四字节无符号整数。</li></ul><p>因此，OpenPGP的包头包含Packet Tag和Packet Length两个字段，Packet Length字段的编码方式通过Packet Length字段的第一个字节来判断其编码长度。</p></blockquote><blockquote><p>我: 关于 Packet Length 你还遗漏了 Partial Body Lengths 的情况</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，您是正确的。在OpenPGP的RFC 4880版本规范中，还存在一种Partial Body Lengths情况。当数据包的实际长度无法事先确定时，可以使用Partial Body Lengths来指示数据包长度为不确定的流。Partial Body Lengths由一个单独的标志位和一个可选的长度字段组成。如果标志位为1，则<br>Packet Length字段的值为0，数据包长度为不确定的流；如果标志位为0，则Packet Length字段的值由后面的长度字段指定。</p><p>因此，在OpenPGP的包头中，Packet Length字段的编码方式可能有四种可能：一个字节的Body<br>Length头可以编码多达191个字节的数据包；两个字节的Body Length头可以编码介于192个字节和<br>8383个字节之间的数据包；五个字节的Body Length头可以编码多达4294967295个字节的数据包；<br>Partial Body Lengths可以用于编码长度不确定的数据包。</p></blockquote><blockquote><p>我: 没有说清如何判断是Partial Body Lengths</p></blockquote><blockquote><p>ChatGPT: 在OpenPGP的规范中，Partial Body Lengths使用一个单独的标志位来指示。这个标志位称为Partial<br>Body Lengths Indeterminate bit，位于Packet Length字段的最高有效位（MSB）。当Partial Body<br>Lengths Indeterminate bit被设置为1时，Packet Length字段的值被指定为0，表示数据包长度是一个不确定的流。当Partial Body Lengths Indeterminate bit被设置为0时，Packet Length字段的值由后面的长度字段指定。因此，判断是否为Partial Body Lengths的方法是检查Packet Length字段的最高位是否为1。如果是，则表示数据包长度为不确定的流；如果不是，则后面的Packet Length字段的值由Packet Length Type决定。</p></blockquote><blockquote><p>我: 不对,实际规范如下: A Partial Body Length header is one octet long and encodes the length of<br>only part of the data packet. This length is a power of 2, from 1 to 1,073,741,824 (2 to the 30th<br>power). It is recognized by its one octet value that is greater than or equal to 224, and less than 255.</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，我的回答有误。您是正确的，Partial Body Lengths的情况可以使用单独的标志位来指示。但是，我的回答中提到的Partial Body Length Indeterminate bit是错误的。在OpenPGP规范中，Partial Body Lengths使用一个特殊的值（0xE0到0xFF之间的任意值）来表示，而不是设置的30次方）。</p><p>因此，要识别Partial Body Lengths，只需要检查Packet Tag的值是否大于等于224并且小于255即可。</p><p>非常抱歉之前造成的困惑，感谢您的纠正。</p></blockquote><blockquote><p>我: 用中文怎样称呼Partial Body Lengths</p></blockquote><blockquote><p>ChatGPT: Partial Body Lengths 可以翻译为“部分体长度”。</p></blockquote><blockquote><p>我: 不够通顺,不符合OpenPGP中的含义</p></blockquote><blockquote><p>ChatGPT: 非常抱歉，我的翻译有误。正确的翻译应该是“不完整数据长度”，它指的是OpenPGP数据包中数据长度不确定的情况。</p></blockquote><blockquote><p>我: 再思考一个更通俗的</p></blockquote><blockquote><p>ChatGPT: 不完整数据长度也可以被翻译为“流式数据长度”。因为在这种情况下，数据的长度不是固定的，而是像流一样，不断地流入和流出。</p></blockquote><blockquote><p>我: 正确翻译OpenPGP的Literal Data Packet ,要求雅,准,达</p></blockquote><blockquote><p>ChatGPT: Literal Data Packet可以翻译为“OpenPGP文字数据包”。其中，“Literal”表示明文或非压缩的数据，而“Data Packet”则指的是OpenPGP中的一种数据包类型。该翻译通顺、准确、简洁明了，同时保留了原始英文的一些关键词，易于理解。</p></blockquote><blockquote><p>我: 那么,图像和音频数据也是文字么?</p></blockquote><blockquote><p>ChatGPT: 不是，图像和音频数据通常不被认为是文字，因为它们不是由离散的字符或字形组成的，而是由连续的声音波形或像素值组成的。然而，在计算机中，这些数据也可以用字节序列的形式表示，就像文本数据一样。因此，可以使用OpenPGP的Literal Data Packet来加密、签名和传输图像、音频等二进制数据。但在这种情况下，&quot;literal&quot;更多地表示未经过编码的数据，而不是具有明确的文本含义。</p></blockquote><blockquote><p>我: 所以翻译OpenPGP的Literal Data Packet不够雅,准,达</p></blockquote><blockquote><p>ChatGPT: 确实，根据上述讨论，将OpenPGP的Literal Data Packet简单翻译成“文字数据包”并不准确和完整。更好的翻译可能是“明文数据包”或“字面数据包”，这可以更好地反映该数据包类型的含义和用途，而不仅仅局限于文本数据。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;wo-kan-chatgpt-ren-lei-zai-zuo-si-huan-shi-zai-chuang-zao-sheng-ming&quot; class=&quot;heading-control&quot;&gt;我看 ChatGPT：人类在作死还是在创造&amp;quot;生命&amp;quot;&lt;a class=&quot;heading-anchor&quot; href=&quot;#wo-kan-chatgpt-ren-lei-zai-zuo-si-huan-shi-zai-chuang-zao-sheng-ming&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;wo-de-gan-shou&quot; class=&quot;heading-control&quot;&gt;我的感受&lt;a class=&quot;heading-anchor&quot; href=&quot;#wo-de-gan-shou&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最近这几个月，我一直在断断续续的使用ChatGPT. 并对它有了一些感受,首先感觉就是笨,智力有限,就像一个8、9岁孩子的智商一样；但是另一方面，我发现ChatGPT的知识面非常广泛，它似乎可以对几乎所有的话题都能够做出头头是道的回答。当然ChatGPT同样也是经常犯错,而且错得是一塌糊涂，但是我却从中总感觉到它是在真的在思考.&lt;/p&gt;
&lt;p&gt;我不知道它的思考能力到底是从何而来，也很难想象一个“机器”可以像人一样去思考。但我知道ChatGPT是基于Transformer架构的语言模型。在产生回答时，它所依赖的是从大规模的文本语料库中学习得到的统计模式和规律，通过计算预测下一个词汇的概率来生成下一步的预测和生成的结果。&lt;/p&gt;
&lt;p&gt;ChatGPT并不是基于真正的自然语言理解和知识图谱技术开发的。在它的“脑子”里并没有可供查询的知识库和推理算法，全是通过模型参数进行预测和生成回答。谁也没想到，这样的方式居然能够推理、解决问题，甚至产生出类似于心智的能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://riceball.me/categories/AI/"/>
    
      <category term="GPT" scheme="https://riceball.me/categories/AI/GPT/"/>
    
    
      <category term="learning" scheme="https://riceball.me/tags/learning/"/>
    
      <category term="ai" scheme="https://riceball.me/tags/ai/"/>
    
      <category term="gpt" scheme="https://riceball.me/tags/gpt/"/>
    
      <category term="chatgpt" scheme="https://riceball.me/tags/chatgpt/"/>
    
      <category term="deep learning" scheme="https://riceball.me/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>智能家居硬件采购避坑指要(四) HA盒子</title>
    <link href="https://riceball.me/article/home-assistant-box/"/>
    <id>https://riceball.me/article/home-assistant-box/</id>
    <published>2022-05-07T00:38:18.000Z</published>
    <updated>2023-03-09T02:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-si-ha-he-zi" class="heading-control">智能家居硬件采购避坑指要(四) HA盒子<a class="heading-anchor" href="#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-si-ha-he-zi" aria-hidden="true"></a></h1><p>HA是跑在PC上还是盒子里,这是个问题!</p><ul><li>PC性能远远强于盒子: CPU主频高(至少都是2G以上)核心多(8-16Cores),内存足(16G-64G),硬盘大</li><li>PC的功耗也远高于盒子,盒子功耗低</li></ul><p>因此如果不在乎功耗和硬盘损耗,以及能够保持24小时开机(不能离线),无脑PC即可.</p><h2 id="pc-de-wen-ti" class="heading-control">PC的问题<a class="heading-anchor" href="#pc-de-wen-ti" aria-hidden="true"></a></h2><p>简单提下我用PC碰到的问题,主要是RAM的问题, 常规 RAM 不支持 ECC 校验, 如果关键地址出错,导致系统崩溃,而有些文件系统严重依赖RAM的稳定性,比如ZFS(可组ZFS软阵列),如果RAM出错就会导致文件系统数据错误.</p><p><img src="./nas8bay.jpg" alt="nas8bay"></p><p>而我,家里的NAS早就不是24小时开机了,而是按需开机. 我也不想家里PC24小时保持开机, 所以需要盒子作为智能中枢.</p><h2 id="ha-he-zi" class="heading-control">HA盒子<a class="heading-anchor" href="#ha-he-zi" aria-hidden="true"></a></h2><h3 id="ha-he-zi-yao-qiu" class="heading-control">HA盒子要求<a class="heading-anchor" href="#ha-he-zi-yao-qiu" aria-hidden="true"></a></h3><ul><li>HA要想跑在docker中，那么CPU核心数量不能少，除非是只跑HA Core,那么单核也可，否则建议4核，主频不要低于1GHz.</li><li>如果HA要接入摄像头,最好至少要支持H.264硬解.</li><li>要储存更多的传感器历史数据,那么至少要支持USB3.0的接口或TF卡插槽方便扩展存储,</li><li>选择至少3A以上的靠谱电源以便带动移动硬盘</li><li>如果更进一步想支持离线AI人脸识别,AI语音识别和AI TTS,最好带够NPU(神经网络处理器)芯片</li></ul><h3 id="ha-he-zi-xuan-xing-yu-bi-jiao" class="heading-control">HA盒子选型与比较<a class="heading-anchor" href="#ha-he-zi-xuan-xing-yu-bi-jiao" aria-hidden="true"></a></h3><p>PC没啥说的,盒子的明堂不少.我买过的盒子:作为机顶盒，路由器，硬盘盒…:</p><ul><li>CubieTruck Box:  Allwinner A20(双核) 1Ghz, 2GiB DDR3 480MHz, 8G NAND(支持内置2.5硬盘)<ul><li><img src="/article/home-assistant-wifi/CubieTruck.jpg" alt="CubieTruck"></li></ul></li><li>NanoPC T4 Box: RK3399, 内存 双通道4GB LPDDR3-1866, 16GB eMMC 5.1 Flash, Bluetooth 4.1 双频Wi-Fi蓝牙模块, 2x2 MIMO, 2xUSB3.0(1xTypeC),2xUsb2.0, 1xPcieX4(M.2 M-Key), 40PinGPIO, microSD(TF卡)插槽<ul><li>RK3399:<ul><li>CPU: 双Cortex-A72大核(up to 2.0GHz)+四Cortex-A53小核结构(up to 1.5GHz),</li><li>GPU: Mali-T864 GPU(4核 900MHz), 支持OpenGL ES1.1/2.0/3.0/3.1, OpenCL, DX11, 支持AFBC（帧缓冲压缩）</li><li>VPU: 支持4K VP9 and 4K 10bits H265/H264 视频解码，高达60fps, 双VOP显示等视频编解码功能</li></ul></li><li><img src="/article/home-assistant-wifi/NanoPC-T4-Box.jpg" alt="NanoPC-T4-Box"></li></ul></li><li>NanoPi R4S: RK3399, 4GB LPDDR4, 2xUSB3<ul><li><img src="/article/home-assistant-wifi/Nanopi-R4S.jpg" alt="Nanopi-R4S"></li></ul></li><li>HK1 Box: CPU Amlogic S905X3(4核A55 up tp 1.91 GHz), GPU G31 MP2（650 MHz，6内核）, 内存2G/4GB（DDR4，3200 MHz）, 闪存16G/32G eMMC, Wifi/Bluetooth 4.0, 1xUsb3.0, 1xUsb2.0, microSD(TF卡)插槽, SPDIF光纤音频接口, H.265硬解(8K支持)<ul><li><img src="/article/home-assistant-wifi/HK1-Box.jpg" alt="HK1-Box"></li></ul></li><li>Rock5 Model B RK3588 16GB RAM 最新到的板子<ul><li>Quad-core ARM Cortex-A76 MPCore processor and quad-core ARM Cortex-A55 MPCore processor</li><li>Embedded ARM Mali-G610 MP4 3D GPU</li><li>The build-in NPU supports INT4/INT8/INT16/FP16 hybrid operation and computing power is up to 6TOPs</li><li><img src="/article/home-assistant-wifi/rock5b.jpg" alt="Rock5B"></li></ul></li></ul><p>其中性能以及功能最好的盒子是<code>NanoPC T4</code>,我当年买成￥900（全套：主板+散热片+RTC+金属外壳+红外遥控），没想到现在单板都上千了。但是价格太贵了。性价比不划算，而且这个板子我已经再用了。于是参考官网推荐的 <a href="https://www.home-assistant.io/blue/" target="_blank" rel="noopener">HomeAssistant Blue</a> , 我选择了HK1 Box。</p><p><code>HK1 Box</code> 与 <code>HomeAssistant Blue</code> 的硬件配置相当(CPU和eMMC稍逊)，<code>HomeAssistant Blue</code>的CPU是S922X(4核A73@2.4GHz+2核A53@1.9Hz), 我在某宝大概查了下 <code>HomeAssistant Blue(Odroid N2+)</code>:32G eMMC闪存/4G内存的<code>Odroid N2+</code>单板+外壳价格就近1200￥。而<code>HK1 Box</code>原装的价格(4G内存/32G闪存)大约230￥左右。这个价位几乎是<code>HomeAssistant Blue</code>的五分之一了。功耗也低: 3-4.45W(不带移动硬盘).</p><h3 id="hk1-box-he-zi-de-zhu-yi-shi-xiang" class="heading-control"><code>HK1 Box</code> 盒子的注意事项<a class="heading-anchor" href="#hk1-box-he-zi-de-zhu-yi-shi-xiang" aria-hidden="true"></a></h3><ol><li>质量参差不齐, 良品率不高(我买两个,退了三个),刷机后,多测试烤机,好处是当机顶盒,游戏机(EmuElec),小服务器都成,而且支持多重引导.</li><li>原装电源质量很差，最好换个质量好的: 电压5V，电流不小于3A，接口5.5*2.5兼容2.1，实在找不到也可以用国产电视盒的5V2A电源，或是5V2A手机充电头+USB转DC线，质量必须是过得去的才可以用。用原装电源的有人已烧了USB接口，有人烧了USB网卡，有人烧了移动硬盘，即使没烧的，也存在各种不稳定的情况。</li><li>原装散热是个问题,不改散热,上80度很轻松.改装大散热片后温度能压到60度,改了大散热片的<code>HK1 Box</code>的价位大约在260￥左右(配3A电源),加了风扇能压到40度(冬天30度),加了风扇的<code>HK1 Box</code>价位大约在290￥(配3A电源),不过改装风扇后的如果对方不留意静电,就要烧EMMC,造成无法刷机.</li><li>最近一次买的HK1 Box的新Android版本(20220222_0120)刷机麻烦,无法USB引导刷机,必须先线刷(插USB2.0口)回退到老版本,才能USB引导刷机.<ul><li>查看版本号:按遥控器help键,拉到底,点<code>更新</code></li></ul></li></ol><h3 id="ha-he-zi-wei-lai" class="heading-control">HA盒子未来<a class="heading-anchor" href="#ha-he-zi-wei-lai" aria-hidden="true"></a></h3><p>而官网正在众筹的<a href="https://www.home-assistant.io/blog/2021/09/13/home-assistant-yellow/" target="_blank" rel="noopener">HomeAssistant Yellow</a>我并不喜欢，它作的是<code>Raspberry Pi CM4</code>的扩展板：内置Zigbee((Silicon Labs MGM210P)+M.2扩展插槽+千兆网口(可选的PoE支持)+Audio DAC，但是这个扩展板只能用在<code>Raspberry Pi Compute Module 4</code>上（要自备），而<code>RaspberryPi CM4</code>(4核A72@1.5Ghz)存在众所周知的诸多小问题,加上如今价格也翻倍,也就没啥性价比了，就生态圈还可以。</p><p>说实在的, 如果addon装得多, 可能4G内存都不够. DIY HA盒子都是追求性价比的. 同时这样也节能省电.</p><p>目前我盒子装的Addons有:</p><ul><li>TimescaleDB(PostgreSQL:TimeScaleDB+PostGis)</li><li>Zigbee2MQTT</li><li>Mosquitto broker</li><li>VLC</li><li>Logitech Media Server</li><li>room-assistant</li><li>Samba share</li><li><a href="https://bbs.hassbian.com/thread-16601-1-1.html" target="_blank" rel="noopener">我自己写的中英文离线语音合成输出(TTS) Addon</a></li><li>File editor(一般关闭)</li><li>Check Home Assistant configuration(一般关闭)</li><li>pgAdmin4(一般关闭)</li><li>Node-RED(一般关闭,测试用)</li><li>ESPHome(一般关闭)</li></ul><p>我理想的HA盒子是有 8G/16G 内存的主板,带NPU(神经网络处理器)芯片,这样可以直接在智能中枢这块实现离线的AI语音识别/TTS/视频识别: <code>Rock5 Model B RK3588</code>.</p><h3 id="ha-shi-yong-zhu-yi-shi-xiang" class="heading-control">HA 使用注意事项<a class="heading-anchor" href="#ha-shi-yong-zhu-yi-shi-xiang" aria-hidden="true"></a></h3><p>这应该归到软件类的,不过这里也简单提一下吧.</p><ol><li>不要直接拔电源，尽量按常规流程关机: 配置 -&gt; 加载项、备份与Supervisor -&gt; 系统 -&gt; 关闭主机<ul><li>否则可能会造成系统损坏，导致重装系统。如果使用<code>overlayfs</code>文件系统，那么系统损坏的情况会得到一定的改善</li></ul></li><li>当传感器较多的时候，数据库数据膨胀很快，需要扩展存储和优化数据存储方式<ol><li>扩展存储：插入256G/512G TF卡或移动硬盘</li><li>如果盒子性能还不错，那么直接上<code>TimescaleDB(PostgreSQL)</code>，注意在配置里控制下CPU和内存的使用，比如HK1盒子。</li><li>如果盒子性能一般或者想节省磁盘空间，那么就上<code>MariaDB</code>, 或者 <code>SQLite Mem</code> + <code>InfluxDB</code> 更省空间，不过这时，历史数据就只能在<code>InfluxDB</code>中查看了。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-si-ha-he-zi&quot; class=&quot;heading-control&quot;&gt;智能家居硬件采购避坑指要(四) HA盒子&lt;a class=&quot;heading-anchor&quot; href=&quot;#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-si-ha-he-zi&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;HA是跑在PC上还是盒子里,这是个问题!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PC性能远远强于盒子: CPU主频高(至少都是2G以上)核心多(8-16Cores),内存足(16G-64G),硬盘大&lt;/li&gt;
&lt;li&gt;PC的功耗也远高于盒子,盒子功耗低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此如果不在乎功耗和硬盘损耗,以及能够保持24小时开机(不能离线),无脑PC即可.&lt;/p&gt;
&lt;h2 id=&quot;pc-de-wen-ti&quot; class=&quot;heading-control&quot;&gt;PC的问题&lt;a class=&quot;heading-anchor&quot; href=&quot;#pc-de-wen-ti&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Open Source" scheme="https://riceball.me/categories/Open-Source/"/>
    
      <category term="Hardware" scheme="https://riceball.me/categories/Open-Source/Hardware/"/>
    
      <category term="SmartHome" scheme="https://riceball.me/categories/Open-Source/Hardware/SmartHome/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="iot" scheme="https://riceball.me/tags/iot/"/>
    
      <category term="open source" scheme="https://riceball.me/tags/open-source/"/>
    
      <category term="hardware" scheme="https://riceball.me/tags/hardware/"/>
    
      <category term="smarthome" scheme="https://riceball.me/tags/smarthome/"/>
    
      <category term="homeassistant" scheme="https://riceball.me/tags/homeassistant/"/>
    
      <category term="ha" scheme="https://riceball.me/tags/ha/"/>
    
      <category term="box" scheme="https://riceball.me/tags/box/"/>
    
  </entry>
  
  <entry>
    <title>智能家居硬件采购避坑指要(三) Bluetooth设备</title>
    <link href="https://riceball.me/article/home-assistant-bluetooth/"/>
    <id>https://riceball.me/article/home-assistant-bluetooth/</id>
    <published>2022-05-06T00:38:18.000Z</published>
    <updated>2023-03-09T02:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-san-lan-ya-she-bei" class="heading-control">智能家居硬件采购避坑指要(三) 蓝牙设备<a class="heading-anchor" href="#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-san-lan-ya-she-bei" aria-hidden="true"></a></h1><h2 id="lan-ya-te-xing" class="heading-control">蓝牙特性<a class="heading-anchor" href="#lan-ya-te-xing" aria-hidden="true"></a></h2><ol><li>短距离通信：蓝牙技术的通信范围通常为10米以内</li><li>蓝牙信号穿墙能力有限,除非你购买BLE蓝牙网关中继设备,而且更容易受到干扰,尤其是不带自动跳频的蓝牙.</li><li>能耗相对较低：因为低功耗蓝牙设备在省电上还是比不过Zigbee设备,BLE蓝牙5.0在省电上与zigbee很接近了.<ul><li>因此: 为了省电,米家的温度传感器(LYWSD03MMC)是大约10分钟发送一次数据,如果不刷第三方固件,想与空调联动就不要想了.</li></ul></li><li>简单易用：智能家居蓝牙设备使用普及度高的蓝牙协议，用户不需要额外的网关或路由器即可连接和控制设备</li><li>目前蓝牙协议大多数是私有协议，互通性较差,HA无法直接控制,只有少量的特定厂家的低功耗蓝牙传感设备才能通过第三方<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a> 直接接入HA,支持的设备详见下方的支持列表.</li><li>价格便宜:由于蓝牙技术在手机和其他消费电子设备上得到广泛应用，智能家居蓝牙设备的成本相对较低。</li></ol><h2 id="di-san-fang-passive-ble-monitor-ji-cheng" class="heading-control">第三方<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a><a class="heading-anchor" href="#di-san-fang-passive-ble-monitor-ji-cheng" aria-hidden="true"></a></h2><p><strong>注意</strong>: 最新HA版本(2022.8以后)的官方蓝牙集成开始直接支持Passive BLE 设备,目前还在移植更多的蓝牙设备.官方蓝牙集成不能与BLE Monitor集成同时工作!请做好选择,官方蓝牙集成同样支持蓝牙网关.</p><p>采用第三方<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>用于跳过所谓的蓝牙网关直接将蓝牙传感器设备接入HA,<strong>注意</strong>,目前<strong>只支持</strong>获取蓝牙传感器数据,<strong>不支持</strong>发送控制指令的蓝牙设备(比如:开关)!</p><blockquote><p>该集成使用的前提是:需要至少支持BLE蓝牙4.0(蓝牙是向下兼容的,所以BLE蓝牙5也可)的适配器,一般的HA盒子都有,如果是用PC就看带WIFI不,一般WIFI都带蓝牙,没有就买一个支持BLE蓝牙的USB WIFI适配器. 如果你使用<code>开源ESPHome通用蓝牙网关</code>接入,那么HA上可以不用配置蓝牙适配器.</p></blockquote><p>BLE 监视器(<code>Passive BLE Monitor</code>)支持来自小米、青萍、Govee、Kegtron、Thermoplus、Brifit、Ruuvitag、iNode 等制造商的蓝牙设备,比内置蓝牙集成支持的设备多得多。详见第三方<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>支持的设备列表: <a href="https://custom-components.github.io/ble_monitor/by_brand" target="_blank" rel="noopener">https://custom-components.github.io/ble_monitor/by_brand</a></p><h3 id="an-zhuang-yu-shi-yong" class="heading-control">安装与使用<a class="heading-anchor" href="#an-zhuang-yu-shi-yong" aria-hidden="true"></a></h3><p>安装很简单,在 <code>HACS</code> 第三方集成商场中搜索<code>Passive BLE Monitor</code>并安装即可.</p><p>这里以<code>小米蓝牙温湿度计2</code>为例讲解使用方法. <img src="./mi_temp2.jpg" alt="XiaoMi temp2"></p><p><strong>注意</strong>: 如果你拿到手的米家蓝牙传感器默认没有BLE Advertisements 广播,那么你必须先接入米家App才能打开广播.如果你的传感器刷了第三方ATC固件,那么就不需要先接入米家.</p><p>然后在<code>设备和集成</code>配置中添加<code>Passive BLE Monitor</code>集成即可:</p><p><img src="./ble_monitor_options.png" alt="ble_monitor_options"></p><ol><li>勾选要使用的<code>蓝牙接口/适配器 的 MAC 地址</code>,如果没有就勾选<code>Don't use Bluetooth adapter</code>让<code>开源ESPHome通用蓝牙网关</code>传入数据.</li><li>勾选<code>自动发现设备及传感器</code>后会自动添加发现的蓝牙传感器设备(前提是没加密)</li><li>勾选<code>重启后恢复状态</code>(可选): 是否重启后恢复设备状态,如果没有勾选,那么重启后在没有收到广播前,设备状态为 <code>Unavailable</code></li><li>对于加密数据传输的,还是必须点最下面的<code>设备</code>下拉列表框,选择<code>Add devices...</code></li><li>点击<code>提交</code>按钮.</li><li>如果选择了添加设备,这时候会弹出<code>配置设备</code>对话框<ul><li>输入蓝牙设备的MAC地址,如果是Beacon输入Beacon的UUID</li><li>输入加密密钥,如果有的话</li><li>最后点击<code>提交</code>按钮</li></ul></li></ol><p><img src="./ble_monitor_options_device.png" alt="ble_monitor_options_device"></p><p>等待几分钟,如果一切顺利,就可以看到该集成下出现的新设备.</p><h2 id="kai-yuan-esphome-tong-yong-lan-ya-wang-guan" class="heading-control">开源ESPHome通用蓝牙网关<a class="heading-anchor" href="#kai-yuan-esphome-tong-yong-lan-ya-wang-guan" aria-hidden="true"></a></h2><p>因为蓝牙穿墙能力弱,为了解决蓝牙信号穿墙问题,就有了所谓的<code>开源ESPHome通用蓝牙网关</code>: 蓝牙信号过不来的就走<code>开源ESPHome通用蓝牙网关</code>,通过wifi信号再到HA上的<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>. 另外<code>开源ESPHome通用蓝牙网关</code>还可以接入只支持<code>Active BLE connection</code>的蓝牙设备.</p><ol><li>蓝牙信号过不来的就走开源ESPHome通用蓝牙网关,通过wifi信号再到HA上的 <a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>.</li><li>接入只支持<strong>Active BLE connection</strong>的蓝牙设备</li></ol><p>硬件很简单,你只需要自备ESP32的主板一枚,建议最好选4M Flash的, 虽然2M的也能刷,但是稍微麻烦些. 我选的是<code>ESP-C3-32S(4M)</code>的开发板.</p><blockquote><p><code>ESP32-C3</code>是Espressif新出的RISC-V 32位单核处理器(160MHz)支持蓝牙5.0(BLE支持),以前的ESP32是基于蓝牙4.2.</p></blockquote><p>ESP32-C3板子目前最便宜的是LuatOS(合宙)的<code>ESP32C3-CORE开发板（简版）</code>,￥9.9.</p><p>然后准备好ESPHome开发环境,请升级到ESPHome的最新版(至少2022.1版本以后),请不要在arm环境下开发,因为<code>Espressif</code>目前还不支持<code>ESP-C3</code>在arm下的编译.</p><p>在Linux环境下安装使用很简单:</p><pre><code class="bash">sudo apt -y install python3 python3-pip python3-pip-whlsudo -H pip3 install --upgrade pippip3 install --user esphome<span class="hljs-comment"># To set this permanently, you can run echo 'export PATH=$PATH:$HOME/.local/bin' &gt;&gt; $HOME/.bashrc</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/.<span class="hljs-built_in">local</span>/bin<span class="hljs-comment"># You may need to logout and back in for the new group to take effect.</span>sudo usermod -a -G dialout <span class="hljs-variable">$USER</span></code></pre><p>好了,刷机的YAML<code>bluetooth-gateway.yaml</code>配置如下(如果板子不是<code>ESP32-C3</code>请自行调整board参数),记得在相同目录下的<code>secrets.yaml</code>文件中填好<code>!secret</code>中的参数:</p><pre><code class="yml"><span class="hljs-attr">substitutions:</span>  <span class="hljs-comment"># Name the device and it's entities</span>  <span class="hljs-attr">device:</span> <span class="hljs-string">ble_gateway</span>  <span class="hljs-attr">device_name:</span> <span class="hljs-string">blegateway1</span><span class="hljs-attr">esphome:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">$device_name</span>  <span class="hljs-attr">comment:</span> <span class="hljs-string">$device</span>  <span class="hljs-attr">platformio_options:</span>    <span class="hljs-attr">board_build.flash_mode:</span> <span class="hljs-string">dio</span>    <span class="hljs-comment"># 还可以通过 tasmota 使用 Arduino:</span>    <span class="hljs-attr">board_build.mcu:</span> <span class="hljs-string">esp32c3</span>    <span class="hljs-attr">platform_packages:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">platformio/framework-arduinoespressif32</span> <span class="hljs-string">@</span> <span class="hljs-string">https://github.com/espressif/arduino-esp32.git#2.0.2</span><span class="hljs-attr">esp32:</span>  <span class="hljs-attr">board:</span> <span class="hljs-string">esp32-c3-devkitm-1</span>  <span class="hljs-attr">variant:</span> <span class="hljs-string">esp32c3</span>  <span class="hljs-attr">framework:</span>    <span class="hljs-comment"># 使用 esp-idf</span>    <span class="hljs-comment"># type: esp-idf</span>    <span class="hljs-comment"># sdkconfig_options:</span>    <span class="hljs-comment">#   CONFIG_BT_BLE_50_FEATURES_SUPPORTED: y</span>    <span class="hljs-comment">#   CONFIG_BT_BLE_42_FEATURES_SUPPORTED: y</span>    <span class="hljs-comment">#   CONFIG_ESP_TASK_WDT_TIMEOUT_S: "10" # Defaults to 5</span>    <span class="hljs-comment"># 使用 tasmota:</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">arduino</span>    <span class="hljs-attr">version:</span> <span class="hljs-number">2.0</span><span class="hljs-number">.3</span>    <span class="hljs-attr">platform_version:</span> <span class="hljs-string">https://github.com/tasmota/platform-espressif32/releases/download/v.2.0.3/platform-espressif32-v.2.0.3.zip</span>    <span class="hljs-comment"># version: 2.0.2</span>    <span class="hljs-comment"># platform_version: https://github.com/tasmota/platform-espressif32/releases/download/v2.0.2.3/platform-espressif32-2.0.2.3.zip</span><span class="hljs-attr">external_components:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">source:</span> <span class="hljs-string">github://myhomeiot/esphome-components</span><span class="hljs-comment"># WIFI 每个信道停留的时间，默认主动扫描为 120 ms，被动扫描为 360 ms。</span><span class="hljs-attr">esp32_ble_tracker:</span>  <span class="hljs-attr">scan_parameters:</span>    <span class="hljs-attr">interval:</span> <span class="hljs-string">320ms</span> <span class="hljs-comment"># if Option “Software controls WiFi/Bluetooth coexistence” is enabled, the BLE scan interval shall not exceed 0x100 slots (about 160 ms).</span>    <span class="hljs-attr">window:</span> <span class="hljs-string">100ms</span>    <span class="hljs-attr">duration:</span> <span class="hljs-string">1min</span> <span class="hljs-comment"># Defaults to 5min</span>    <span class="hljs-comment"># active: true # Defaults to true</span><span class="hljs-comment"># Enable logging</span><span class="hljs-attr">logger:</span>  <span class="hljs-attr">level:</span> <span class="hljs-string">DEBUG</span> <span class="hljs-comment"># defaults to DEBUG, NONE ERROR WARN INFO DEBUG VERBOSE VERY_VERBOSE</span><span class="hljs-comment"># Enable Home Assistant API</span><span class="hljs-attr">api:</span>  <span class="hljs-attr">reboot_timeout:</span> <span class="hljs-string">1h</span><span class="hljs-attr">ota:</span>  <span class="hljs-attr">password:</span> <span class="hljs-type">!secret</span> <span class="hljs-string">ota_password</span><span class="hljs-attr">wifi:</span>  <span class="hljs-attr">ssid:</span> <span class="hljs-type">!secret</span> <span class="hljs-string">wifi_ssid</span>  <span class="hljs-attr">password:</span> <span class="hljs-type">!secret</span> <span class="hljs-string">wifi_password</span>  <span class="hljs-comment"># Enable fallback hotspot in case wifi connection fails</span>  <span class="hljs-attr">ap:</span>    <span class="hljs-attr">ssid:</span> <span class="hljs-string">"$device_name Fallback Hotspot"</span>    <span class="hljs-attr">password:</span> <span class="hljs-type">!secret</span> <span class="hljs-string">ap_password</span><span class="hljs-attr">ble_gateway:</span>  <span class="hljs-attr">id:</span> <span class="hljs-string">$device_name</span>  <span class="hljs-comment"># devices:</span>  <span class="hljs-comment">#   - mac_address: 01:23:45:67:89:AB</span>  <span class="hljs-comment">#   - mac_address: !secret lywsd03mmc_mac</span>  <span class="hljs-attr">on_ble_advertise:</span>    <span class="hljs-attr">then:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">homeassistant.service:</span>          <span class="hljs-attr">service:</span> <span class="hljs-string">ble_monitor.parse_data</span>          <span class="hljs-attr">data:</span>            <span class="hljs-attr">packet:</span> <span class="hljs-type">!lambda</span> <span class="hljs-string">return</span> <span class="hljs-string">packet;</span>            <span class="hljs-attr">gateway_id:</span> <span class="hljs-string">$device_name</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">homeassistant.event:</span>          <span class="hljs-attr">event:</span> <span class="hljs-string">esphome.on_ble_advertise</span>          <span class="hljs-attr">data:</span>            <span class="hljs-attr">packet:</span> <span class="hljs-type">!lambda</span> <span class="hljs-string">return</span> <span class="hljs-string">packet;</span><span class="hljs-attr">binary_sensor:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">homeassistant</span>    <span class="hljs-attr">id:</span> <span class="hljs-string">ble_gateway_discovery</span>    <span class="hljs-attr">entity_id:</span> <span class="hljs-string">binary_sensor.ble_gateway</span>    <span class="hljs-attr">attribute:</span> <span class="hljs-string">discovery</span>    <span class="hljs-attr">on_state:</span>      <span class="hljs-attr">then:</span>        <span class="hljs-attr">lambda:</span> <span class="hljs-string">id($device_name).set_discovery(x);</span><span class="hljs-attr">text_sensor:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">homeassistant</span>    <span class="hljs-attr">id:</span> <span class="hljs-string">ble_gateway_devices</span>    <span class="hljs-attr">entity_id:</span> <span class="hljs-string">binary_sensor.ble_gateway</span>    <span class="hljs-attr">attribute:</span> <span class="hljs-string">devices</span>    <span class="hljs-attr">on_value:</span>      <span class="hljs-attr">then:</span>        <span class="hljs-attr">lambda:</span> <span class="hljs-string">id($device_name).set_devices(x);</span>  <span class="hljs-comment"># IP address of device. Not really needed for HA (as HA already knows it), but for showing on the display during startup. The startup screen will leave on if no instance connects to the API.</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">wifi_info</span>    <span class="hljs-attr">ip_address:</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">$device_name</span> <span class="hljs-string">IP</span> <span class="hljs-string">address</span>      <span class="hljs-attr">id:</span> <span class="hljs-string">ip_address</span>  <span class="hljs-comment"># ESPHome version used to compile the app</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">version</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">$device_name</span> <span class="hljs-string">ESPHome</span> <span class="hljs-string">Version</span><span class="hljs-attr">sensor:</span>  <span class="hljs-comment"># WiFi signals strength sensor</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">wifi_signal</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">$device_name</span> <span class="hljs-string">WiFi</span> <span class="hljs-string">Signal</span> <span class="hljs-string">Sensor</span>    <span class="hljs-attr">update_interval:</span> <span class="hljs-string">60s</span></code></pre><pre><code class="yml"><span class="hljs-comment"># secrets.yaml 例子</span><span class="hljs-attr">ota_password:</span> <span class="hljs-string">your</span> <span class="hljs-string">ota</span> <span class="hljs-string">password</span><span class="hljs-attr">wifi_ssid:</span> <span class="hljs-string">your</span> <span class="hljs-string">wifi</span> <span class="hljs-string">ssid</span><span class="hljs-attr">wifi_password:</span> <span class="hljs-string">your</span> <span class="hljs-string">password</span><span class="hljs-attr">ap_password:</span> <span class="hljs-string">your</span> <span class="hljs-string">password</span></code></pre><p>注意： 如果使用LuatOS(合宙)的<code>ESP32C3-CORE开发板（简版）</code>的<code>arduino框架</code>要么禁用log组件,要么改用<code>esp-idf框架</code>并设置log组件的参数为:<code>hardware_uart: USB_SERIAL_JTAG</code>.</p><p>USB插上ESP32开发板,看清楚串口号(<code>ls /dev/tty*</code>),一般是<code>/dev/ttyUSB0</code>,然后执行如下语句编译烧录固件:</p><pre><code class="bash"><span class="hljs-comment"># choose the port after compiling</span>esphome run bluetooth-gateway.yaml</code></pre><p>至此,通用蓝牙网关的硬件烧录部分完成.</p><p>接着,还要在HA上配置与<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>的搭配部分.</p><p>注意:</p><ol><li><a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a> 版本要求 至少是 8.x</li><li><code>input_boolean.settings_ble_gateway</code> 是否启用蓝牙网关</li><li><code>input_boolean.settings_ble_gateway_discovery</code> 是否启用设备自动发现</li></ol><p>修改HA <code>configuration.yaml</code>文件:</p><pre><code class="yml"><span class="hljs-attr">input_boolean:</span>  <span class="hljs-attr">ha_started:</span>    <span class="hljs-attr">initial:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">settings_ble_gateway:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">BLE</span> <span class="hljs-string">Gateway</span>    <span class="hljs-attr">icon:</span> <span class="hljs-string">mdi:bluetooth</span>  <span class="hljs-attr">settings_ble_gateway_discovery:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">BLE</span> <span class="hljs-string">Gateway</span> <span class="hljs-string">Discovery</span>    <span class="hljs-attr">icon:</span> <span class="hljs-string">mdi:bluetooth-connect</span><span class="hljs-attr">input_text:</span>  <span class="hljs-attr">settings_ble_gateway_add_device:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">BLE</span> <span class="hljs-string">Gateway</span> <span class="hljs-string">Add</span> <span class="hljs-string">Device</span>    <span class="hljs-attr">icon:</span> <span class="hljs-string">mdi:bluetooth-connect</span>    <span class="hljs-attr">initial:</span> <span class="hljs-string">''</span><span class="hljs-attr">template:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">binary_sensor:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">BLE</span> <span class="hljs-string">Gateway</span> <span class="hljs-string">Add</span> <span class="hljs-string">Device</span>        <span class="hljs-attr">state:</span> <span class="hljs-string">"{{ (state_attr('binary_sensor.ble_gateway_add_device', 'mac_address')) }}"</span>        <span class="hljs-attr">availability:</span> <span class="hljs-string">"{{ is_state('input_boolean.ha_started', 'on') }}"</span>        <span class="hljs-attr">attributes:</span>          <span class="hljs-attr">mac_address:</span> <span class="hljs-string">"{{ states('input_text.settings_ble_gateway_add_device') | replace(':', '') | trim }}"</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">binary_sensor:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">BLE</span> <span class="hljs-string">Gateway</span>        <span class="hljs-attr">icon:</span> <span class="hljs-string">mdi:bluetooth</span>        <span class="hljs-attr">state:</span> <span class="hljs-string">"{{ is_state('input_boolean.settings_ble_gateway', 'on') }}"</span>        <span class="hljs-attr">availability:</span> <span class="hljs-string">"{{ is_state('input_boolean.ha_started', 'on') }}"</span>        <span class="hljs-attr">attributes:</span>          <span class="hljs-attr">discovery:</span> <span class="hljs-string">"{{ is_state('input_boolean.settings_ble_gateway_discovery', 'on') }}"</span>          <span class="hljs-attr">devices:</span> <span class="hljs-string">"{{ states | selectattr('entity_id', 'search', '^(device_tracker||(binary_)?sensor).ble_') | selectattr('attributes.mac_address', 'defined') | map(attribute='attributes.mac_address') | unique | sort | join('') | replace(':', '') if is_state('binary_sensor.ble_gateway', 'on') }}"</span></code></pre><p>然后修改<code>automations.yaml</code>文件:</p><pre><code class="yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">alias:</span> <span class="hljs-string">HA</span> <span class="hljs-string">Start</span> <span class="hljs-string">automation</span>  <span class="hljs-attr">initial_state:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">trigger:</span>    <span class="hljs-attr">platform:</span> <span class="hljs-string">homeassistant</span>    <span class="hljs-attr">event:</span> <span class="hljs-string">start</span>  <span class="hljs-attr">action:</span>    <span class="hljs-attr">service:</span> <span class="hljs-string">input_boolean.turn_on</span>    <span class="hljs-attr">entity_id:</span> <span class="hljs-string">input_boolean.ha_started</span>  <span class="hljs-attr">id:</span> <span class="hljs-string">ha_start</span></code></pre><p>重启HA即可. 对了记得把刚刚新鲜出炉的蓝牙网关加入进来.</p><p>然后该蓝牙网关就会自动转发已发现的并且在<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>中设备.</p><p>如果要添加新的蓝牙设备请在<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>上添加.<br>如果想只针对个别设备在指定的蓝牙网关上转发,那么请使用<code>input_text.settings_ble_gateway_add_device</code>添加该设备的MAC地址.</p><p><strong>注意</strong>: <a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>上的<code>自动发现设备及传感器</code>不能在蓝牙网关上使用,只限本地HA. 换句话说,如果HA本机没有蓝牙适配器,只用蓝牙网关,那么必须手动在<a href="https://github.com/custom-components/ble_monitor" target="_blank" rel="noopener">Passive BLE Monitor 集成</a>中添加设备.</p><p>蓝牙网关接收到已注册设备的广播后会同时触发事件<code>esphome.on_ble_advertise</code>发送原始数据.</p><p>最后,记得设置<code>input_boolean.settings_ble_gateway</code>为&quot;on&quot;,启用蓝牙网关功能.<br>设置<code>input_boolean.settings_ble_gateway_discovery</code>为&quot;on&quot;,启用自动发现功能.</p><p>已知问题:</p><ul><li>ESP32可能会遗漏广播消息,这是由于ESP32的蓝牙和WIFI共用通道造成,目前无解,除非不用WIFI,才能完全不遗漏.<br>调教<code>scan_parameters</code>参数会有好转,但是依然不能保证. 可以参阅: <a href="https://bbs.hassbian.com/thread-16350-1-1.html" target="_blank" rel="noopener">【难题求解】ESPHome+ESP32打造通用蓝牙网关漏收广播信息</a></li></ul><p><strong>版本更新</strong></p><ul><li>2022-5-09: [Bug] esp-idf 下无法更改 <code>scan_parameters</code>, 使用 Arduino framework now.</li><li>2022-5-21: [feat] 新增 启用自动发现开关</li></ul><h2 id="wo-mai-guo-de-she-bei" class="heading-control">我买过的设备<a class="heading-anchor" href="#wo-mai-guo-de-she-bei" aria-hidden="true"></a></h2><ul><li>小米蓝牙温湿度计2 价格便宜(Zigbee的一半不到)还带屏幕, 但是原始固件10分钟才报告1次温湿度,耗电高, 因此需要刷第三方开源固件<ul><li><img src="./mi_temp2.jpg" alt="XiaoMi temp2"></li><li>刷入第三方开源固件后<ul><li>更省电</li><li>可调节报告频率,默认是2.5秒报告1次温湿度,这个频率联动完全足够,报告频率越低越省电.</li><li>可以读取设备上记录的温湿度数据(循环记录19632个测量结果),记录的时间间隔也可以配置</li><li>可以校准温湿度以及设置自己的舒适温度区间</li><li>可调节蓝牙发射功率(自己权衡省电或信号覆盖率)</li></ul></li></ul></li><li>青萍动作和环境光传感器(CGPR1), 分体构思不错,光强能够识别弱光,缺点是动作感知<code>没人</code>会偶尔失灵,感知<code>有人</code>灵敏<ul><li><img src="./qingping_CGPR1.jpg" alt="QingPing CGPR1.jpg"></li><li>我主要是用它的环境光(光强)传感器,因为绿米M1S网关带和绿米(RTCGQ11LM)人体PIR传感带的光强传感器弱光下全部为0,根本没用!</li></ul></li><li>小米体脂秤2: 因为是接收广播所以数据不能立马出现,开机后要等一会儿,换句话说首次测量结果可能不会出现<ul><li><img src="./mi_scale2.jpg" alt="mi_scale2"></li><li>查看体脂信息需要安装 <a href="https://github.com/dckiller51/bodymiscale" target="_blank" rel="noopener">BodyMiScale 集成</a> 以及 前端 <a href="https://github.com/dckiller51/lovelace-body-miscale-card" target="_blank" rel="noopener">lovelace-body-miscale-card</a> 详见后述</li></ul></li><li><a href="#%E5%BC%80%E6%BA%90esphome%E9%80%9A%E7%94%A8%E8%93%9D%E7%89%99%E7%BD%91%E5%85%B3">自制开源ESPHome通用蓝牙网关(ESP32-C3)</a></li><li>Yeelight 智能调光开关(YLKG08YL) 贴装版 旋动一格有明显的喀哒声音,不错,但是,并没有信号发出,必须连续扭动两格(大约)才是1 step, 如果单独一格一格的扭动,也没有信号.<ul><li><img src="./Yeelight-YLKG08YL.jpg" alt="Yeelight-YLKG08YL"></li></ul></li></ul><h3 id="xiao-mi-lan-ya-wen-shi-du-ji-2-shua-di-san-fang-kai-yuan-gu-jian" class="heading-control">小米蓝牙温湿度计2刷第三方开源固件<a class="heading-anchor" href="#xiao-mi-lan-ya-wen-shi-du-ji-2-shua-di-san-fang-kai-yuan-gu-jian" aria-hidden="true"></a></h3><p><img src="./mi_temp2.jpg" alt="Mi temp2"></p><ul><li>小米蓝牙温湿度计2价格便宜,只有Zigbee温湿度计的一半不到,还带屏幕</li><li>蓝牙穿墙能力弱于Zigbee</li><li>官方原始固件:<ul><li>10分钟报告1次温湿度,大约1小时报告1次电量.如果想和其它设备联动(如,空调),这个上报频率就没法用.</li><li>依然耗电</li><li>无法调整配置</li></ul></li></ul><p>而在刷入第三方开源固件后:</p><ul><li>更省电</li><li>可调节报告频率,默认是2.5秒报告1次温湿度,这个频率联动完全足够,报告频率越低越省电.</li><li>可以读取设备上记录的温湿度数据(循环记录19632个测量结果),记录的时间间隔也可以配置</li><li>可以校准温湿度以及设置自己的舒适温度区间</li><li>可调节蓝牙发射功率(自己权衡省电或信号覆盖率)</li></ul><h4 id="di-san-fang-gu-jian-shua-ji" class="heading-control">第三方固件刷机<a class="heading-anchor" href="#di-san-fang-gu-jian-shua-ji" aria-hidden="true"></a></h4><p>使用Chrome浏览器即可直接Web刷机,请启用浏览器的<a href="chrome://flags/#enable-experimental-web-platform-features">#enable-experimental-web-platform-features</a>功能后重启浏览器.</p><ol><li>点击 <a href="https://pvvx.github.io/ATC_MiThermometer/TelinkMiFlasher.html" target="_blank" rel="noopener">TelinkMiFlasher.html</a> 进入刷机页面</li><li>点击 <code>Connect</code> 按钮,连接待刷机的小米蓝牙温湿度计2,设备名一般是: <code>LYWSD03MMC</code></li><li>配对连接后,点击<code>Do Activate</code>按钮,自动获取小米蓝牙温湿度计2的token和绑定密码</li><li>然后点 <code>Custom firmware ver 3.7</code> 按钮, 旁边那个<code>Original_OTA_Xiaomi_LYWSD03MMC_v1.0.0_0130.bin</code>按钮是恢复原来的官方固件</li><li>点<code>Start Flashing</code>按钮开始刷机</li><li>成功后即可在该页面上修改各种配置参数.要想更省电可以把发射功率和上报频率调节得更小些即可.</li><li>点击参数配置的 <code>Show all mi keys</code>按钮,显示设备的MAC地址,并自己记录下来温湿度计的MAC(不包括最后4位,最后4位是随机数,不是MAC地址),后面要用</li></ol><p>最后,请关闭刚才用于刷机的蓝牙适配器设备,不然HA设备没法发现小米蓝牙温湿度计2.</p><p>我修改后的温度计配置:</p><ul><li>Advertising interval: 3125 ms</li><li>Measure interval: 4 x(Advertising interval)</li><li>Connect latency: 2600 ms</li><li>Recording averaging measurements to flash memory: 90 x(measure interval)</li></ul><h3 id="xiao-mi-ti-zhi-cheng-2-jie-ru-ha-duo-ren-ti-zhong-zi-dong-ji-lu-fang-an" class="heading-control">小米体脂秤2接入HA多人体重自动记录方案<a class="heading-anchor" href="#xiao-mi-ti-zhi-cheng-2-jie-ru-ha-duo-ren-ti-zhong-zi-dong-ji-lu-fang-an" aria-hidden="true"></a></h3><p><img src="./mi_scale2.jpg" alt="mi_scale2"></p><p>本解决方案可以支持多人体重自动记录(前提是每个人有明显的体重区分或阻抗区分),以及完美显示最近一次的的人体体重,体脂信息.</p><blockquote><p>使用的前提硬件,需要至少支持BLE蓝牙4.0(蓝牙是向下兼容的,所以BLE蓝牙5也可)的适配器,一般的HA盒子都有,如果是用PC就看带WIFI不,一般WIFI都带蓝牙,没有就买一个支持的USB WIFI适配器.</p></blockquote><p>请首先安装 <code>Passive BLE Monitor 集成</code>.</p><p>如果你已经勾选了<code>Passive BLE Monitor 集成</code>的&quot;自动发现设备及传感器&quot;,那么小米体脂秤2开机后多等一会(保持体脂秤屏幕常亮),就应该看到在该集成(Bluetooth Low Energy Monitor)下多出一个<code>Mi Scale V2</code>设备,你可以重命名一个有意义的名字.</p><p>如果你希望看到详细的体脂信息,那么需要先在HACS第三方集成商场中安装 <a href="https://github.com/dckiller51/bodymiscale" target="_blank" rel="noopener">BodyMiScale 集成</a>: 点击 <code>HACS</code> -&gt; <code>集成</code> -&gt; <code>自定义存储库</code>(右上角三个点中) -&gt; 存储库设置为 “<a href="https://github.com/dckiller51/bodymiscale" target="_blank" rel="noopener">https://github.com/dckiller51/bodymiscale</a>” , 类别为: <code>集成</code></p><p><strong>注意</strong>,<a href="https://github.com/dckiller51/bodymiscale" target="_blank" rel="noopener">BodyMiScale 集成</a>的最新版本<code>2.1 版本</code>需要您安装的<code>Home Assistant</code>是 <code>2022.4</code> 以上版本才能支持,否则您只能安装<code>bodymiscale@2.0</code>以下版本,切勿升级.</p><p><a href="https://github.com/dckiller51/bodymiscale" target="_blank" rel="noopener">BodyMiScale 集成</a>的最新版本已经支持直接在配置界面中配置:</p><ol><li><code>配置</code> -&gt; <code>设备与服务</code> -&gt; <code>添加集成</code> -&gt; 搜索 <code>BodyMiScale</code><ul><li><img src="./sel-bodymiscale.png" alt="Sel-BodyMiScale"></li></ul></li><li>开始配置 <code>BodyMiScale</code><ul><li><img src="./bodymiscale.png" alt="BodyMiScale"></li></ul></li><li>如果有多人重复上述操作</li></ol><p>如果是<a href="https://github.com/dckiller51/bodymiscale" target="_blank" rel="noopener">BodyMiScale</a>@2.0及以下的版本必须在<code>configuration.yaml</code>手工配置传感器:</p><pre><code class="yml"><span class="hljs-attr">bodymiscale:</span>  <span class="hljs-attr">your_name1:</span>    <span class="hljs-attr">sensors:</span>      <span class="hljs-attr">weight:</span> <span class="hljs-string">sensor.ble_stabilized_weight_XXXX</span>      <span class="hljs-attr">impedance:</span> <span class="hljs-string">sensor.ble_impedance_XXXX</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">176</span>    <span class="hljs-attr">born:</span> <span class="hljs-string">"1990-04-10"</span>    <span class="hljs-attr">gender:</span> <span class="hljs-string">"male"</span>    <span class="hljs-attr">model_miscale:</span> <span class="hljs-string">"181B"</span> <span class="hljs-comment"># miscale2</span>  <span class="hljs-attr">your_name2:</span>    <span class="hljs-attr">sensors:</span>      <span class="hljs-attr">weight:</span> <span class="hljs-string">sensor.ble_stabilized_weight_XXXX</span>      <span class="hljs-attr">impedance:</span> <span class="hljs-string">sensor.ble_impedance_XXXX</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">176</span>    <span class="hljs-attr">born:</span> <span class="hljs-string">"1990-04-10"</span>    <span class="hljs-attr">gender:</span> <span class="hljs-string">"male"</span>    <span class="hljs-attr">model_miscale:</span> <span class="hljs-string">"181D"</span> <span class="hljs-comment">#  miscale1</span></code></pre><p>重启后就会多出来名为: <code>bodymiscale.your_name1</code> 和 <code>bodymiscale.your_name2</code>的实体.</p><p>然后你需要在HACS第三方集成商场中安装<a href="https://github.com/dckiller51/lovelace-body-miscale-card" target="_blank" rel="noopener">lovelace-body-miscale-card</a> 界面, 来使用该实体.</p><p>先加库: 点击 <code>HACS</code> -&gt; <code>集成</code> -&gt; <code>自定义存储库</code>(右上角三个点中) -&gt; 存储库设置为 <code>https://github.com/dckiller51/lovelace-body-miscale-card</code> , 类别为: <code>Lovelace</code></p><p>然后再安装该界面. 最后复制仓库中的图片文件(<code>src/images/*</code>)到<code>config/www/images</code>目录下.</p><p>接着就可以在 lovelace 中进行配置了:</p><pre><code class="yml"><span class="hljs-attr">type:</span> <span class="hljs-string">custom:body-miscale-card</span><span class="hljs-attr">entity:</span> <span class="hljs-string">bodymiscale.your_name1</span><span class="hljs-attr">show_name:</span> <span class="hljs-literal">true</span><span class="hljs-attr">image:</span> <span class="hljs-string">/local/images/miscale2.jpg</span><span class="hljs-attr">show_states:</span> <span class="hljs-literal">true</span><span class="hljs-attr">show_attributes:</span> <span class="hljs-literal">true</span><span class="hljs-attr">show_body:</span> <span class="hljs-literal">true</span><span class="hljs-attr">show_buttons:</span> <span class="hljs-literal">true</span><span class="hljs-attr">show_toolbar:</span> <span class="hljs-literal">true</span></code></pre><p>如果有多个人需要分别记录,并且可以通过体重区分的话,当然你也可以加上阻抗值(impedance)来判断,那么可以在<code>configuration.yaml</code>中:</p><pre><code class="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">template</span>  <span class="hljs-attr">sensors:</span>    <span class="hljs-comment"># the first person's weight</span>    <span class="hljs-attr">weight_your_name:</span>      <span class="hljs-attr">friendly_name:</span> <span class="hljs-string">"Weight Your Name"</span>      <span class="hljs-attr">value_template:</span> <span class="hljs-string">&gt;-        {% set weight = states('sensor.ble_stabilized_weight_XXXX') | float %}        {% if 66.9 <= weight <="77" %} {{ states("sensor.ble_stabilized_weight_xxxx") }} {% else states("sensor.weight_your_name") endif span>      <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">'kg'</span>      <span class="hljs-attr">icon_template:</span> <span class="hljs-string">mdi:weight-kilogram</span>    <span class="hljs-comment"># the first person's impedance</span>    <span class="hljs-attr">impedance_your_name:</span>      <span class="hljs-attr">friendly_name:</span> <span class="hljs-string">"Impedance Your Name"</span>      <span class="hljs-attr">value_template:</span> <span class="hljs-string">&gt;-        {% set weight = states('sensor.ble_stabilized_weight_XXXX') | float %}        {% if 66.9 <= weight <="77" %} {{ states("sensor.ble_impedance_xxxx") }} {% else states("sensor.impedance_your_name") endif span>      <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">'ohm'</span>      <span class="hljs-attr">icon_template:</span> <span class="hljs-string">mdi:omega</span></=></span></=></span></code></pre><p>问题又来了,如何显示最近的历史数据. 因为当电子秤离线后或者HA重启后,就没当前数据(最近一次的)了!</p><p>还是用的SQL Sensor获取的最近一次的历史数据:</p><pre><code class="yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">sql</span>  <span class="hljs-attr">db_url:</span> <span class="hljs-type">!secret</span> <span class="hljs-string">db_url</span>  <span class="hljs-attr">queries:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Latest</span> <span class="hljs-string">Weight</span> <span class="hljs-string">Your</span> <span class="hljs-string">Name</span>      <span class="hljs-attr">query:</span> <span class="hljs-string">"SELECT state FROM states WHERE entity_id = 'sensor.weight_your_name' and state &lt;&gt; 'unknown' and state &lt;&gt; 'unavailable' ORDER BY created DESC LIMIT 1;"</span>      <span class="hljs-attr">column:</span> <span class="hljs-string">"state"</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Latest</span> <span class="hljs-string">Impedance</span> <span class="hljs-string">Your</span> <span class="hljs-string">Name</span>      <span class="hljs-attr">query:</span> <span class="hljs-string">"SELECT state FROM states WHERE entity_id = 'sensor.impedance_your_name' and state &lt;&gt; 'unknown' and state &lt;&gt; 'unavailable' ORDER BY created DESC LIMIT 1;"</span>      <span class="hljs-attr">column:</span> <span class="hljs-string">"state"</span><span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">template</span>  <span class="hljs-attr">sensors:</span>    <span class="hljs-attr">weight_your_name:</span>      <span class="hljs-attr">friendly_name:</span> <span class="hljs-string">"Weight Your Name"</span>      <span class="hljs-attr">value_template:</span> <span class="hljs-string">&gt;-        {% set weight = states('sensor.ble_stabilized_weight_XXXX') | float(0) %}        {% set id = 'weight_your_name' %}          {% if 66.9 <= weight <="77" %} {{ }} {% elif state_attr("sensor.latest_"+id, 'state') else states("sensor."+id) endif span>      <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">'kg'</span>      <span class="hljs-attr">icon_template:</span> <span class="hljs-string">mdi:weight-kilogram</span>    <span class="hljs-attr">impedance_your_name:</span>      <span class="hljs-attr">friendly_name:</span> <span class="hljs-string">"Impedance Your Name"</span>      <span class="hljs-attr">value_template:</span> <span class="hljs-string">&gt;-        {% set weight = states('sensor.ble_stabilized_weight_XXXX') | float(0) %}        {% set id = 'impedance_your_name' %}          {% if 66 <= weight <="77" %} {{ states("sensor.ble_impedance_xxxx") }} {% elif state_attr("sensor.latest_"+id, 'state') else states("sensor."+id) endif span>      <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">'ohm'</span>      <span class="hljs-attr">icon_template:</span> <span class="hljs-string">mdi:omega</span></=></span></=></span></code></pre><p>注意:   <code>db_url: !secret db_url</code> 要填写自己<code>recorder</code>数据库的url. 详细请参阅 : <a href="https://www.home-assistant.io/integrations/sql/" target="_blank" rel="noopener">SQL Sensor</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-san-lan-ya-she-bei&quot; class=&quot;heading-control&quot;&gt;智能家居硬件采购避坑指要(三) 蓝牙设备&lt;a class=&quot;heading-anchor&quot; href=&quot;#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-san-lan-ya-she-bei&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;lan-ya-te-xing&quot; class=&quot;heading-control&quot;&gt;蓝牙特性&lt;a class=&quot;heading-anchor&quot; href=&quot;#lan-ya-te-xing&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;短距离通信：蓝牙技术的通信范围通常为10米以内&lt;/li&gt;
&lt;li&gt;蓝牙信号穿墙能力有限,除非你购买BLE蓝牙网关中继设备,而且更容易受到干扰,尤其是不带自动跳频的蓝牙.&lt;/li&gt;
&lt;li&gt;能耗相对较低：因为低功耗蓝牙设备在省电上还是比不过Zigbee设备,BLE蓝牙5.0在省电上与zigbee很接近了.
&lt;ul&gt;
&lt;li&gt;因此: 为了省电,米家的温度传感器(LYWSD03MMC)是大约10分钟发送一次数据,如果不刷第三方固件,想与空调联动就不要想了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;简单易用：智能家居蓝牙设备使用普及度高的蓝牙协议，用户不需要额外的网关或路由器即可连接和控制设备&lt;/li&gt;
&lt;li&gt;目前蓝牙协议大多数是私有协议，互通性较差,HA无法直接控制,只有少量的特定厂家的低功耗蓝牙传感设备才能通过第三方&lt;a href=&quot;https://github.com/custom-components/ble_monitor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Passive BLE Monitor 集成&lt;/a&gt; 直接接入HA,支持的设备详见下方的支持列表.&lt;/li&gt;
&lt;li&gt;价格便宜:由于蓝牙技术在手机和其他消费电子设备上得到广泛应用，智能家居蓝牙设备的成本相对较低。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;di-san-fang-passive-ble-monitor-ji-cheng&quot; class=&quot;heading-control&quot;&gt;第三方&lt;a href=&quot;https://github.com/custom-components/ble_monitor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Passive BLE Monitor 集成&lt;/a&gt;&lt;a class=&quot;heading-anchor&quot; href=&quot;#di-san-fang-passive-ble-monitor-ji-cheng&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 最新HA版本(2022.8以后)的官方蓝牙集成开始直接支持Passive BLE 设备,目前还在移植更多的蓝牙设备.官方蓝牙集成不能与BLE Monitor集成同时工作!请做好选择,官方蓝牙集成同样支持蓝牙网关.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Open Source" scheme="https://riceball.me/categories/Open-Source/"/>
    
      <category term="Hardware" scheme="https://riceball.me/categories/Open-Source/Hardware/"/>
    
      <category term="SmartHome" scheme="https://riceball.me/categories/Open-Source/Hardware/SmartHome/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="iot" scheme="https://riceball.me/tags/iot/"/>
    
      <category term="open source" scheme="https://riceball.me/tags/open-source/"/>
    
      <category term="hardware" scheme="https://riceball.me/tags/hardware/"/>
    
      <category term="smarthome" scheme="https://riceball.me/tags/smarthome/"/>
    
      <category term="homeassistant" scheme="https://riceball.me/tags/homeassistant/"/>
    
      <category term="ha" scheme="https://riceball.me/tags/ha/"/>
    
      <category term="wifi" scheme="https://riceball.me/tags/wifi/"/>
    
  </entry>
  
  <entry>
    <title>智能家居硬件采购避坑指要(二) Wifi设备</title>
    <link href="https://riceball.me/article/home-assistant-wifi/"/>
    <id>https://riceball.me/article/home-assistant-wifi/</id>
    <published>2022-05-05T00:38:18.000Z</published>
    <updated>2023-03-09T02:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-er-wifi-she-bei" class="heading-control">智能家居硬件采购避坑指要(二) Wifi设备<a class="heading-anchor" href="#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-er-wifi-she-bei" aria-hidden="true"></a></h1><p><img src="./wifi-smart-home.jpg" alt></p><h2 id="wifi-te-xing" class="heading-control">Wifi 特性<a class="heading-anchor" href="#wifi-te-xing" aria-hidden="true"></a></h2><ol><li>穿墙性能好(与Zigbee和蓝牙相比)</li><li>高带宽(与Zigbee和蓝牙相比)</li><li>Wifi模块便宜</li><li>需要考虑路由器的带机量,一般家用路由器的带机量都不大.</li><li>最好选择直接供电(非电池)的Wifi设备,避免频繁更换电池的麻烦</li></ol><p>Zigbee2MQTT的低功耗是源于它的低速,但某些场合则要求高带宽,比如<code>IP摄像头</code>. 而对IP摄像头来说支持 <code>ONVIF(Open Network Video Interface Forum)</code> 协议是必须的,不支持开放网络视频协议的都是在耍流氓,当用户是羊!比如:<strong>萤石</strong>私有协议,看似可以接入HA,你不知道的是所有的控制都要去他们公司云上绕一圈才回来,为了达到偷窥家庭的目的,特意废弃一贯支持的<code>ONVIF</code>,搞了萤石私有协议,让他们公司的有权限的人可以随时随地观看场景剧甚至动作片,不旺一番苦心.</p><p>另,就算商家告诉你支持<code>ONVIF</code>也不要掉以轻心,因为<code>ONVIF</code>也是可深可浅,浅的就只有选择个分辨率,控制录像,深的则可以控制云台,控制麦克风语音,以及触发运动事件等. 乐橙号称支持<code>ONVIF</code>, 但是居然把Web管理端给去掉了!导致要用Wifi就不能修改设备密码,只能使用设备固定初始的安全码(真的安全吗?),如果要改密码只能在复位后,通过网口连上后用大华的IP配置工具修改,然后Wifi配置就没辙了,只能用有线网络,还有他的 ntp 授时服务配置根本没有用,用的是自家的端口号10000的一个鬼服务,这个端口一屏蔽时间就完蛋,然后就是录制视频上的<strong>时间和乐橙LOGO</strong>居然无法取消.</p><p>其它Wifi设备最好使用能刷 开源<a href="https://esphome.io/" target="_blank" rel="noopener">ESPHome</a> 或 <a href="https://tasmota.github.io/" target="_blank" rel="noopener">Tasmota</a>固件的设备, 这样就能完全掌控该设备:</p><ul><li><a href="https://www.esphome-devices.com/" target="_blank" rel="noopener">ESPHome 支持的设备列表</a></li><li><a href="https://templates.blakadder.com/" target="_blank" rel="noopener">Tasmota 支持的设备列表</a></li></ul><h2 id="wo-mai-guo-de-wifi-she-bei" class="heading-control">我买过的WIFI设备<a class="heading-anchor" href="#wo-mai-guo-de-wifi-she-bei" aria-hidden="true"></a></h2><ul><li>乐橙(IMou TP7S-4M)IP摄像头: 坑货,如果不是因为半价,勉强可用(支持<code>ONVIF</code>云台控制)就退了,所谓AI人脸识别,追踪全是联机服务和产品无关 不推荐<ul><li>当然更坑的是<strong>萤石</strong>,连<code>ONVIF</code>也不支持,海康威视不敢坑企业和政府,于是专门成立<strong>萤石</strong>出来坑普通消费者的,而<strong>乐橙</strong>则是大华专门成立出来坑的.</li></ul></li><li>SONOFF(易微联 NSPanel) 智能面板, 带温度,小喇叭,两路继电器,两个实体按钮及触摸屏, 可刷开源 ESPHome 固件,<strong>推荐</strong><ul><li><img src="./nspanel.jpg" alt="nsPanel"></li><li><a href="https://bbs.hassbian.com/thread-15932-1-1.html" target="_blank" rel="noopener">易微联 SONOFF NSPanel 智能面板刷 ESPHome 固件 接入 HA 入坑指南</a></li></ul></li><li>博联 RM Pro 万能遥控器: 支持红外,以及 RF315/433 很久以前买的<ul><li><img src="./rmpro.jpg" alt="Broadlink RM Pro"></li></ul></li><li>博联 SPMini3 Wi-Fi插座（10A） 很久以前买的<ul><li><img src="./sp_mini3.jpg" alt="sp_mini3"></li></ul></li><li>小米路由器CR6608（移动定制版）: 已刷开源OpenWRT固件<ul><li><img src="./cr6608.jpg" alt="cr6608"></li></ul></li><li>树莓派 Zero/w BCM2835 1GHz 主频 ARM11 32位单核, 512 MB DDR2<ul><li><img src="./raspberrypi_zerow.jpg" alt="RaspberryPi Zero/w"></li></ul></li><li>Banana PI BPI-M2 Zero Allwinner H2+, 32位 Quad-core Cortex-A7 1.2GHz, Mali400 MP2 @600MHz, 512MB DDR 3 SDRAM<ul><li><img src="Banana-PI-BPI-M2-Zero.jpg" alt="Banana-PI-BPI-M2-Zero"></li></ul></li><li>Lichee RV 86 Panel 基于平头哥玄铁C906处理器,主频1GHz 512MB DDR3内存<ul><li><img src="./Sipeed-Lichee-RV-86-Panel.jpg" alt="Sipeed-Lichee-RV-86-Panel"></li></ul></li><li>RockPi S With PoE Hat Rockchip RK3308 512MB DDR3,4G NAND<ul><li><img src="./RockPi-S-With-PoE-Hat-Shell.jpg" alt="RockPi S With PoE Hat"></li></ul></li><li>Rock5 Model B RK3588 16GB RAM<ul><li>Quad-core ARM Cortex-A76 MPCore processor and quad-core ARM Cortex-A55 MPCore processor</li><li>Embedded ARM Mali-G610 MP4 3D GPU</li><li>The build-in NPU supports INT4/INT8/INT16/FP16 hybrid operation and computing power is up to 6TOPs</li><li><img src="./rock5b.jpg" alt="Rock5B"></li></ul></li><li>NanoPi R4S<ul><li><img src="./Nanopi-R4S.jpg" alt="Nanopi-R4S"></li></ul></li><li>HK1 Box<ul><li><img src="./HK1-Box.jpg" alt="HK1-Box"></li></ul></li><li>NanoPC T4 Box<ul><li><img src="./NanoPC-T4-Box.jpg" alt="NanoPC-T4-Box"></li></ul></li><li>CubieTruck Box<ul><li><img src="./CubieTruck.jpg" alt="CubieTruck"></li></ul></li><li>以及ESP32/ESP8266板子若干</li></ul><h2 id="kai-yuan-esphome-he-tasmota-gu-jian-bi-jiao" class="heading-control">开源 ESPHome 和 Tasmota 固件比较<a class="heading-anchor" href="#kai-yuan-esphome-he-tasmota-gu-jian-bi-jiao" aria-hidden="true"></a></h2><p><a href="https://esphome.io/" target="_blank" rel="noopener">ESPHome</a> 和 <a href="https://tasmota.github.io/" target="_blank" rel="noopener">Tasmota</a> 都是基于 ESP8266 或 ESP32 的开源固件，用于控制智能家居设备的固件。它们都提供了很多功能，例如支持 MQTT、HTTP、WebSocket，以及对各种传感器和执行器的支持。</p><p>然而，它们在以下几个方面有所不同：</p><ol><li>设计哲学：ESPHome 的设计哲学是通过 YAML 文件进行配置，以使用户可以轻松地定义其设备的功能，而无需编写任何代码。另一方面，Tasmota 侧重于使用 Web 界面进行配置，其界面和配置选项更为复杂。<ol><li>ESPHome的固件是按需编译,体积更小</li><li>而Tasmota的固件是将所有功能都预先编译内置在固件中,体积大</li></ol></li><li>设备支持：ESPHome 目前支持更多的设备，而且它提供了对许多设备的官方支持。 Tasmota 虽然支持许多设备，但某些设备需要使用非官方固件或插件才能使用。</li><li>社区支持：ESPHome 和 Tasmota 都有活跃的社区，但 ESPHome 的社区更加友好和活跃，并且有更多的文档和示例可供参考。</li><li>集成性：ESPHome 的集成性更好，可以轻松地将其与 Home Assistant 和其他智能家居平台集成。Tasmota 也可以集成到 Home Assistant 中，但需要更多的设置和调整。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-er-wifi-she-bei&quot; class=&quot;heading-control&quot;&gt;智能家居硬件采购避坑指要(二) Wifi设备&lt;a class=&quot;heading-anchor&quot; href=&quot;#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-er-wifi-she-bei&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;./wifi-smart-home.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;wifi-te-xing&quot; class=&quot;heading-control&quot;&gt;Wifi 特性&lt;a class=&quot;heading-anchor&quot; href=&quot;#wifi-te-xing&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;穿墙性能好(与Zigbee和蓝牙相比)&lt;/li&gt;
&lt;li&gt;高带宽(与Zigbee和蓝牙相比)&lt;/li&gt;
&lt;li&gt;Wifi模块便宜&lt;/li&gt;
&lt;li&gt;需要考虑路由器的带机量,一般家用路由器的带机量都不大.&lt;/li&gt;
&lt;li&gt;最好选择直接供电(非电池)的Wifi设备,避免频繁更换电池的麻烦&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Zigbee2MQTT的低功耗是源于它的低速,但某些场合则要求高带宽,比如&lt;code&gt;IP摄像头&lt;/code&gt;. 而对IP摄像头来说支持 &lt;code&gt;ONVIF(Open Network Video Interface Forum)&lt;/code&gt; 协议是必须的,不支持开放网络视频协议的都是在耍流氓,当用户是羊!比如:&lt;strong&gt;萤石&lt;/strong&gt;私有协议,看似可以接入HA,你不知道的是所有的控制都要去他们公司云上绕一圈才回来,为了达到偷窥家庭的目的,特意废弃一贯支持的&lt;code&gt;ONVIF&lt;/code&gt;,搞了萤石私有协议,让他们公司的有权限的人可以随时随地观看场景剧甚至动作片,不旺一番苦心.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Open Source" scheme="https://riceball.me/categories/Open-Source/"/>
    
      <category term="Hardware" scheme="https://riceball.me/categories/Open-Source/Hardware/"/>
    
      <category term="SmartHome" scheme="https://riceball.me/categories/Open-Source/Hardware/SmartHome/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="iot" scheme="https://riceball.me/tags/iot/"/>
    
      <category term="open source" scheme="https://riceball.me/tags/open-source/"/>
    
      <category term="hardware" scheme="https://riceball.me/tags/hardware/"/>
    
      <category term="smarthome" scheme="https://riceball.me/tags/smarthome/"/>
    
      <category term="homeassistant" scheme="https://riceball.me/tags/homeassistant/"/>
    
      <category term="ha" scheme="https://riceball.me/tags/ha/"/>
    
      <category term="wifi" scheme="https://riceball.me/tags/wifi/"/>
    
  </entry>
  
  <entry>
    <title>智能家居硬件采购避坑指要(一) Zigbee设备</title>
    <link href="https://riceball.me/article/home-assistant-zigbee/"/>
    <id>https://riceball.me/article/home-assistant-zigbee/</id>
    <published>2022-05-04T00:38:18.000Z</published>
    <updated>2023-03-09T02:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./zigbee-smart-home.jpg" alt></p><h1 id="zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-yi-zigbee-she-bei" class="heading-control">智能家居硬件采购避坑指要(一) Zigbee设备<a class="heading-anchor" href="#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-yi-zigbee-she-bei" aria-hidden="true"></a></h1><p>注意: <a href="https://www.home-assistant.io/" target="_blank" rel="noopener">Home Assistant</a> 简称 HA, 后面我就用简称了.</p><h2 id="zigbee-she-bei-de-te-xing" class="heading-control">Zigbee设备的特性<a class="heading-anchor" href="#zigbee-she-bei-de-te-xing" aria-hidden="true"></a></h2><p>为啥要以Zigbee设备为主,这就要从它的特性谈起:</p><ol><li>低功耗：由于节点常常休眠，zigbee是比较省电的,一般1-2年</li><li>短时延，设备激活快，点播中的消息确认是微秒级别；不过路径长的话会增加延时</li><li>可靠,安全,数据通讯是加密的</li><li>网络容量大：实际CC2530组建的网络基本能达到100个节点</li><li>自组织和自愈性，协调器自动建立网络，有节点故障时网络可以自我修复</li><li>近距离，单个节点通讯范围最多是100米以内</li><li>支持的设备的多: 因为Zigbee设备的协议基本透明(或破解)了,大多可以<strong>直接接入</strong>HA.</li></ol><h2 id="tang-keng-ji-lu" class="heading-control">蹚坑记录<a class="heading-anchor" href="#tang-keng-ji-lu" aria-hidden="true"></a></h2><p>这里<strong>注意</strong>: 不要通过什么各类<code>**多模网关**</code>(如:小米/绿米)来接入,它们只能接入<code>大桶</code>内的zigbee设备!而且他们不停的向互联网发送采集到的设备数据,并能从网络上<strong>直接接管</strong>您的设备.</p><p>我最初买的就是<strong>小米多模网关</strong>和<strong>绿米M1S网关</strong>,试用后退掉了<strong>小米多模网关</strong>,留下了<strong>绿米M1S网关</strong>,图它的彩灯,没想到这个坑货,我一旦屏蔽<strong>绿米M1S网关</strong>连接互联网,那绿米的破彩灯不一会儿就闪个不停关掉停一会儿又闪. 后来发现了 <strong>Zigbee2MQTT(Z2M) USB网关</strong>,把我所有的Zigbee设备转到新的Z2M USB上去,才终于清静了.</p><p>请购买使用开源的 <a href="https://www.zigbee2mqtt.io/" target="_blank" rel="noopener">Zigbee2MQTT(Z2M)</a> 网关接入,价格也不贵. <a href="https://www.zigbee2mqtt.io/" target="_blank" rel="noopener">Z2M</a> 支持的硬件网关列表: <a href="https://www.zigbee2mqtt.io/guide/adapters/" target="_blank" rel="noopener">https://www.zigbee2mqtt.io/guide/adapters/</a></p><p>我买的是<a href="https://sonoff.tech/product/diy-smart-switch/sonoff-dongle-plus/" target="_blank" rel="noopener">SONOFF USB Dongle Plus</a>万能通用网关(基于CC2652P芯片)价位在￥70左右, 该网关通过<a href="https://www.zigbee2mqtt.io/" target="_blank" rel="noopener">Z2M</a>能支持2千余种的Zigbee设备. <strong>值得推荐</strong></p><p><a href="https://sonoff.tech/product/diy-smart-switch/sonoff-dongle-plus" target="_blank" rel="noopener"><img src="./sonoff-dongle-plus.png" alt="sonoff-dongle-plus"></a></p><p><a href="https://www.zigbee2mqtt.io/" target="_blank" rel="noopener">Z2M</a>具体支持的设备列表请看这里: <a href="https://www.zigbee2mqtt.io/supported-devices/" target="_blank" rel="noopener">https://www.zigbee2mqtt.io/supported-devices/</a>. 够让你挑花眼的, 我买的绝大部分Zigbee设备在Z2M均能正常使用,包括绿米/小米的Zigbee设备,反而是在SONOFF(易微联)的温度计和按钮上碰到了点小问题.</p><p>先说说碰到的问题吧:</p><p>首先涂鸦的设备质量参差不齐,因为涂鸦主要是卖方案的,所以实际上设备要看各个厂家的品控.购买要多加小心. 我试过三家的涂鸦人体PIR传感器,其中有一家发过来的全是坏的:一个能配对,但是工作一会就没有数据了,另一个根本不工作,配对都不行. 另外两家的还行.我买涂鸦的设备总量比较少.</p><p>SONOFF(易微联SNZB-02)的温湿度计配对使用没啥问题,但是如果你再次配对到另一个Zigbee网关,然后再配对回原来的网关,你会发现,尽管配对成功,信号也正常,但就是没有数据,后来我发现当把这货配对到M1S网关,尽管M1S会报告该设备无法配对,拒绝配对后,我再配对回原来的网关,数据居然有了.<br><img src="./sonoff-snzb-02-s.jpg" alt="sonoff-snzb-02"></p><p>SONOFF(易微联SNZB-01)的按钮配对和使用也没啥问题,问题出在<code>绑定</code>上,Zigbee有个功能可以将按钮设备<code>绑定</code>到另一个设备(如开关)上,这样就算没有HA中枢,按钮也能控制另一个设备(如开关),当易微联的按钮配对时,会自动绑定一个设备(开关),这很烦,而当我在Z2M上操作解除绑定的时候,发现竟然无法解绑.而与此同时也无法绑定新设备.<br><img src="./sonoff-snzb-01-s.jpg" alt="sonoff-snzb-01"></p><p>涂鸦(Lonsonho ZB-RGBCW)全彩灯泡 如果长时间关闭电源,灯泡就会彻底掉线,需要再次重新配对join.<br><img src="./tuya-zb-rgbcw-tiny.jpg" alt="tuya-zb-rgbcw"></p><p>绿米的品控不错,但是贵,另外绿米的人体PIR传感器(RTCGQ11LM),虽然带了温度和光强,但是温度根本不准,温度差了6度,这货光强照度和M1S网关的一样在弱光下根本没值,就是0,强光下变化倒是明显,没鸟用,在<a href="https://www.zigbee2mqtt.io/" target="_blank" rel="noopener">Z2M</a>配置光强照度以及温度为精度为小数点后2位,但根本不生效,没有小数后面的数字,配置里只有温度校准有用.</p><p>现在用的Zigbee设备列表:</p><ol><li>SONOFF(易微联SNZB-02)的温湿度计 小问题 不推荐<br><img src="./sonoff-snzb-02.jpg" alt="sonoff-snzb-02"></li><li>SONOFF(易微联SNZB-01)的按钮    小问题 不推荐<br><img src="./sonoff-snzb-01.jpg" alt="sonoff-snzb-01"></li><li>SONOFF(易微联SNZB-03) 人体PIR传感 推荐<br><img src="./sonoff-snzb-03.jpg" alt="sonoff-snzb-03"></li><li>SONOFF(易微联SNZB-04) 门磁 推荐 <img src="./sonoff-snzb-04.jpg" alt="sonoff-snzb-04"></li><li><a href="https://sonoff.tech/product/diy-smart-switch/sonoff-dongle-plus/" target="_blank" rel="noopener">SONOFF(易微联) USB Dongle Plus</a> 万能通用网关(基于CC2652P芯片) 推荐 <img src="./sonoff-dongle-plus.png" alt="sonoff-dongle-plus"></li><li>涂鸦(Lonsonho ZB-RGBCW)灯泡 不推荐 <img src="./tuya-zb-rgbcw.jpg" alt="tuya-zb-rgbcw"></li><li>涂鸦(TuYa TS0203) 门磁 <img src="./tuya-ts0203.jpg" alt="ts0203"></li><li>涂鸦(TuYa TS0202) 人体PIR传感 <img src="./tuya-ts0202.jpg" alt="ts0202"></li><li>涂鸦(TuYa TS0601_motion_sensor) 人体毫米波雷达传感 性价比太差,不如买IP摄像头 <img src="./tuya-ts0601_motion_sensor.jpg" alt="tuya-ts0601_motion_sensor"></li><li>绿米(Xiaomi QBCZ11LM)86插座 可中继 <img src="./Aqara_QBCZ11LM.jpg" alt="Aqara_QBCZ11LM"></li><li>绿米(Xiaomi WSDCGQ11LM) 温湿度计 <img src="./Aqara_WSDCGQ11LM.jpg" alt="Aqara_WSDCGQ11LM"></li><li>绿米(Xiaomi RTCGQ11LM) 人体PIR传感 带温度和光强 它的温度和光强没法用,不推荐 <img src="./Aqara_RTCGQ11LM.jpg" alt="Aqara_RTCGQ11LM"></li><li>小米魔方(Xiaomi MFKZQ01LM) 控制器(玩具) <img src="./Aqara-MFKZQ01LM-Cube.jpg" alt="Aqara-MFKZQ01LM-Cube"></li></ol><p>所有的Zigbee灯泡都不推荐,因为几乎都是固定死的,根本无法拆解无法更换,还是买 <code>LED Controller</code>, 或买<code>开关/通断器</code>(最好带电量统计)比较划算.</p><h2 id="bi-mian-yu-wifi-24g-xin-dao-gan-rao-de-wen-ti" class="heading-control">避免与WIFI 2.4G信道干扰的问题<a class="heading-anchor" href="#bi-mian-yu-wifi-24g-xin-dao-gan-rao-de-wen-ti" aria-hidden="true"></a></h2><p>Zigbee和Wi-Fi 2.4G信道可以互相影响，因为它们都使用了相同的频段（2.4GHz频段）。在使用Wi-Fi 2.4G信道的同时使用Zigbee设备时，可能会发生以下问题：</p><ol><li>干扰问题：当Wi-Fi和Zigbee设备同时使用2.4G信道时，它们会相互干扰，导致信号质量下降、数据传输速度变慢等问题。</li><li>传输距离问题：Wi-Fi信号较强，如果Wi-Fi设备的信号覆盖区域较大，可能会导致Zigbee设备的信号被遮蔽或干扰，从而影响其正常工作。</li></ol><p>为了解决这些问题，可以采取以下措施：</p><ol><li>避免使用相同信道：在使用Wi-Fi和Zigbee设备时，应尽量避免它们使用相同的2.4G信道，以避免干扰和冲突。</li><li>选择合适的设备：在选购Wi-Fi和Zigbee设备时，应选择具有良好的抗干扰能力和传输距离的设备，以减少冲突的发生。</li><li>优化网络布局：在使用Wi-Fi和Zigbee设备时，应合理规划和布局网络，避免设备之间的信号干扰和遮蔽。</li><li>调整信道设置：在出现干扰和冲突的情况下，可以尝试调整Wi-Fi和Zigbee设备的信道设置，以减少干扰和冲突的发生。</li></ol><p>具体来说,就是 Wi-Fi和Zigbee设备在2.4GHz频段内使用的信道有一些重叠，这些信道的中心频率有可能会相互干扰：</p><ul><li>Wi-Fi使用的信道：1、6、11、以及在部分国家可用的信道14</li><li>Zigbee使用的信道：11、15、20、25<ul><li>所有Zigbee设备都支持11信道,其它信道不一定是所有Zigbee设备都支持.</li></ul></li></ul><p>因此，最佳方案是让WIFI避开11信道,如果实在避不开,可以让Zigbee网关尝试选择其它信道.只要不是太老的Zigbee设备就没啥问题,自行尝试.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;./zigbee-smart-home.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-yi-zigbee-she-bei&quot; class=&quot;heading-control&quot;&gt;智能家居硬件采购避坑指要(一) Zigbee设备&lt;a class=&quot;heading-anchor&quot; href=&quot;#zhi-neng-jia-ju-ying-jian-cai-gou-bi-keng-zhi-yao-yi-zigbee-she-bei&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;注意: &lt;a href=&quot;https://www.home-assistant.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Home Assistant&lt;/a&gt; 简称 HA, 后面我就用简称了.&lt;/p&gt;
&lt;h2 id=&quot;zigbee-she-bei-de-te-xing&quot; class=&quot;heading-control&quot;&gt;Zigbee设备的特性&lt;a class=&quot;heading-anchor&quot; href=&quot;#zigbee-she-bei-de-te-xing&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为啥要以Zigbee设备为主,这就要从它的特性谈起:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Open Source" scheme="https://riceball.me/categories/Open-Source/"/>
    
      <category term="Hardware" scheme="https://riceball.me/categories/Open-Source/Hardware/"/>
    
      <category term="SmartHome" scheme="https://riceball.me/categories/Open-Source/Hardware/SmartHome/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="iot" scheme="https://riceball.me/tags/iot/"/>
    
      <category term="open source" scheme="https://riceball.me/tags/open-source/"/>
    
      <category term="hardware" scheme="https://riceball.me/tags/hardware/"/>
    
      <category term="smarthome" scheme="https://riceball.me/tags/smarthome/"/>
    
      <category term="homeassistant" scheme="https://riceball.me/tags/homeassistant/"/>
    
      <category term="ha" scheme="https://riceball.me/tags/ha/"/>
    
      <category term="zigbee" scheme="https://riceball.me/tags/zigbee/"/>
    
  </entry>
  
  <entry>
    <title>智能家居:全屋智能还是全无智能,智能产品还是智障&quot;产品&quot;(服务)</title>
    <link href="https://riceball.me/article/home-assistant-guide/"/>
    <id>https://riceball.me/article/home-assistant-guide/</id>
    <published>2022-05-03T00:38:18.000Z</published>
    <updated>2023-03-09T02:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="quan-wu-zhi-neng-huan-shi-quan-wu-zhi-neng-zhi-neng-chan-pin-huan-shi-zhi-zhang-chan-pin-fu-wu" class="heading-control">全屋智能还是全无智能,智能产品还是智障&quot;产品&quot;(服务)<a class="heading-anchor" href="#quan-wu-zhi-neng-huan-shi-quan-wu-zhi-neng-zhi-neng-chan-pin-huan-shi-zhi-zhang-chan-pin-fu-wu" aria-hidden="true"></a></h1><p>要注意区分产品和服务,产品才是自己的,服务是别人的,是可以随时改变条款的. 不要花大价钱,买回一堆服务.</p><h2 id="yi-dian-fei-hua" class="heading-control">一点废话<a class="heading-anchor" href="#yi-dian-fei-hua" aria-hidden="true"></a></h2><p>现在越来越多&quot;智能&quot;产品,都要求注册/登陆后才能使用, 这不荒唐么,这是什么产品,还是服务?</p><p>听上去全屋智能高达上,其实只是是换了个词忽悠.你兴匆匆的东看看西看看,这家这个不错,便宜;那家那个功能强,都提全屋智能了,那还不赶紧随便挑.<br>嘿嘿,那你就想错了,各家是各家的,各家设备彼此是无法直接沟通的,没有互联互通,谈不上智能,唯有智障,弄一大堆按钮铺满在手机上遥控就是智能?</p><p>更可恶的是,他们不仅仅是正大光明的控制并窃取用户隐私信息,而且他们随时都有能力把&quot;全屋智能&quot;变成全屋智障: 只要他们中断互联网服务!</p><p>设备所采集的传感数据和大部分的控制指令都要先到他们的云上走一圈才会执行.他们非常自豪感觉牛逼:你家发生的事情,我们最先知道!<br>而且你不能说不,如果你说不,主动切断互联网,那么大部分智能设备就都歇菜了!</p><p>他们是如此的理直气壮,哪怕你不在家,我们也能让你知道家里发生的事情,我们还能帮你记录家里的事情,你看我们多好,我们的产品多先进,多智能!<br>这是产品?这TM明明是服务!无时无刻的在偷换概念. 这就好像你去买了房子,他们不仅不把房门钥匙交给你,还随时到房间里面想看就看.这多好,要啥钥匙,<br>这样你们都不用自己开门了,我们随叫随到给你开门,而且屋子里有任何动静我们都能通知你.</p><p>这样就叫&quot;全智能&quot;?这样买的又是啥设备,空气? 难道真的以为用户是羊,通过这样的办法就能把用户赶进自家的大桶里.题外话,尽管打破厂家壁垒互联互通的<a href="https://csa-iot.org/zh-CN/%E7%BC%96%E8%BE%91%E9%83%A8/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E5%88%9B%E6%96%B0%E5%B0%86%E5%8A%A0%E9%80%9F-matter%EF%BF%BC/" target="_blank" rel="noopener">Matter协议</a>提了许久,如今国内有多少智能商家落实下去了?</p><p>业主应该也必须<strong>拥有</strong>所有智能设备产生的各种数据以及完全的控制智能设备,这是全屋智能的前提. 否则这所谓的智能就没啥事,充其量只能算对方提供的服务,你还要倒掏腰包把对方施行服务的产品先行买下,然后作为他们的测试人员,感受并不完美的&quot;智能&quot;:遥控,场景遥控,他们则采集各种数据就成了他们提升自身服务品质的关键,同时作为提价的手段,最后把数据打包销售.</p><p>诚然,不用记录管理自己的设备,简单方便,但后果呢…,那还会是你的设备么?</p><p>感谢开源的曙光,正义的骑士,一系列的开源智能家居设备管理软件:<code>Home Assistant</code>,让我们能够能真正掌握拥有智能设备,拥有它,所谓的全屋智能才有了可能.</p><h2 id="homeassistant" class="heading-control">HomeAssistant<a class="heading-anchor" href="#homeassistant" aria-hidden="true"></a></h2><p><img src="./ha.jpg" alt></p><p>HomeAssistant是一个非常聪明的小家伙，它可以通过连接各种<a href="https://www.home-assistant.io/integrations" target="_blank" rel="noopener">厂家设备</a>(截至2021年9月HA已经支持了超过1500个厂家和品牌的设备)和服务来帮助你自动化你的家居生活。它就像是一个家庭管家，可以管理你的灯光、温度、媒体设备等等。你可以告诉它你的喜好，它就会在你需要的时候自动调整，为你提供最舒适的居住体验。</p><p>其次，HomeAssistant非常容易上手，因为它有一个非常友好的用户界面，你甚至不需要太多的技术知识。只要你会点基础的电脑操作，就可以轻松掌握。</p><p>最后，HomeAssistant是一个非常有趣的小伙伴。它可以与你进行对话，让你感觉就像是在跟一个智能机器人交流一样。你可以给它下指令，它就会立刻回应。这真是太酷了！</p><p>所以，如果你想要一个智能家居系统，不妨考虑一下HomeAssistant。它不仅聪明、易用，而且还非常有趣。它会成为你家庭生活中不可或缺的一部分，给你带来更加便利和舒适的居住体验。</p><h2 id="wo-wei-sha-yao-yong-kai-yuan-ha" class="heading-control">我为啥要用开源HA<a class="heading-anchor" href="#wo-wei-sha-yao-yong-kai-yuan-ha" aria-hidden="true"></a></h2><p>自从开始使用<a href="https://www.home-assistant.io/" target="_blank" rel="noopener">Home Assistant</a>(简称<code>HA</code>)1个多月了,陆陆续续买了一些硬件, 在这里把使用过程中碰到的一些坑做个总结,先从HA硬件开始再说软件.</p><p>首先说说目的,我为啥用开源HA,而不是图省事,直接用米家桶或HomeKit,主要目的是希望把硬件掌握在自己手中,而不是厂家手中,不想要厂家来替我开关,这牵涉到:</p><ul><li>必须登陆注册才能使用</li><li>必须与互联网连接才能使用</li><li>安全:外网下厂家可随时操控家中设备，智能音箱随时监听说话，摄像头的所谓遮挡也可以远程打开，家里的电器特别是厨房大功率电器如果被人远程控制干烧还很危险的，生活作息习惯也被人分析,还记得手机上的银行AI人脸识别,背后的员工都看不下去,提醒大家注意着装,别裸.<ul><li><a href="https://www.163.com/dy/article/GE1LD4T905129QAF.html" target="_blank" rel="noopener">App人脸识别不是只拍脸？专家揭秘审核后台能看到啥</a></li><li>使用开源的HA智能家居平台，你可以更加安全地控制自己的设备。由于HomeAssistant是开源的，所有的代码和数据都存储在你自己的设备中，你可以更加掌控自己的数据和隐私。</li></ul></li><li>速度问题,所有设备都要经过网络云上中转下，慢一拍</li><li>断网成智障,不仅如此有的还成废铁</li><li>自动化难以使用,只能适用简单场景,无法根据各家实际情况调整编程,说白了能用只有云上遥控和场景.</li><li>产品实质上掌握在厂家手里,他只要停止服务,产品立马变废铁.方不方便是厂家说了算,你说了不算,不会为你一个人改变.</li><li>软件封闭(非开源)无法审计,HomeKit虽然稍好一点(能够保障离线可用),但实质也一样,HomeKit软件并没有开源,只要软件停止更新,那么等软件在新系统上无法使用,离线也就玩完.</li><li>选择产品范围受到限制:被困于米家桶或HomeKit.<ul><li>使用开源的HA智能家居平台，你可以自由地选择你想要的硬件设备，不受任何厂家的限制。无论是灯光、温度传感器、安防设备，还是音频视频设备，你都可以自由选择符合自己需求的品牌和型号，并且在HomeAssistant平台上进行自由组合和控制。</li></ul></li><li>无法自由地定制和修改设备的控制逻辑.<ul><li>使用开源的HA智能家居平台，你可以自由地定制和修改设备的控制逻辑，满足个性化的需求。HomeAssistant提供了非常强大的自动化和脚本功能，你可以根据自己的需求编写自己的自动化逻辑，并且将不同品牌和型号的设备进行联动。这样，你可以让你的智能家居设备更加符合自己的生活习惯和偏好。</li></ul></li></ul><p>要注意区分产品和服务,产品才是自己的,服务是别人的,是可以随时改变条款的.不要花大价钱,买回一堆服务就成.</p><p>看一些服务的例子(<strong>反面教材</strong>):</p><h4 id="1-ai-yun-zhi-neng-chang-jing-kong-a1" class="heading-control">1. <a href="https://post.smzdm.com/p/751997/" target="_blank" rel="noopener">艾韵智能场景控A1</a><a class="heading-anchor" href="#1-ai-yun-zhi-neng-chang-jing-kong-a1" aria-hidden="true"></a></h4><p><img src="./aiwin.jpg" alt="aiwin.jpg"></p><p>这货其实就是带WIFI的万能红外遥控器,可以通过手机控制它, 但是在它的奇葩实现中，所有的控制消息都要经过厂家的服务器(在互联网上)中转，因此它硬是把好端端的产品变成了服务. 于是不幸的事情发生了,该厂如今已倒闭跑路了，服务器也早已失联，所以原厂功能完全用不了,成了废铁一块。</p><h4 id="2-fei-xun-zhi-neng-ti-zhi-cheng" class="heading-control">2. <a href="https://zhuanlan.zhihu.com/p/31599769" target="_blank" rel="noopener">斐讯智能体脂秤</a><a class="heading-anchor" href="#2-fei-xun-zhi-neng-ti-zhi-cheng" aria-hidden="true"></a></h4><p><img src="./pxScale.jpg" alt="PeiXunScale"></p><p>该秤需要安装APP并注册后才能得到体脂, 但是该厂如今也已倒闭跑路了, 好在设备上还有一个屏幕,于是只能当一个普通的体重称使用(设备上看不到体脂信息).</p><h4 id="3-ge-lei-zhi-neng-yin-xiang" class="heading-control">3. 各类智能音箱<a class="heading-anchor" href="#3-ge-lei-zhi-neng-yin-xiang" aria-hidden="true"></a></h4><p><img src="./popular-smart-speaker.jpg" alt="popular-smart-speaker"></p><p>不用说了全都是服务,根本不算是产品,首先要你注册才能使用,然后必须要能连互联网,你把互联网断开试一试,立马变智障.</p><h4 id="4-xiao-peng-qi-che-bei-pu-tou-tou-cuan-gai-xie-yi-zhong-shen-mian-fei-jiu-yuan-bian-cheng-le-zhi-liang-gu-zhang-jiu-yuan" class="heading-control">4. <a href="https://www.leiphone.com/category/industrynews/i6IOylL2jTWynmua.html" target="_blank" rel="noopener">小鹏汽车被曝偷偷篡改协议：终身免费救援变成了“质量故障”救援</a><a class="heading-anchor" href="#4-xiao-peng-qi-che-bei-pu-tou-tou-cuan-gai-xie-yi-zhong-shen-mian-fei-jiu-yuan-bian-cheng-le-zhi-liang-gu-zhang-jiu-yuan" aria-hidden="true"></a></h4><p>承诺的服务又如何呢,利益面前说变就变,小米还承诺<strong>利润率永远不超5% ，超过部分全退给用户</strong>,现在如何?</p><p>总之, 使用HA，你可以更加自由地选择以及控制自己的智能家居设备，提高生活品质和安全性。</p><p>本着如上的目的, 要想作到设备的完全控制权采购设备就要注意下面几点:</p><ol><li>以Zigbee设备为主: <a href="/article/home-assistant-zigbee">HA智能家居硬件采购避坑指要(一) Zigbee篇</a></li><li>以Wifi设备为辅: <a href="/article/home-assistant-wifi">​HA智能家居硬件采购避坑指要(二) Wifi篇</a></li><li>少量低功耗蓝牙设备: <a href="/article/home-assistant-bluetooth">​HA智能家居硬件采购避坑指要(三) 蓝牙篇</a></li><li>HA盒子还是PC: <a href="/article/home-assistant-box">​HA智能家居硬件采购避坑指要(四) 盒子篇</a></li></ol><p><strong>注意</strong>: <a href="https://www.home-assistant.io/" target="_blank" rel="noopener">Home Assistant</a> 简称 HA, 后面我就用简称了.</p><h2 id="ha-bi-keng-zhi-yao" class="heading-control">HA避坑指要<a class="heading-anchor" href="#ha-bi-keng-zhi-yao" aria-hidden="true"></a></h2><p>如果对Linux/Unix系统不是很熟悉,并且希望体验完整的<code>HA OS</code>体验,那么</p><hr><p>智能家居什么时候能形成既方便又安全的产业链呢，现在小米系列虽然东西比较全了，但是方便上与安全上都不太放心，所有设备都要经过网关或者小爱音箱中转下，慢一拍不说，这两个东西正是不安全的因素，外网下可随时操控家中设备，智能音箱随时监听说话，摄像头的所谓遮挡也可以远程打开，家里的电器特别是厨房大功率电器如果被人远程控制干烧还很危险的，生活作息习惯也被人分析了。。。个人理想中的智能家居应该是内网一套系统+外网一套系统，所有设备都支持内网，同时部分设备兼顾支持外网，内网设备之间用蓝牙mesh私有协议互控，部分需要外网控制的设备同时支持WIFI，WIFI可通过内网系统强行关闭。</p><p>只有开源才能从根上解决,智能硬件就和小电脑一样, 需要一个微型操作系统来控制, 但是目前各个厂家个人搞个人的,不能互通,自然谈不上智能, 软件水平也参差不齐, 用户想安装什么&quot;MCU操作系统&quot;就装什么, 就象PC一样,智能硬件专精硬件本身,而微型控制软件由开源社区项目负责持续改进,人人都审核代码改进功能,这样哪怕公司不在维护,你的硬件也能持续得到支持. 现在这样,真的有智能? 如果是Wifi蓝牙这块不妨看看 ESPHome : 一款开源的智能硬件控制系统, 以及 HomeAssistant 开源的智能中枢软件, 本地记录和控制所有的传感数据和智能设备,支持N多厂家.</p><p>从家用智能来看,总体来说截至到目前(2022-04)不可以. 目前还没有出现真正的智能设备.说是智能产品其实都是服务,都是坑. 具体表现为:<br>必须安装厂家特定的软件,无第三方软件可选.<br>必须联网注册登陆才能使用断网就成智障.<br>智能设备不能自行刷第三方固件,甚至连管理密码都是掌握在厂家手里而不是用户自己手里,请问你觉得这是自己的设备么?<br>不仅仅是蓝牙,包括zigbee以及wifi设备都是如此.<br>当然如果你懂一点IT,而且用的是Zigbee倒是可以通过一些方法绕过.但是蓝牙不行,目前蓝牙协议大多数是各家的私有协议，互通性较差. 只有少数的蓝牙传感器被破译了协议,倒是可以,但是要控制还不行.<br>在加上蓝牙比较耗电,比如米家的温度传感器(LYWSD03MMC)是大约10分钟才发送一次数据,如果不刷第三方固件,想与空调联动就不要想了.<br>而Wifi如果内部用的乐鑫的芯片组(ESP8266/ESP32)是可以通过重刷固件(操作系统)来获取设备的完整控制权,推荐采用 ESPHome 开源固件, 对HomeAssistant的支持也很好.<br>然后你需要的是安装 HomeAssistant 智能中枢软件, 如果是用Zigbee,你还需要购买 Zigbee2MQTT网关设备来代替所谓的小米/绿米多模智能网关(这货只能连接米家的,而且会被厂家控制并不停的上报你的各种只能设备数据) . 这里有一份 Zigbee2MQTT 支持的设备清单: <a href="https://www.zigbee2mqtt.io/supported-devices/" target="_blank" rel="noopener">https://www.zigbee2mqtt.io/supported-devices/</a> 目前支持近2千余种的Zigbee设备.<br>通过 HomeAssistant 智能中枢软件,你才能真正掌控自己的设备,包括在本地记录并控制你自己的各种传感数据而不是被厂家所监控:<br>厂家可随时操控家中设备，智能音箱随时监听说话，IP摄像头的所谓遮挡也可以远程打开，家里的电器特别是厨房大功率电器如果被人远程控制干烧还很危险的，生活作息习惯也被人分析.<br>如此智能设备才不会一断网就成智障设备.<br>普通玩家建议还是别玩,如果是搞IT开发人员那么就别犹豫,上吧.<br>看看HomeAssistant能作些啥: Home Assistant Demo</p><p>​一点点经验教训</p><p>摄像头必须支持ONVIF协议,才能本地控制, ONVIF协议最基本的是支持两路不同分辨率的视频流, 最好支持摄像头和云台控制和事件(这个有的化就可以实现按需拍摄)</p><p>千万别买萤石和乐橙, 尤其是萤石, 萤石是只有私有协议,所有视频流和云台控制都是由厂家云上控制,萤石可以接入HA,但是其实也是厂家云上控制的,视频要给厂家云观赏后才传回本地.乐橙默认也是如此, 乐橙好一点的是支持ONVIF, 但是没法更该设备密码(只能使用厂家的默认安全码),这是个安全问题,如果更改密码,ONVIF就只能使用有线模式(因为乐橙阉割掉了WEB设备控制,大华才有), 而且它的时间配置没有使用NTP Server,而是它自己的服务器(端口10000),一旦它停止服务,时间就不正常了,而且我没找到如果关闭显示的时间戳和乐橙LOGO的选项控制.</p><p>硬盘录像机没必要买,得到视频流后,自己想录就录, HA插件也有现成的比如: <a href="https://frigate.video/" target="_blank" rel="noopener">Frigate NVR</a> 支持AI对象检测和区域设置, 就是对硬件要求比较高.</p><p>从2M支持上来看 支持解锁操作的有 Kwikset 66492-001, ShinaSystem DLM-300Z, Yale YMF30/YDD-D4F0-TSDB/YDF40/YMF40/YDM4109+/YMF40A RL/YRD210-HA-605 …</p><p>但目前的智能锁都是在提供方便而非安全, 而且大多厂家把这个方便掌握在厂家自己手里(远程开门)而不是用户自己控制(非常危险),只有少数的厂家提供解锁了API.</p><p>在我看来,目前还没有真正的能满足即方便又安全的智能锁:安全和方便都是应该是用户自行设置决定的:</p><ol><li>设备密钥应该掌握在用户手里,用户可以随时签发或吊销新密钥</li><li>厂家要想远程开门或者获取门的状态,必须得到用户的授权(通过设备密钥签名,可以设置过期时间)</li><li>用户可以配置开门解锁的组合方式: 可以设置必须指纹和人脸同时匹配成功才能解锁(增强安全性),或者单独一个条件满足即可解锁(提升方便性)</li></ol><p>现在的智能锁,只是增加了一个开门渠道,方便黑客(厂家被破解或厂家内部人员泄密)进入的方式. 这个是方便你我它.</p><p>服务就是服务,产品就是产品,但是现在现状是几乎所有的商家都在把服务当产品宣传销售,混淆产品和服务的界限,这样的商家有任何底线可言? 如果商家坦白说的是我卖的智能门锁服务: 替您开门,让您更方便! 那我无二话.</p><p>编辑<br>Floor-3D For HA</p><p>我在it行业，近期在装修房子，对智能这一块看的比较多，遗憾的是，身边的人或者做全屋智能的商家，能实现的无非就是灯光控制，窗帘控制，音响等，简单的说， 就是遥控器的变相实现</p><p>我设想的全屋智能，至少应该有以下几方面：一，节能<br>1，零冷水，通过人在传感器、无线网络的手机mac地址、智能摄像头等采集各种信息，用相应的逻辑，来控制开启或停止系统，达到节能与方便的统一。<br>2，制冷、制热，与各种传感器互动，控制地暖的开启关闭，制冷的开启关闭，新风的开启关闭等；比如说，房间有人就开启新风，或者感知主人回来，就开启主人书房的新风，如果空气传感器探测到主人书房空气质量非常好，就不开启新风。<br>3、灯光控制，需要的时候开启，不需要的时候关闭。二，方便<br>1，各种联动控制，比如说，观影模式，就直接灯光调整到合适亮度、窗帘关闭，投影机打开等等；<br>2，灯光、窗帘、人在不在等各种智能关联，比如说人离开家，自动拉上窗帘，有个隐私保护，或者默认状态，窗帘都是关闭的，根据自己的喜好。比如说，男主人喜欢亮，那么男主人进书房，就自动打开窗帘或者开灯到最亮。女主人喜欢暗一点，那么女主人进房间，灯光打开就不是最亮档等等。<br>3，最简单的，各种语音控制或者app直接控制等。、三、安全<br>1，各种烟感等传感器，与其他的各种智能设备互动<br>2，人脸识别的安全应用<br>3，监控的联动，比如说监控到有人翻墙到院子，就报警。</p><p>目前,1-3点基本都可以用HA做到本地智能,而所有商家吹嘘的全是远程服务,断网就是全屋智障.</p><p>HA本地智能目前难点在AI这块(那些用PC的豪不在此列),受到嵌入设备的算力限制:</p><ol><li>基于 AI的 本地 TTS</li><li>基于 AI的 本地 语音识别</li><li>基于 AI的 本地 图像(人/物)识别</li></ol><p>当前智能的主要诟病再于无法精确识别各个房间是否有人,以及在做什么. 当然和以前相比现在传感器数据和控制都能通过HA直接掌控(需要选择适当的智能设备,否则你买到的还不会是设备,只是服务,得不到设备的控制权)</p><p>而通过摄像头进行本地 图像(人/物)识别PIR运动传感器甚至能精准到每个房间有多少人. 但是目前家用IP摄像头(其中萤石最糟糕,乐橙稍好些)都是极度的恶劣:想尽办法都想让你的视频传到它的服务器上兜一圈,是因为视频可以卖高价?</p><p>这里我想发表一点儿个人的想法。现在国内对于智能家居或者物联网的概念炒作乌烟瘴气的，看看现在面世的各种产品，好像所谓的智能家居就是可以用远程摄像头看看家里情况，然后可以随时随地用手机控制家中设备，小到开关灯，大到监视温湿度，烟雾报警什么的。直接的体现就是要各种设置，各种在屏幕上点点戳戳。不知道各位觉得怎样，我觉得很累。生活中加入了这样的系统，我不会觉得方便，反而觉得麻烦。这也就是为什么现在所谓的智能家居，并没有普及和很大的市场了吧。因为它们这些根本就不是真的智能家居，叫做传感网络或者是遥控更适合。</p><p>未来所谓的智能家居是应该在尽量不麻烦人，不干扰人正常生活的情况下，默默的在后台运行，可以体察到人的需求而自动进行动作。举个最简单的例子，我并不关心温度湿度的数字和曲线变化，我只关心是否体感舒适，如果系统发现环境不合适了直接动作调整就好了，数字曲线关我鸟事。即便是需要人的命令，自然手势，语音控制这些都比一个APP上好多个页面各种数据和按钮调节条要来得正宗也是需要重点突破的技术。 而且系统和节点的部署需要方便快捷，对用户屏蔽专业的设置，这些都是需要解决的问题。再扯远点儿，上升到理论，那就是我坚信，好的科技是顺应人的自然状态，而不是改变，所谓的 “科技以人为本”。突然好怀念诺基亚。。。。</p><p>实体与 HA Core 交互</p><p>从实体基类集成的集成实体类负责获取数据并处理服务调用。如果禁用了轮询，则它还负责告知 HA 数据何时可用。</p><pre><code class="mermaid">graph TB   EntityRegistry[Entity Registry] --&gt;|Changes to entity registration| Entity   EntityPlatform[Entity Platform] --&gt;|Poll for Update| Entity   EntityRegistry --&gt;|&quot;State&lt;br/&gt;(if no entity object)&quot;| StateMachine[State Machine]   Entity --&gt;|State| StateMachine   ServiceRegistry[Service Registry] --&gt;|&quot;Service Calls&lt;br/&gt;(via entity component/platform)&quot;| Entity</code></pre><p>实体基类（由实体集成定义）负责格式化数据并将其写入状态机。</p><p>实体注册表将为 unavailable 当前未由实体对象支持的任何注册实体写入状态。</p><p>实体数据层次</p><pre><code class="mermaid">graph TB    ConfigEntry --&gt; DeviceRegistryEntry --&gt; EntityRegistryEntry --&gt; Entity</code></pre><p>删除，禁用或重新启用任何对象，下面的所有对象都将进行相应调整。</p><p>什么是实体</p><p>实体注册表（Entity Registry）？我认为是 HA 中智能设备所能划分的最小单元，也可以理解为控制单元，如空气净化器中的温度传感器上报视作一个实体。</p><p>每个实体均有 Unique ID，该ID不能被用户更改，否则造成数据不一致情况。如果一个设备只有一个ID，但提供多个实体，我们可以这样标识 {unique_id}-{sensor_type}。</p><p>切记 Unique ID 必须全局唯一，且不可变，一般用 MAC 地址。</p><p>什么是设备</p><p>什么是设备，设备注册表（Device Registry）？HA 中的设备代表具有自己的控制单元的物理设备，它位于一个特定的地理区域，通常由一个或多个实体表示。举个例子，一台空气净化器是一台设备，它所包含的温度、湿度和PM2.5传感器（控制单元）所暴露的我们可以认为是实体。</p><p>但是一个实体（如温度传感器）如果拆解出来，也可以是一个独立的设备，这里更多的其实就是一个从属关系的划分（设备可以视作实体，实体可以视作设备），具体的实体或设备的划分自行考虑。配置实体、实体、设备之间的关系如下图：</p><pre><code class="mermaid">graph TD  subgraph Components     subgraph ComponentA[Component A]       direction BT       ConfigEntry[Config Entry] --&gt; EntryA[Entry]       ConfigEntry[Config Entry] --&gt; EntryB[Entry]       ConfigEntry2[Config Entry] --&gt; EntryC1[Entry]       ConfigEntry2[Config Entry] --&gt; EntryC2[Entry]     end     subgraph ComponentB[Component B]       ConfigEntryB[Config Entry] --&gt; EntryC3[Entry]     end  end  subgraph Devices     DeviceA --- EntryA     DeviceB --- EntryB     DeviceC --- EntryC1     DeviceC --- EntryC2     DeviceC --- EntryC3  end</code></pre><p>Config Entry 配置了指定的 Entry，该 Entry 可能关联着某个 Device。一个设备通常有如下属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>HA 生成的唯一ID</td></tr><tr><td>name</td><td>设备的名称</td></tr><tr><td>connections</td><td>connetion_type, connection_identifier的集合</td></tr><tr><td>identifiers</td><td>标识符集合，外界的设备识别号，如序列号</td></tr><tr><td>manufacturer</td><td>设备制造商</td></tr><tr><td>model</td><td>设备模型</td></tr><tr><td>suggested_area</td><td>建议设备区域</td></tr><tr><td>config_entries</td><td>联接该设备的实体</td></tr><tr><td>sw_version</td><td>设备防火墙版本</td></tr><tr><td>via_device</td><td>设备与 HA 之间路由消息的设备标识符</td></tr><tr><td>area_id</td><td>区域ID</td></tr><tr><td>entry_type</td><td>实体类型，None 或者 “service”</td></tr></tbody></table><p>通过设备注册表来进行管理。</p><p>什么是区域什么是区域，区域注册表（Area Registry）？区域应该是最好理解的，它用来定义区域，如客厅，卧室A，厨房等，代表了一个具体的物理位置，它可以帮助我们归集和标记设备的具体区域。</p><p>通过区域注册表来进行管理。</p><p>什么是Blueprint<br>蓝图，是可重复使用的自动化，可以轻松共享。您可以从 Github 和社区论坛导入其他用户的 Blueprint。</p><p>什么是自动化其描述很清晰，为智能家居指定自动化规则。即在什么情况下想要使得智能家居做出什么样的反应。</p><p>什么是场景定格一组设备的状态，日后即可一键恢复。也就是说在实际使用过程中，你可能有一个固定的场景或者模式，比如家庭影院。</p><p>什么是脚本执行一系列动作，相当于指定流水线。可以自行考虑考虑</p><p>什么是lovelace<br>相当于是一个主题，你可以在这个主题上做自己的定制。</p><p>目前  AI 一般指神经网络, 多用于语音识别,图像/视频识别. 而神经网络的问题是没法告诉你为什么. 其实最好的AI方式是结合推理机. 推理机执行的是人(专家)自己定义的知识规则库,而不是依据神经网络的统计分析.</p><p>而最早的AI是从推理机开始引申出来专家系统以及适合专家系统开发的语言(比如CLIPS ), 推理分正向推理和反向推理, 它能解释每一个推理步骤的来龙去脉,更适合由物理逻辑推动的场合(比如HA). 然后大家又开始构想更通用的知识管理(比如: Wordnet, wordnet没解决多语互通的问题,各个语言独自为镇)作为推理的基石. 以前的专家系统问题是所有的知识规则都在内存中,没有考虑知识的分类和数据库化,只是面向特定领域的.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;quan-wu-zhi-neng-huan-shi-quan-wu-zhi-neng-zhi-neng-chan-pin-huan-shi-zhi-zhang-chan-pin-fu-wu&quot; class=&quot;heading-control&quot;&gt;全屋智能还是全无智能,智能产品还是智障&amp;quot;产品&amp;quot;(服务)&lt;a class=&quot;heading-anchor&quot; href=&quot;#quan-wu-zhi-neng-huan-shi-quan-wu-zhi-neng-zhi-neng-chan-pin-huan-shi-zhi-zhang-chan-pin-fu-wu&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;要注意区分产品和服务,产品才是自己的,服务是别人的,是可以随时改变条款的. 不要花大价钱,买回一堆服务.&lt;/p&gt;
&lt;h2 id=&quot;yi-dian-fei-hua&quot; class=&quot;heading-control&quot;&gt;一点废话&lt;a class=&quot;heading-anchor&quot; href=&quot;#yi-dian-fei-hua&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;现在越来越多&amp;quot;智能&amp;quot;产品,都要求注册/登陆后才能使用, 这不荒唐么,这是什么产品,还是服务?&lt;/p&gt;
&lt;p&gt;听上去全屋智能高达上,其实只是是换了个词忽悠.你兴匆匆的东看看西看看,这家这个不错,便宜;那家那个功能强,都提全屋智能了,那还不赶紧随便挑.&lt;br&gt;
嘿嘿,那你就想错了,各家是各家的,各家设备彼此是无法直接沟通的,没有互联互通,谈不上智能,唯有智障,弄一大堆按钮铺满在手机上遥控就是智能?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Open Source" scheme="https://riceball.me/categories/Open-Source/"/>
    
      <category term="Hardware" scheme="https://riceball.me/categories/Open-Source/Hardware/"/>
    
      <category term="SmartHome" scheme="https://riceball.me/categories/Open-Source/Hardware/SmartHome/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="iot" scheme="https://riceball.me/tags/iot/"/>
    
      <category term="open source" scheme="https://riceball.me/tags/open-source/"/>
    
      <category term="hardware" scheme="https://riceball.me/tags/hardware/"/>
    
      <category term="smarthome" scheme="https://riceball.me/tags/smarthome/"/>
    
      <category term="homeassistant" scheme="https://riceball.me/tags/homeassistant/"/>
    
      <category term="ha" scheme="https://riceball.me/tags/ha/"/>
    
  </entry>
  
  <entry>
    <title>网摘与知识笔记杂弹</title>
    <link href="https://riceball.me/article/web-clipper/"/>
    <id>https://riceball.me/article/web-clipper/</id>
    <published>2020-07-10T17:39:18.342Z</published>
    <updated>2020-07-11T13:55:56.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wang-zhai-yu-zhi-shi-bi-ji-za-dan" class="heading-control">网摘与知识笔记杂弹<a class="heading-anchor" href="#wang-zhai-yu-zhi-shi-bi-ji-za-dan" aria-hidden="true"></a></h1><h2 id="qian-yan" class="heading-control">前言<a class="heading-anchor" href="#qian-yan" aria-hidden="true"></a></h2><p>忙活了许久，攻克了一个接一个的难关：</p><ul><li>Offline first with P2P</li><li>离线(本机)人机对话界面：尝试取代信息配置界面（目前还是需要二者结合）</li><li>钥匙链的构造规范</li><li>钥匙对（数字印章）代替注册与登录</li><li>公开数据的加密与签名规范与实施（部分）</li><li>P2P数据存储与管理</li><li>基于矢量图（可无极缩放）的家谱树</li><li>离线(本机)人工智能识别人脸与身体</li><li>简易动画相片编辑器（自动移位、缩放动画到人脸或者指定位置）</li></ul><p>眼看我的原型项目就快完成了，结果我栽在了同步上，没错，就是 <code>PouchDB</code> 引以为豪的同步操作，第一次同步没有问题。第二次同步就歇菜，一大堆的冲突错误，但实际上我根本没有增加任何数据，粗步怀疑后续同步必需保存上一次的<code>last_seq</code>的值，这不科学，万一这玩意弄丢了，那不就再也无法同步到服务器了，这太Low了。我还记得，前面发现一个PouchDB的严重错误：在特定情况下（<code>new_edits=false</code>）的<code>bulkDocs</code>函数并不返回操作成功的的数据。然后PouchDB的维护者说，他必需保证和CouchDB的完全一致，<a href="https://github.com/pouchdb/pouchdb/issues/7916#issuecomment-560028271" target="_blank" rel="noopener">CouchDB的Bug也必需在PouchDB完全重现</a>，于是拒绝了我的PR，并关闭了Issue就当bug不存在！这脑洞到底该有多大。给PouchDB缝缝补补也有些时日，算了，累了，趁这个机会换吧，老早想换，因为PouchDB/CouchDB本来就不适合纯P2P（点对点）的存储，也就是人人都是中心的方式，P2P方式更类似于<code>Git</code>，本来考虑到是原型怎么着都无所谓，做做试验，试水一下，忍忍就过去了，但是，直到今天，再也无法忍了，还是一步到位，直接上Git作为存储。在开搞之前，决定写篇文字放松放松。</p><p>以上文字，与我现在要写的文章没有半毛钱关系。</p><a id="more"></a><h2 id="markdown-bi-ji" class="heading-control">Markdown 笔记<a class="heading-anchor" href="#markdown-bi-ji" aria-hidden="true"></a></h2><p>用 <a href="https://zh.wikipedia.org/zh-hans/Markdown" target="_blank" rel="noopener">Markdown</a> 做笔记是一件简单而惬意的事，当然这得在你熟悉它简单的纯文本格式之后。鉴于我喜欢简单的KISS原则，我心目中最理想的笔记就是保存在文件系统中的纯文本文件，没有数据库(真 database-less)，而文件目录就是笔记的分类，用 <a href="https://jekyllrb.com/docs/front-matter/" target="_blank" rel="noopener">front-matter</a> 记录笔记的 meta data（标题, 作者，创作时间，tags…）。</p><p>不提EverNote/Notion这类商业软件(资料首选保存到云端，这明智得无语)。开源并支持<a href="https://zh.wikipedia.org/zh-hans/Markdown" target="_blank" rel="noopener">Markdown</a>笔记软件就非常多了：</p><ul><li><a href="https://joplinapp.org/" target="_blank" rel="noopener">Joplin</a>: <img src="./joplin.png" alt="Joplin"></li><li><a href="https://github.com/0xGG/crossnote" target="_blank" rel="noopener">Cross Note</a>: <img src="./cross-note.png" alt="CrossNote"></li><li><a href="https://getmicropad.com/" target="_blank" rel="noopener">μPad</a>: <img src="./uPad.png" alt="μPad"></li><li><a href="https://www.qownnotes.org/" target="_blank" rel="noopener">QOwnNotes</a>: <img src="./qown-notes.png" alt="QOwnNotes"></li><li><a href="https://zim-wiki.org/" target="_blank" rel="noopener">Zim - A Desktop Wiki</a>: <img src="./zim.png" alt="Zim"></li><li><a href="https://www.giuspen.com/cherrytree/" target="_blank" rel="noopener">Cherry tree</a> (can export as Markdown): <img src="./cherry-tree.png" alt="Cherry tree"></li><li><a href="https://github.com/notable/notable" target="_blank" rel="noopener">Notable</a> - Source Closed since v1.5.1: <img src="./notable.png" alt="Notable"></li><li><a href="https://github.com/gsantner/markor" target="_blank" rel="noopener">Markor</a> - Android 平台超棒的 Markdown 记事本（含代办事宜）: <img src="./markor.png" alt="Markor"></li></ul><p>但是能方便进行网摘的就很少了，不过，可以使用网页转换为Markdown的浏览器插件: <a href="https://github.com/deathau/markdown-clipper" target="_blank" rel="noopener">markdown-clipper</a>，这个Clipper的问题是没保存图像数据。</p><p>目前唯一发现的是<a href="https://joplinapp.org/" target="_blank" rel="noopener">Joplin</a>提供了网摘的浏览器插件，并且可以保存图像数据，同时提供了手机端。<a href="https://joplinapp.org/" target="_blank" rel="noopener">Joplin</a>唯二的问题就是多终端同步冲突容易掉数据，还有就是保存的Markdown文件名称纯是看不懂的UUID，相关meta data是保存在数据库中的。如果再简单一点，用标题作为文件名称，将meta数据放到文章中不香么，对了，还有就是<a href="https://joplinapp.org/" target="_blank" rel="noopener">Joplin</a>的图片资源全混在一个目录下，根本分不清是哪一个文章的。</p><p>最后，我只用到了<a href="https://joplinapp.org/" target="_blank" rel="noopener">Joplin</a>的网摘的浏览器插件: <a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a>，然后撸了一个<a href="https://github.com/snowyu/h2doc.js" target="_blank" rel="noopener">Joplin Web Clipper Server</a>来协同<a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a>保存网摘的文章和图片到本地。这样终于可以愉快的解构了，再也不用上面花里狐骚的记事软件：</p><ul><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a> 文本编辑器负责编辑文稿</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 负责版本管理和数据同步合并</li><li><a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a> 与 <a href="https://github.com/snowyu/h2doc.js" target="_blank" rel="noopener">Joplin Web Clipper Server</a> 协同进行网页摘要</li></ul><h3 id="wang-zhai-yu-markdown" class="heading-control">网摘 与 Markdown<a class="heading-anchor" href="#wang-zhai-yu-markdown" aria-hidden="true"></a></h3><p>网摘 原本只是保存链接地址，但这样的話当网站失效后，内容将无迹可寻，</p><p>结合 <a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a> 与 <a href="https://github.com/snowyu/h2doc.js" target="_blank" rel="noopener">Joplin Web Clipper Server</a> 协同进行网页摘要。</p><p><a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a> 可以对文章全文以及选择部分内容进行提取，然后发送HTML内容到后台进行处理。<br><img src="./joplin-web-clipper.png" alt="joplin-web-clipper"></p><p>使用<a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a>前必需运行<a href="https://joplinapp.org/" target="_blank" rel="noopener">Joplin</a>或者<a href="https://github.com/snowyu/h2doc.js" target="_blank" rel="noopener">Joplin Web Clipper Server</a>。</p><h4 id="joplin-web-clipper-server" class="heading-control"><a href="https://github.com/snowyu/h2doc.js" target="_blank" rel="noopener">Joplin Web Clipper Server</a><a class="heading-anchor" href="#joplin-web-clipper-server" aria-hidden="true"></a></h4><p><a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a>与后端通讯只用到<a href="https://joplinapp.org/api/" target="_blank" rel="noopener">Joplin REST API</a>其中的4个API:</p><ul><li>ping</li><li>Get Folders</li><li>Get Tags</li><li>Post Note</li></ul><p>看上去挺简单的吧，感觉是一天可以搞定到事情，却耗费了我整5天的时间。</p><p><a href="https://github.com/snowyu/h2doc.js" target="_blank" rel="noopener">Joplin Web Clipper Server</a>要求使用的文件夹中至少存在一个子目录。</p><h5 id="an-zhuang" class="heading-control">安装<a class="heading-anchor" href="#an-zhuang" aria-hidden="true"></a></h5><p>一个命令行程序，没啥安装的。如果已经安装了<a href="https://nodejs.org/" target="_blank" rel="noopener">Nodejs@12</a> 以上版本，那么直接用 <code>npm</code> or <code>yarn</code> 安装：</p><pre><code class="bash"><span class="hljs-comment"># yarn global add h2doc@alpha</span>npm i -g h2doc@alpha</code></pre><p>如果懒得安装 <a href="https://nodejs.org/" target="_blank" rel="noopener">Nodejs@12</a> ，那么这里提供了常见平台到压缩包供下载：<a href="https://github.com/snowyu/h2doc.js/releases" target="_blank" rel="noopener">H2DOC 发布包下载</a>.</p><h5 id="gong-neng" class="heading-control">功能<a class="heading-anchor" href="#gong-neng" aria-hidden="true"></a></h5><h6 id="server-ming-ling" class="heading-control">server 命令<a class="heading-anchor" href="#server-ming-ling" aria-hidden="true"></a></h6><p>功能如下：</p><ul><li>转换 HTML 内容为 Markdown 格式</li><li>下载 HTML 内容中的图像资产</li><li>一个文件夹就是一个 notebook.</li><li>保存转换后的 Markdown 文件及图像到指定到文件夹(<code>root</code>)</li><li>设置存储的文件名和图像资产目录名规则:<ol><li>可将网摘的图像资产目录名设置成和网摘 markdown 文件名称相同（不包括扩展名），以<code>title</code>作为名称。<ul><li>markdown file: <code>${folder}/${title}.md</code></li><li>markdown assets folder: <code>${folder}/${title}/</code></li><li>markdown assets base file name: <code>${assetBaseName}</code></li></ul></li><li>也可将网摘markdown文件和它的图像资产放在同一目录中, 用 <code>index|README.md</code> 作为网摘markdown文件名<ul><li>markdown file: <code>${folder}/${title}/index.md</code></li><li>markdown assets folder: <code>${folder}/${title}/</code></li><li>markdown assets base file name: <code>${assetBaseName}</code></li></ul></li><li>you can customize by yourself</li></ol></li></ul><p>可供使用的变量和函数如下：</p><ul><li><code>folder</code>: 目录名称，相对于<code>root</code>目录 (来自<a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a>的notebook选项)</li><li><code>title</code>: 标题,(来自<a href="https://joplinapp.org/clipper/" target="_blank" rel="noopener">Joplin Web Clipper</a>的 title 选项)</li><li><code>assetBaseName</code>: 图像资产的文件名 (不含扩展名)</li><li><code>date</code>: ISO 格式的日期时间</li><li><code>index</code>: 当前资产图像的序号.</li><li><code>slug</code> : 根据标题语言，智能将标题转为可供url使用的字符串，参见<code>toSlug</code>函数。</li><li><code>shortid()</code>: 该函数返回一个唯一id.</li><li><code>toSlug(str)</code>: 该函数将字符串 <code>str</code> 转换为一个智能 slug，例如:<ul><li><code>toSlug('i ♥ latin')</code> 结果是 ‘i-love-latin’</li><li><code>toSlug('我爱官话')</code> 结果是 ‘wo3-ai4-guan1-hua4’</li><li><code>toSlug('Я люблю русский')</code> 结果是 ‘ya-lyublyu-russkij’</li></ul></li></ul><p>上述功能只能在配置文件中设置（详细设置见后述）。</p><p>目前也就这个功能了。执行 <code>h2doc server [your-dir]</code>即可，如果不带 <code>[your-dir]</code> 就使用当前工作目录。</p><pre><code class="bash">h2doc server [your-dir]</code></pre><p>要想停止就按<code>Ctrl+C</code>键。</p><p><strong>配置文件</strong></p><p>配置文件的存放位置为(按照优先顺序排列)：</p><ol><li>工作目录（启动设定的root目录）下</li><li>用户主目录下</li><li>应用所在目录下(<code>/$APP/config/</code>)</li></ol><p>配置文件可以使用<a href="https://zh.wikipedia.org/zh/YAML" target="_blank" rel="noopener">yaml</a>格式或者<a href="https://zh.wikipedia.org/zh-hans/JSON" target="_blank" rel="noopener">json</a>格式。</p><p>配置文件名为 <code>.md-config.(yaml|json)</code> 或 <code>md-config.(yaml|json)</code>.</p><p>配置文件的内容解释如下：</p><pre><code class="yml"><span class="hljs-attr">output:</span> <span class="hljs-comment"># 输出内容配置</span>  <span class="hljs-attr">root:</span> <span class="hljs-string">~/Documents/my-clip</span> <span class="hljs-comment"># 保存markdown文件的位置</span>  <span class="hljs-attr">exclude:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules</span>          <span class="hljs-comment"># 排除的目录，不作为 notebook 显示和存储。</span>  <span class="hljs-attr">deep:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 允许的子目录嵌套的最大深度</span>  <span class="hljs-attr">markdown:</span> <span class="hljs-string">${folder}/${title}.md</span> <span class="hljs-comment"># 网摘markdown文件名称和位置</span>  <span class="hljs-attr">asset:</span> <span class="hljs-string">${folder}/${title}/</span>      <span class="hljs-comment"># 网摘的图片资产目录名称</span>  <span class="hljs-attr">assetBaseName:</span> <span class="hljs-string">${assetBaseName}</span> <span class="hljs-comment"># 网摘的图片资产文件基本名称，不含扩展名</span><span class="hljs-attr">slug:</span> <span class="hljs-comment"># 智能 slug 参数对象或字符串，如果是字符串就是分隔符的设置</span>  <span class="hljs-attr">separator:</span> <span class="hljs-string">'-'</span> <span class="hljs-comment"># 分隔符设定，将空白字符替换为分隔符默认为 "-"</span>  <span class="hljs-attr">lang:</span> <span class="hljs-string">''</span> <span class="hljs-comment"># 设置语言代码：ISO 639-1 two-letter language code, 默认为空时为自动检测语言</span>  <span class="hljs-attr">tone:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否给拼音加上音调，默认为 true</span>  <span class="hljs-attr">separateNumbers:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否分隔数字，默认为 false</span>  <span class="hljs-attr">maintainCase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 保留大小写，默认为 false</span><span class="hljs-attr">download:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否下载图片资产，默认为 true</span><span class="hljs-attr">format:</span> <span class="hljs-comment"># HTML 转 Markdown 的配置信息（注意：未来可能有所调整，不是所有参数都有效）</span>  <span class="hljs-attr">headingStyle:</span> <span class="hljs-string">'atx'</span> <span class="hljs-comment"># 'setext' or 'atx'</span>  <span class="hljs-attr">hr:</span> <span class="hljs-string">'---'</span>  <span class="hljs-comment"># 水平分隔线</span>  <span class="hljs-attr">bulletListMarker:</span> <span class="hljs-string">'*'</span> <span class="hljs-comment"># 无序列表</span>  <span class="hljs-attr">codeBlockStyle:</span> <span class="hljs-string">'fenced'</span> <span class="hljs-comment"># 代码块类型 'indented' or 'fenced'</span>  <span class="hljs-attr">fence:</span> <span class="hljs-string">'```'</span> <span class="hljs-comment"># ``` or ~~~</span>  <span class="hljs-attr">emDelimiter:</span> <span class="hljs-string">'_'</span> <span class="hljs-comment"># _ or *</span>  <span class="hljs-attr">strongDelimiter:</span> <span class="hljs-string">'**'</span> <span class="hljs-comment"># ** or __</span>  <span class="hljs-attr">linkStyle:</span> <span class="hljs-string">'inlined'</span> <span class="hljs-comment"># inlined or referenced</span>  <span class="hljs-attr">linkReferenceStyle:</span> <span class="hljs-string">'full'</span> <span class="hljs-comment"># full, collapsed, or shortcut</span>  <span class="hljs-attr">gfw:</span>    <span class="hljs-attr">strikethrough:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># for converting &lt;strike&gt;, &lt;s&gt;, and &lt;del&gt; elements</span>    <span class="hljs-attr">tables:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">taskListItems:</span> <span class="hljs-literal">true</span><span class="hljs-attr">frontMatter:</span> <span class="hljs-comment"># frontMatter输出的配置对象, 是否使用 front matter，以及包括那些meta信息</span>  <span class="hljs-attr">title:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">url:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">author:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">publisher:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">lang:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">description:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">image:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">video:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">audio:</span> <span class="hljs-literal">true</span></code></pre><h6 id="autocomplete-ming-ling" class="heading-control">autocomplete 命令<a class="heading-anchor" href="#autocomplete-ming-ling" aria-hidden="true"></a></h6><p>shell下命令自动补全</p><p>执行 <code>h2doc autocomplete</code> 按照提示操作即可。</p><pre><code class="bash">❯ h2doc autocompleteBuilding the autocomplete cache... <span class="hljs-keyword">done</span>Setup Instructions <span class="hljs-keyword">for</span> H2DOC CLI Autocomplete ---1) Add the autocomplete env var to your zsh profile and <span class="hljs-built_in">source</span> it$ <span class="hljs-built_in">printf</span> <span class="hljs-string">"<span class="hljs-variable">$(h2doc autocomplete:script zsh)</span>"</span> &gt;&gt; ~/.zshrc; <span class="hljs-built_in">source</span> ~/.zshrcNOTE: After sourcing, you can run `$ compaudit -D` to ensure no permissions conflicts are present2) Test it out, e.g.:$ h2doc &lt;TAB&gt;                 <span class="hljs-comment"># Command completion</span>$ h2doc <span class="hljs-built_in">command</span> --&lt;TAB&gt;       <span class="hljs-comment"># Flag completion</span>Enjoy!</code></pre><hr><h3 id="nao-tu-yu-markdown" class="heading-control">脑图 与 Markdown<a class="heading-anchor" href="#nao-tu-yu-markdown" aria-hidden="true"></a></h3><p>脑图不过是另类的大纲，用Markdown写大纲，不是更简单快捷，然后,要脑图还不简单，try:</p><p><a href="https://markmap.js.org/repl/" target="_blank" rel="noopener"><img src="./markmap.png" alt="markmap"></a></p><p>至于用Markdown写幻灯片(SlideShow),<img src="./md-slideshow.png" alt="md-slideshow"></p><p>嵌入流程图，<img src="https://github.com/mjbvz/vscode-markdown-mermaid/raw/master/docs/example.png" alt="markdown-mermaid"></p><p>数学公式，<img src="https://cloud.githubusercontent.com/assets/1908863/14398210/0e408954-fda8-11e5-9eb4-562d7c0ca431.gif" alt="md-math"></p><p>更是不再话夏。</p><h3 id="markdown-yu-vscode" class="heading-control">Markdown 与 VSCode<a class="heading-anchor" href="#markdown-yu-vscode" aria-hidden="true"></a></h3><p>毋庸置疑，VSCode是非常好用的编辑器，通过各式插件，可以玩出花来。</p><p>安装插件方法：进入VSCode, 按下<code>ctrl+P</code>，然后输入 <code>ext install</code> + <code>插件名称</code> 后，按下回车即可，例如, 安装流程图支持的markdown 插件: “ext install bierner.markdown-mermaid”。</p><p><img src="./vscode-outline.png" alt="vscode-outline"><br>VSCode 自带大纲显示和导航。再装上如下的插件(当心：多图杀🐈️猫)，就是一个专业的Markdown编辑器。</p><ul><li>holmescn.vscode-wordcount-cjk: 在状态栏上显示文章的字数。</li><li>bierner.markdown-emoji:<ul><li><img src="./markdown-emoji.png" alt="markdown-emoji"></li></ul></li><li>darkriszty.markdown-table-prettify:<ul><li><img src="https://github.com/darkriszty/MarkdownTablePrettify-VSCodeExt/raw/master/assets/animation.gif" alt="darkriszty.markdown-table-prettify"></li></ul></li><li>alefragnani.Bookmarks:<ul><li><img src="https://github.com/alefragnani/vscode-bookmarks/raw/master/images/printscreen-select-lines.gif" alt="Bookmarks"></li></ul></li><li>bierner.markdown-mermaid:<ul><li><img src="https://github.com/mjbvz/vscode-markdown-mermaid/raw/master/docs/example.png" alt="mermaid"></li></ul></li><li>bpruitt-goddard.mermaid-markdown-syntax-highlighting:<ul><li><img src="https://raw.githubusercontent.com/bpruitt-goddard/vscode-mermaid-syntax-highlight/master/images/graph.png" alt="mermaid-markdown-syntax-highlighting"></li></ul></li><li>Compulim.vscode-chinese-translation:<ul><li><img src="https://raw.githubusercontent.com/compulim/vscode-chinese-translation/master/demo.gif" alt="vscode-chinese-translation"></li></ul></li><li>docsmsft.docs-authoring-pack: 包含下面一系列的插件，装了这个，下面的就不用装了<ul><li>docsmsft.docs-article-templates: markdown 模板(目前对大小写区分的文件系统存在问题)<ul><li><img src="https://github.com/Microsoft/vscode-docs-authoring/raw/master/media/video/apply-template.gif" alt="docs-article-templates"></li></ul></li><li>docsmsft.docs-images:<ul><li><img src="https://raw.githubusercontent.com/microsoft/vscode-docs-authoring/master/docs-images/images/right-click-image-compression.png" alt="docs-images"></li></ul></li><li>docsmsft.docs-linting</li><li>docsmsft.docs-markdown: 可以在状态栏上显示Markdown格式的工具栏，或者用(Alt+M 呼唤)<ul><li><img src="https://github.com/Microsoft/vscode-docs-authoring/raw/master/media/video/extension-demo.gif" alt="docs-markdown"></li></ul></li><li>docsmsft.docs-metadata</li><li>docsmsft.docs-preview</li><li>docsmsft.docs-yaml</li><li>blackmist.LinkCheckMD: 失效链接检查。<ul><li><img src="https://github.com/microsoft/linkcheckermd/raw/master/images/working.gif" alt="LinkCheckMD"></li></ul></li><li>DavidAnson.vscode-markdownlint: markdown 格式的语法检查</li><li>streetsidesoftware.code-spell-checker: 单词拼写检查(可惜没有中文词库，默认带的是英文)</li></ul></li><li>fabiospampinato.vscode-todo-plus: 让管理Todo(代办事宜)类别更容易。<strong>推荐</strong><ul><li><img src="https://github.com/fabiospampinato/vscode-todo-plus/raw/master/resources/demo/syntax.png" alt="vscode-todo-plus"></li></ul></li><li>jsynowiec.vscode-insertdatestring: 插入当前日期时间</li><li>kisstkondoros.vscode-gutter-preview: 可以在右边指示器直接显示图片预览，以及鼠标预览图片 <strong>必装</strong><ul><li><img src="https://raw.githubusercontent.com/kisstkondoros/gutter-preview/master/images/sample.png" alt="vscode-gutter-preview"></li></ul></li><li>kortina.vscode-markdown-notes: <strong>必装</strong><ul><li><img src="https://github.com/kortina/vscode-markdown-notes/raw/master/demo/create-note-on-missing-go-to-definition.gif" alt="vscode-markdown-notes"></li></ul></li><li>shd101wyy.markdown-preview-enhanced: <strong>必装</strong><ul><li>如果想用它做文档导出，请参看它的文档: <a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">markdown-preview-enhanced文档</a></li><li><img src="https://user-images.githubusercontent.com/1908863/28495106-30b3b15e-6f09-11e7-8eb6-ca4ca001ab15.png" alt="markdown-preview-enhanced"></li></ul></li><li>tchayen.markdown-links: markdown-notes的最佳搭档<ul><li><img src="https://github.com/tchayen/markdown-links/raw/master/demo.gif" alt="markdown-links"></li></ul></li><li>telesoho.vscode-markdown-paste-image: 直接复制图像(ctrl+alt+v)并保存</li><li>yzhang.markdown-all-in-one: 键盘快捷，TOC，列表编辑… <strong>必装</strong><ul><li><img src="https://github.com/yzhang-gh/vscode-markdown/raw/master/images/gifs/toggle-bold.gif" alt="markdown-all"></li></ul></li><li>oderwat.indent-rainbow: 对不同层次的缩进显示不同颜色.<ul><li><img src="https://raw.githubusercontent.com/oderwat/vscode-indent-rainbow/master/assets/example.png" alt="indent-rainbow"></li></ul></li><li>redhat.vscode-yaml</li><li>eliostruyf.vscode-front-matter:<ul><li><img src="https://github.com/estruyf/vscode-front-matter/raw/master/assets/create-tag-category.gif" alt="vscode-front-matter"></li></ul></li><li>donjayamanne.githistory: 查看某个文件的版本历史. <strong>GIT必装</strong><ul><li><img src="https://raw.githubusercontent.com/DonJayamanne/gitHistoryVSCode/master/images/gitLogv3.gif" alt="githistory"></li></ul></li><li>eamodio.gitlens: 在文件内显示（灰色小字）每一处变更发生的时间和提交者 <strong>GIT必装</strong><ul><li><img src="https://raw.githubusercontent.com/eamodio/vscode-gitlens/master/images/docs/gitlens-preview.gif" alt="gitlens"></li></ul></li><li>softwaredotcom.swdc-vscode: 这货可以统计你在vscode上花费的时间.<ul><li><img src="https://swdc-vscode.s3-us-west-1.amazonaws.com/code-time-features.png" alt="Code Time"></li></ul></li><li>Shan.code-settings-sync: 可以将您的配置和安装的插件信息同步到<code>gist</code>. 最新的Code-insiders测试版本已内置支持。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;wang-zhai-yu-zhi-shi-bi-ji-za-dan&quot; class=&quot;heading-control&quot;&gt;网摘与知识笔记杂弹&lt;a class=&quot;heading-anchor&quot; href=&quot;#wang-zhai-yu-zhi-shi-bi-ji-za-dan&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;qian-yan&quot; class=&quot;heading-control&quot;&gt;前言&lt;a class=&quot;heading-anchor&quot; href=&quot;#qian-yan&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;忙活了许久，攻克了一个接一个的难关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Offline first with P2P&lt;/li&gt;
&lt;li&gt;离线(本机)人机对话界面：尝试取代信息配置界面（目前还是需要二者结合）&lt;/li&gt;
&lt;li&gt;钥匙链的构造规范&lt;/li&gt;
&lt;li&gt;钥匙对（数字印章）代替注册与登录&lt;/li&gt;
&lt;li&gt;公开数据的加密与签名规范与实施（部分）&lt;/li&gt;
&lt;li&gt;P2P数据存储与管理&lt;/li&gt;
&lt;li&gt;基于矢量图（可无极缩放）的家谱树&lt;/li&gt;
&lt;li&gt;离线(本机)人工智能识别人脸与身体&lt;/li&gt;
&lt;li&gt;简易动画相片编辑器（自动移位、缩放动画到人脸或者指定位置）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;眼看我的原型项目就快完成了，结果我栽在了同步上，没错，就是 &lt;code&gt;PouchDB&lt;/code&gt; 引以为豪的同步操作，第一次同步没有问题。第二次同步就歇菜，一大堆的冲突错误，但实际上我根本没有增加任何数据，粗步怀疑后续同步必需保存上一次的&lt;code&gt;last_seq&lt;/code&gt;的值，这不科学，万一这玩意弄丢了，那不就再也无法同步到服务器了，这太Low了。我还记得，前面发现一个PouchDB的严重错误：在特定情况下（&lt;code&gt;new_edits=false&lt;/code&gt;）的&lt;code&gt;bulkDocs&lt;/code&gt;函数并不返回操作成功的的数据。然后PouchDB的维护者说，他必需保证和CouchDB的完全一致，&lt;a href=&quot;https://github.com/pouchdb/pouchdb/issues/7916#issuecomment-560028271&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CouchDB的Bug也必需在PouchDB完全重现&lt;/a&gt;，于是拒绝了我的PR，并关闭了Issue就当bug不存在！这脑洞到底该有多大。给PouchDB缝缝补补也有些时日，算了，累了，趁这个机会换吧，老早想换，因为PouchDB/CouchDB本来就不适合纯P2P（点对点）的存储，也就是人人都是中心的方式，P2P方式更类似于&lt;code&gt;Git&lt;/code&gt;，本来考虑到是原型怎么着都无所谓，做做试验，试水一下，忍忍就过去了，但是，直到今天，再也无法忍了，还是一步到位，直接上Git作为存储。在开搞之前，决定写篇文字放松放松。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thinking" scheme="https://riceball.me/categories/Thinking/"/>
    
      <category term="Knowledge" scheme="https://riceball.me/categories/Thinking/Knowledge/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="knowledge" scheme="https://riceball.me/tags/knowledge/"/>
    
      <category term="web clip" scheme="https://riceball.me/tags/web-clip/"/>
    
      <category term="note" scheme="https://riceball.me/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>OpenPGP 密钥(GnuPG软件)安全随笔</title>
    <link href="https://riceball.me/article/gpg/"/>
    <id>https://riceball.me/article/gpg/</id>
    <published>2019-11-26T17:27:00.000Z</published>
    <updated>2019-11-26T17:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>GnuPG软件（简称GPG） – OpenPGP</p><h1 id="li-shi-jie-shao-history" class="heading-control">历史介绍 History<a class="heading-anchor" href="#li-shi-jie-shao-history" aria-hidden="true"></a></h1><h2 id="pgp-pretty-good-privacy" class="heading-control">PGP (Pretty Good Privacy)<a class="heading-anchor" href="#pgp-pretty-good-privacy" aria-hidden="true"></a></h2><p>最早是由PGP Inc.公司拥有原始的PGP加密软件的版权，后来它被赛门铁克公司（Symantec Corp.）收购。后续由赛门铁克公司继续开发维护PGP品牌。</p><h2 id="openpgp" class="heading-control">OpenPGP<a class="heading-anchor" href="#openpgp" aria-hidden="true"></a></h2><p>Zimmerman(最早的PGP开发人员)于1997年向IETF（互联网工程任务组）提交了<a href="https://tools.ietf.org/html/rfc4880" target="_blank" rel="noopener">开源PGP（OpenPGP）标准提案</a>。如今，OpenPGP成为了PGP的标准规范，是供公众使用的开源代码，并且该术语可用于描述支持OpenPGP系统的任何程序。</p><h2 id="gpg-gnu-privacy-guard" class="heading-control">GPG (GNU Privacy Guard)<a class="heading-anchor" href="#gpg-gnu-privacy-guard" aria-hidden="true"></a></h2><p>GnuPGP由Werner Koch开发的开源加密工具软件，并于1999年发布，以替代现有的Symantec加密工具软件套件。 它可以免费下载，并且基于IETF建立的OpenPGP标准，因此可以与Symantec的PGP工具和支持OpenPGP标准的软件互操作。GPG可以打开和解密任何PGP和OpenPGP标准的文件。</p><h2 id="keys" class="heading-control">Keys<a class="heading-anchor" href="#keys" aria-hidden="true"></a></h2><p>在公开密钥算法中，一个Key(密钥)包括两个部分：公钥和私钥。公钥类似于印鉴，而私钥类似于印章。</p><h2 id="subkeys" class="heading-control"><a href="https://wiki.debian.org/Subkeys" target="_blank" rel="noopener">Subkeys</a><a class="heading-anchor" href="#subkeys" aria-hidden="true"></a></h2><p>在OpenPGP标准中你的钥匙包括一个主钥(master key)和若干子钥(subkeys)。在OpenPGP标准中主钥，子钥(Subkey)是必需理解，非常关键的概念，可以极大的提升安全性。</p><ul><li>主钥的主要作用是用于签发和吊销其它密钥、签名或用户Id，从安全角度考虑，主钥的私钥应该完全保持离线。</li><li>子钥：根据设置用途可以用于加密或签名，一旦子钥泄密可以用主钥吊销该子钥。<ul><li>GPG会随机选择用于加密或签名(GPG默认策略会挑选钥匙size最大的，以及创建时间最近的)。</li></ul></li></ul><p>而就内部结构上看，子钥和主钥没啥不同的，只是PacketId上有差别，另外子钥要求有绑定主钥的签名包（见后面描述Binding Signatures）。</p><ul><li>Public-Subkey Packet Tag 是 14</li><li>Secret-Subkey Packet Tag 是 7</li></ul><h3 id="subkey-usage" class="heading-control">Subkey Usage<a class="heading-anchor" href="#subkey-usage" aria-hidden="true"></a></h3><p>OpenPGP subkeys 用于不同的设想：</p><ul><li>可以保持主键始终处于离线安全状态，您的主键不需要存放在线上(online)，可以只存放在本地的安全设备上。一旦有子键泄露，可以立刻使用主键轻松的吊销该子键，而没有撤销主键的麻烦（需要再次分享新的键,获取新的签名…）。Being able to store the primary key offline or a more secure device. If a machine with a subkey is harmed, you can easily revoke the subkey without all the hassles of revoking your primary key (sharing a new key, getting new signatures, …).</li><li>可以在不同的机器上使用不同的子键。例如在构建服务器上使用单独的子键。记住，吊销单独的子键非常容易。Having different subkeys on different machines, for example a signing subkey on a build server. Again, revoking single keys is easy.</li><li>使用较大尺寸的密钥作为主键长时间使用，而使用短而快速的子键，可以每天一换。Using a larger primary key for long lifetime, and shorter, but faster subkeys for day-to-day usage.</li><li>某些算法不能同时支持加密和签名，例如: DSA 主密钥只能签名，因此它需要另一个密钥来加密，通常DSA与ElGamal算法成对使用。Some algorithms do not support both encrypting and signing. For example, a DSA primary key requires another key for encryption, typically paired with ElGamal.</li></ul><h3 id="binding-signatures" class="heading-control">Binding Signatures<a class="heading-anchor" href="#binding-signatures" aria-hidden="true"></a></h3><p>There are special signature subtypes to bind subkeys to primary keys (and vice verse), listed in <a href="http://tools.ietf.org/html/rfc4880#section-5.2.1" target="_blank" rel="noopener">RFC 4880, OpenPGP, 5.2.1 Signature Types</a>:</p><p>0x18: Subkey Binding Signature</p><p>This signature is a statement by the top-level signing key that indicates that it owns the subkey. This signature is calculated directly on the primary key and subkey, and not on any User ID or other packets. A signature that binds a signing subkey MUST have an Embedded Signature subpacket in this binding signature that contains a 0x19 signature made by the signing subkey on the primary key and subkey.</p><p>0x19: Primary Key Binding Signature</p><p>This signature is a statement by a signing subkey, indicating that it is owned by the primary key and subkey. This signature is calculated the same way as a 0x18 signature: directly on the primary key and subkey, and not on any User ID or other packets.</p><p>OpenPGP 更进一步的支持 <code>subkeys</code>, 它像普通的钥匙,但 subkeys 是和一个 master 钥匙绑定的，子钥 可以用于签名或加密。子钥可以独立于主钥匙进行撤销和存放。</p><p>换句话说，子钥像单独的钥匙对，但是自动与您的主钥匙关联。</p><p>GnuPG 实际上用一个签名(signing-only)钥匙作为主钥匙。然后自动创建了一个用于加密的子钥。 Without a subkey for encryption, you can’t have encrypted e-mails with GnuPG at all. Debian requires you to have the encryption subkey so that certain kinds of things can be e-mailed to you safely, such as the initial password for your <a href="http://debian.org" target="_blank" rel="noopener">debian.org</a> shell account.</p><p>主钥仅当在以下情况下才被使用：</p><ul><li>when you sign someone else’s key or revoke an existing signature,</li><li>when you add a new UID or mark an existing UID as primary,</li><li>when you create a new subkey,</li><li>when you revoke an existing UID or subkey,</li><li>when you change the preferences (e.g., with setpref) on a UID,</li><li>when you change the expiration date on your master key or any of its subkey, or</li><li>when you revoke or generate a revocation certificate for the complete key.</li></ul><p>看 openpgpjs 的代码，好像可以独立使用subkey,但是必须存在 master key的公钥。</p><pre><code class="bash">gpg --<span class="hljs-built_in">help</span>gpg --gen-keygpg --expert --gen-key <span class="hljs-comment"># 可以打开ECC等其它加密算法的支持, or --full-gen-key</span>　　gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.　　This is free software: you are free to change and redistribute it.　　There is NO WARRANTY, to the extent permitted by law.　　请选择您要使用的密钥种类：　　　(1) RSA and RSA (default)　　　(2) DSA and Elgamal　　　(3) DSA (仅用于签名)　　　　(4) RSA (仅用于签名)　　您的选择？<span class="hljs-comment"># 生成一张"撤销证书"，以备以后密钥作废时，可以请求外部的公钥服务器撤销你的公钥。</span>gpg --gen-revoke [用户ID]gpg --list-keys --list-options show-keyring/home/XXX/.gnupg/pubring.kbx---------------------------------pub   rsa4096 2016-10-05 [SC]      72ECF46A56B4AD39C907BBB71646B01B86E50310uid           [ unknown] Yarn Packaging &lt;yarn@dan.cx&gt;sub   rsa4096 2016-10-05 [E]sub   rsa4096 2016-10-05 [S] [expires: 2017-10-05]sub   rsa4096 2016-10-30 [S]pub   rsa4096 2017-04-17 [SC]      EAD16A2C6AE2C4C70344D76855C2BF1FD36EBB60uid           [ultimate] Riceball LEE &lt;snowyu.lee@gmail.com&gt;sub   rsa4096 2017-04-17 [E]<span class="hljs-comment"># 输出密钥,armor参数可以将其转换为ASCII码显示。</span>gpg --armor --output public-key.txt --<span class="hljs-built_in">export</span> [用户ID]gpg --armor --output private-key.txt --<span class="hljs-built_in">export</span>-secret-keys<span class="hljs-comment"># 上传公钥 公钥服务器是网络上专门储存用户公钥的服务器</span>gpg --send-keys [用户ID]<span class="hljs-comment"># 除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用import参数。</span>gpg --import [密钥文件]<span class="hljs-comment"># 为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找。</span>gpg --search-keys [用户ID]<span class="hljs-comment"># encrypt参数用于加密。</span>gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt<span class="hljs-comment"># 解密 GPG允许省略decrypt参数。</span>gpg --decrypt demo.en.txt --output demo.de.txt<span class="hljs-comment"># 对文件签名 当前目录下生成demo.txt.gpg文件 -a 将为ascii armored 输出 demo.txt.asc</span><span class="hljs-comment"># -o demo.txt.sig 自定义输出文件名</span>gpg --detach-sig demo.txt<span class="hljs-comment"># 生成ASCII码的签名文件</span>gpg --clearsign demo.txt<span class="hljs-comment">#  验证签名</span>gpg --verify demo.txt.asc demo.txt<span class="hljs-comment"># 增加 subkey 启用 ECC 支持</span>gpg --expert --edit-key YOURMASTERKEYIDgpg&gt; addkey  Please select what kind of key you want:    (3) DSA (sign only)    (4) RSA (sign only)    (5) Elgamal (encrypt only)    (6) RSA (encrypt only)    (7) DSA (<span class="hljs-built_in">set</span> your own capabilities)    (8) RSA (<span class="hljs-built_in">set</span> your own capabilities)    (10) ECC (sign only)    (11) ECC (<span class="hljs-built_in">set</span> your own capabilities)    (12) ECC (encrypt only)    (13) Existing key  Your selection? 10  Please select <span class="hljs-built_in">which</span> elliptic curve you want:    (1) Curve 25519    (3) NIST P-256    (4) NIST P-384    (5) NIST P-521    (6) Brainpool P-256    (7) Brainpool P-384    (8) Brainpool P-512    (9) secp256k1  Your selection? 9gpg&gt; save</code></pre><h3 id="dao-chu-mi-yue" class="heading-control">导出密钥<a class="heading-anchor" href="#dao-chu-mi-yue" aria-hidden="true"></a></h3><p>应用签名等需要。</p><p><code>openpgp2ssh</code> 测试成功，其余失败,搞定。</p><pre><code class="bash">sudo apt install monkeysphere<span class="hljs-comment"># 弄之前先解密需要导出的密钥</span><span class="hljs-comment"># 10F15E84852CB868 是subkey的id,可以用 gpg --list-keys 看到</span>gpg --<span class="hljs-built_in">export</span>-secret-subkeys youmasterid@gmail.com | openpgp2ssh 10F15E84852CB868 &gt; id_rsaopenssl rsa -<span class="hljs-keyword">in</span> id_rsa -outform pem &gt; key.pem<span class="hljs-comment"># 将子密钥转为 pkcs8 格式。</span>openssl pkcs8 -topk8 -outform DER -<span class="hljs-keyword">in</span> key.pem -inform PEM -out key.pk8 -nocrypt<span class="hljs-comment"># 产生请求签名的证书文件,发给签名方签名形成签名证书。</span>openssl req -new -key key.pem -out request.pem<span class="hljs-comment"># 签名方进行签名，产生签名证书。</span><span class="hljs-comment"># 这样一来变成了自签名的，而不是主钥签名的。如果要主钥签名，首先得导出主钥。</span>openssl x509 -req -days 9999 -<span class="hljs-keyword">in</span> request.pem -signkey key.pem -out certificate.pem<span class="hljs-comment"># 使用 Android 提供的 SignApk.jar 进行 apk签名</span>java -jar SignApk.jar certificate.pem key.pk8 Application.apk Application_signed.apk<span class="hljs-comment"># 可以用这个脚本转到keytool去用java的 jarsigner, -p keystore-password</span>keytool-importkeypair -k ~/.android/debug.keystore -p android -pk8 key.pk8 -cert certificate.pem -<span class="hljs-built_in">alias</span> platform<span class="hljs-comment"># 使用 java自带的签名工具进行签名</span>jarsigner -verbose -keystore ~/.android/debug.keystore Application_unsign.apk platform</code></pre><p><a href="https://github.com/getfatday/keytool-importkeypair" target="_blank" rel="noopener">https://github.com/getfatday/keytool-importkeypair</a></p><pre><code class="bash"><span class="hljs-comment"># keytool-importkeypair</span><span class="hljs-comment"># 将pkcs8 转回 pem 格式</span>openssl pkcs8 -inform DER -nocrypt -<span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">${pk8}</span>"</span> -out <span class="hljs-string">"<span class="hljs-variable">${key}</span>"</span><span class="hljs-comment"># 将密钥绑定签名证书，使用 keystore的密码加密</span>openssl pkcs12 -<span class="hljs-built_in">export</span> -<span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">${cert}</span>"</span> -inkey <span class="hljs-string">"<span class="hljs-variable">${key}</span>"</span> -out <span class="hljs-string">"<span class="hljs-variable">${p12}</span>"</span> -password pass:<span class="hljs-string">"<span class="hljs-variable">${passphrase}</span>"</span> -name <span class="hljs-string">"<span class="hljs-variable">${alias}</span>"</span><span class="hljs-comment"># 导入keystore</span>keytool -importkeystore -deststorepass <span class="hljs-string">"<span class="hljs-variable">${passphrase}</span>"</span> -destkeystore <span class="hljs-string">"<span class="hljs-variable">${keystore}</span>"</span> -srckeystore <span class="hljs-string">"<span class="hljs-variable">${p12}</span>"</span> -srcstoretype PKCS12 -srcstorepass <span class="hljs-string">"<span class="hljs-variable">${passphrase}</span>"</span></code></pre><hr><p>以下为测试失败的一些方法：</p><p>It’s separate key storage: <code>gpg</code> has <code>~/.gnupg/pubring.gpg</code>, <code>gpgsm</code> has <code>~/.gnupg/pubring.kbx</code><br>So keys added with gpgsm aren’t usable with gpg; gpg doesn’t read ~/.gnupg/pubring.kbx.</p><pre><code class="bash">gpg -o secret-key.p12 --<span class="hljs-built_in">export</span> [key id] --<span class="hljs-built_in">export</span>-format pkcs12 --cert</code></pre><p><code>pkcs12</code> Only binary blocks are output; the default file extension is .p12; a signed key must be paired; and input must match exactly one key. In this case, --cert is required.</p><p><code>--cert</code> This option is the X.509 issuer long name or the 32-bit or 64-bit key ID, if the signing key is available.</p><p>And there is an option concerning the charset of the exported key, which often is a problem with (especially older) windows programs:</p><p><code>--p12-charset</code> name gpgsm uses the UTF-8 encoding when encoding passphrases for PKCS#12 files. This option may be used to force the passphrase to be encoded in the specified encoding name. This is useful if the application used to import the key uses a different encoding and thus will not be able to import a file generated by gpgsm. Commonly used values for name are Latin1 and CP850. Note that gpgsm itself automagically imports any file with a passphrase encoded to the most commonly used encodings.</p><p>It contains keys and certificates. Then you can split them with openSSL and transform it in .pem at the same time</p><pre><code class="bash">openssl pkcs12 -<span class="hljs-keyword">in</span> secret-key.p12 -out gpg-certs.pem -clcerts -nokeys -passin <span class="hljs-string">'pass:P@s5w0rD'</span>openssl pkcs12 -<span class="hljs-keyword">in</span> secret-key.p12 -out gpg-key.pem -nocerts -nodesopenssl pkcs12 -<span class="hljs-keyword">in</span> secret-key.p12 -nocerts -out gpg-key.pemopenssl pkcs12 -<span class="hljs-keyword">in</span> secret-key.p12 -nokeys -out gpg-certs.pem</code></pre><p>还发现一个工具可以： openpgp2ssh <a href="http://manpages.ubuntu.com/manpages/natty/man1/openpgp2ssh.1.html" target="_blank" rel="noopener">http://manpages.ubuntu.com/manpages/natty/man1/openpgp2ssh.1.html</a></p><p>但是只支持rsa以及没有密码的key.</p><p><code>gpg --edit-key $KEYID</code> 然后用 <code>passwd</code> 子命令移除密码。然后</p><p><code>gpg --export-secret-key $KEYID | openpgp2ssh $KEYID &gt; id_rsa</code></p><p>然后可以建立 Certificate Signing Request (CSR):</p><p>openssl req -new -key id_rsa -out id_rsa.csr</p><p>id_rsa.csr’s content should look like:</p><pre><code>-----BEGIN CERTIFICATE REQUEST-----MIIC9jCCAd4CAQAwgZkxCzAJBgNVBAYTAkRFMRMwEQYDVQQIEwpTb21lLVN0YXRl[...]-----END CERTIFICATE REQUEST-----</code></pre><p>然后发给CA，CA签名后发给你证书文件:</p><pre><code>-----BEGIN CERTIFICATE-----MIIFRjCCAy6gAwIBAgIDCuP8MA0GCSqGSIb3DQEBBQUAMHkxEDAOBgNVBAoTB1Jv[...]-----END CERTIFICATE-----</code></pre><p>你把<code>id_rsa</code>和证书合并在一起：</p><pre><code>-----BEGIN CERTIFICATE-----MIIFRjCCAy6gAwIBAgIDCuP8MA0GCSqGSIb3DQEBBQUAMHkxEDAOBgNVBAoTB1Jv[...]-----END CERTIFICATE----------BEGIN RSA PRIVATE KEY-----MIIEowIBAAKCAQEA0s2wNIWuUzuBYU9U0cK/mGa4LMtsWTEZEFTQhHj2eg4ZHmdt[...]-----END RSA PRIVATE KEY-----</code></pre><p>最后创建a PKCS#12 container:</p><p>openssl pkcs12 -export -in email@address.pem -out email@address.pem.p12</p><p><a href="http://wiki.cacert.org/ConvertingPgpKeyToCertificate" target="_blank" rel="noopener">Creating a new X.509 certificate from your PGP key pair</a></p><pre><code class="bash"><span class="hljs-comment"># 失败，没有 p12-export参数了！！！</span>/usr/lib/gnupg/gpg-protect-tool --p12-export -P &lt;passphrase&gt; ~/.gnupg/private-keys-v1.d/[keygrip] &gt;foo.p12</code></pre><p><code>[keygrip]</code> is the hash of the key.  you can find it by:</p><pre><code class="bash">gpg --with-keygrip --list-key</code></pre><p>prepend the above line by space to avoid login the passphrase in history.</p><p>then (as per this guide, in fact)</p><pre><code>openssl pkcs12 -in foo.p12 -nocerts -out foo.pemchmod 0600 foo.pemmv foo.pem ~/.ssh/id_rsassh-keygen -y -f ~/.ssh/id_rsa &gt; ~/.ssh/id_rsa.pub</code></pre><h2 id="pgp-xin-ren-fang-shi" class="heading-control">PGP 信任方式<a class="heading-anchor" href="#pgp-xin-ren-fang-shi" aria-hidden="true"></a></h2><p>PGP（Pretty Good Privacy）最初是用传统公钥密码学加密email信息的，之后又被用于加密本地文件。</p><p>注意：PGP和WoT(Web of Trust)不是同一样事务，PGP采用了WoT的方式。</p><p>PGP没有可信任的中心权威（第三方机构），但是相对应的是，系统中的每个人都可以签发自己的公钥并通过证书签名建立起自己的信任网。</p><p>一、公钥证书</p><p>公钥证书是PGP的重要核心。每个证书包含公钥所有者的用户ID（通常使用email地址），公钥，密钥ID，日期以及创建时间。证书需要被多个“介绍人”签名，“介绍人”是指用户完全信任的实体。PGP信任网的每个实体的主要标识是其公钥ID，而非与证书相关的用户ID号(这是因为用户ID号不稳定而公钥ID全局唯一且稳定不变)。但是公钥ID难以记忆，这也是唯一的问题（目前尚未完全解决）。</p><p>二、信任的定义</p><p>在PGP中有两个方面来定义信任：</p><ol><li>公钥证书的有效性；</li><li>介绍人的可信度。</li></ol><p>在此做个说明：一是所谓公钥之间的“介绍”其实就是“介绍人”对“被介绍人”的公钥证书上进行签名，其它人通过证书上的签名判断“被介绍人”的可信度，后面会讲到如何判断；二是公钥的有效性是指公钥通过证书上完全可信的签名将其与对应的公钥ID号紧密相连，如果失联则有效性消失。</p><p>首先介绍公钥证书有效性的层级：</p><ul><li>未定义有效（undefined）:公钥的有效性无法判断；</li><li>边际有效（marginal）：公钥可具有一定的有效性，但是无法完全确认；</li><li>完全有效（complete）：公钥完全有效。</li></ul><p>“介绍人”可信度主要定义的是用户认为某公钥所有者作为其它公钥的“介绍人”的可信任度。</p><p>下面再介绍“介绍人”可信度的层级：</p><ul><li>完全可信（full）：该公钥介绍其它公钥是完全值得信任的；</li><li>边际可信(marginal)：该公钥可以介绍其它公钥，但其可信度值得怀疑；</li><li>不可信(untrustworthy)：该公钥完全不值得信任，它为其它公钥所做的签名可忽略不计；</li><li>可信未知（don’t know）：该公钥介绍其它公钥的可信度仍属未知状态。</li></ul><p>然而以上的有效性和可信度定义得十分模糊，PGP就想办法使其更具实际指导意义。PGP赋予用户自行调节标准的能力，它定义了两个参数：COMPLETES_NEEDED（完全需要数量）和MARGINALS_NEEDED（边际需要数量）。前者定义为使公钥证书完全有效时所需的完全可信签名的数量，后者定义为使公钥部分有效时所需的边际签名的数量。这两个参数都是需要用户根据自身情况定的。</p><p>三、信任评估算法</p><p>当PGP评估一个公钥证书的可信度时，它需要运用如下算法，即信任评估算法（用伪代码表示）：</p><pre><code>1. For each signature do// scan signatures2. if signature is completely valid then3. if key trust ∈{undefined,unknown,untrusted} then4. ignore signature5. if key trust is marginal then6. accumulate marginals_counter7. if key trust is complete then8. accumulate completes_counter9. else10. ignore signature// decision11. if (marginals_counter&gt;0) or (completes_counter&gt;0) then12. if (marginals_counter&gt;=MARGINALS_NEEDED) or13.(completes_counter&gt;=COMPLETES_NEEDED) then14. mark key validity as 'complete'15. else16. mark key validity as 'marginal'</code></pre><p>其中：</p><ul><li>line 6: marginals_counter  计算该公钥证书的边际信任签名个数；</li><li>line 8: completes_counter 计算该公钥证书的完全信任签名个数；</li><li>line 10:非完全有效的签名将被忽略，即便它是由可信任的“介绍人”提出；</li><li>lines 11,12,13: COMPLETES_NEEDED（完全需要数量）和MARGINALS_NEEDED（边际需要数量）均大于1。</li></ul><p>四、介绍人</p><p>PGP是通过证书的签名人来证明公钥的有效性的，这些签名人又被称为“介绍人”，即，一个用户通过用自己的私钥签名一个新的公钥证书来向其它用户证明该证书中包含的公钥的有效性。如果一个用户有幸被划分为“完全可信介绍人”，则其被人完全信任，它在介绍其它公钥证书时影响力更大，介绍的人不需更多；若该用户被划分为“边际可信介绍人”，则其影响力就不足，需要更多这样的人来签名证书作证明。其中每个介绍人的可信度都是根据用户的考虑和隐私的需求结合起来定义的。</p><p>在PGP中，信任是不可以传递的。即在下图的介绍人（证书）链中，Carol不能假设Eric 的证书是有效的，除非通过介绍人的介绍。</p><pre><code>Carol --&gt; Alice --&gt; Bob --&gt; Eric</code></pre><pre><code class="mermaid">graph LR  Carol --&gt; Alice  Alice --&gt; Bob  Bob --&gt; Eric</code></pre><p>在PGP中的CERT_DEPTH参数尽管定义了证书链长度的最大值，但是也不能用其确定出证书的有效性。</p><p>也就是说，这些链的作用仅在于寻求用户之间的直接信任关系，帮助减少关系网的冗余度，使关系网更加清晰。</p><p>信赖网路机制比S/MIME方案的集中管理的公钥基础设施有优势，但是没有被网络普通大众普遍采用，一般只在Unix-like的爱好者、开源软体界、和对隐私特别注意而且有电脑知识的人群之间使用。如何使一般用户容易并且乐意使用、接收证书然后手动的验证它们的有效性，这些潜在的推广阻碍目前还没有满意的解决方案。</p><h2 id="key-server" class="heading-control">Key Server<a class="heading-anchor" href="#key-server" aria-hidden="true"></a></h2><p><a href="https://roll.urown.net/server/pgp-keyserver.html" target="_blank" rel="noopener">https://roll.urown.net/server/pgp-keyserver.html</a></p><h2 id="references" class="heading-control">References<a class="heading-anchor" href="#references" aria-hidden="true"></a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GnuPG软件（简称GPG） – OpenPGP&lt;/p&gt;
&lt;h1 id=&quot;li-shi-jie-shao-history&quot; class=&quot;heading-control&quot;&gt;历史介绍 History&lt;a class=&quot;heading-anchor&quot; href=&quot;#li-shi-jie-shao-history&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;pgp-pretty-good-privacy&quot; class=&quot;heading-control&quot;&gt;PGP (Pretty Good Privacy)&lt;a class=&quot;heading-anchor&quot; href=&quot;#pgp-pretty-good-privacy&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最早是由PGP Inc.公司拥有原始的PGP加密软件的版权，后来它被赛门铁克公司（Symantec Corp.）收购。后续由赛门铁克公司继续开发维护PGP品牌。&lt;/p&gt;
&lt;h2 id=&quot;openpgp&quot; class=&quot;heading-control&quot;&gt;OpenPGP&lt;a class=&quot;heading-anchor&quot; href=&quot;#openpgp&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://riceball.me/categories/Security/"/>
    
      <category term="PGP" scheme="https://riceball.me/categories/Security/PGP/"/>
    
    
      <category term="openpgp" scheme="https://riceball.me/tags/openpgp/"/>
    
      <category term="pgp" scheme="https://riceball.me/tags/pgp/"/>
    
      <category term="gpg" scheme="https://riceball.me/tags/gpg/"/>
    
      <category term="public key" scheme="https://riceball.me/tags/public-key/"/>
    
  </entry>
  
  <entry>
    <title>基于Markdown的响应(交互)式文档</title>
    <link href="https://riceball.me/article/interative-markdown/"/>
    <id>https://riceball.me/article/interative-markdown/</id>
    <published>2019-11-23T14:22:00.000Z</published>
    <updated>2019-12-08T01:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shi-mo-shi-xiang-ying-jiao-hu-shi-wen-dang" class="heading-control">什么是响应(交互)式文档<a class="heading-anchor" href="#shi-mo-shi-xiang-ying-jiao-hu-shi-wen-dang" aria-hidden="true"></a></h2><p>什么是响应(交互)式文档，简单的说就是文档内容能够实时响应读者的交互，根据交互实时变化的文档。在技术，教育领域中，为了将知识表述更清楚，常常需要✍文档能“动”起来，最极端的例子应该是🎮️“游戏”。虽然目前还不能让🎮️游戏文档直接“动”起来。不过未来就不一定了。</p><p>我们接下来通过一个简单的响应(交互)式文档例子，来直观感受一下，请看下面。</p><a id="more"></a><h3 id="hui-zhi-ju-xing-rect-li-zi" class="heading-control">绘制矩形(Rect)例子<a class="heading-anchor" href="#hui-zhi-ju-xing-rect-li-zi" aria-hidden="true"></a></h3><p><strong>参数</strong>：<span class="AMElement" data-embed="false" data-config="rx:10..">x轴坐标:10</span>，<span class="AMElement" data-embed="false" data-config="ry:10..">y轴坐标:18</span>，<span class="AMElement" data-embed="false" data-config="rw:1..">宽度:100</span>，<span class="AMElement" data-embed="false" data-config="rh:1..">高度:50</span></p><p>下面演示在提供好的画布上用上述参数绘制一个矩形，点击下方的播放按钮进行演示：</p><pre><code class="output"># 演示绘制矩形的过程paper = @canvas|~~~tooltip: 设置画布大小为200X100 ::: 初始化工作type:paper.setSize(200,100)\ntooltip: 清空画布type:paper.clear()\ntooltip: 初始化来自文档的x,y座标，宽度和高度参数变量type:@rx ||=10\ntype:@ry ||=18\ntype:@rw ||=100\ntype:@rh ||=50\ntooltip: 开始绘制矩形 ::: 绘制矩形type:rect = paper.rect(@rx, @ry, @rw, @rh)\ntooltip: 为矩形填充红色type:rect.attr('fill', 'red')moveTo: 8:13tooltip: 现在你可以自己试一试了</code></pre><hr><p>看完演示，你可以通过将鼠标移到上方参数列表中的x,y或宽,高参数上进行拖动来直观的改变参数值，也可以直接在上面的代码中编辑修改，自己动手试一试其他的绘图函数,比如: 圆，椭圆, 文字，图片等等。</p><ul><li><code>circle(x, y, r)</code></li><li><code>ellipse(x, y, xr, yr)</code></li><li><code>image(src, x, y, width, height)</code></li><li><code>text(50, 50, &quot;Hi world\n你好世界&quot;)</code></li></ul><p>响应(交互)式文档能够更加直观的看到结果的变化，使得知识更容易理解。</p><h2 id="wei-shi-mo-xiang-ying-jiao-hu-shi-wen-dang-yao-ji-yu-markdown-ge-shi" class="heading-control">为什么响应(交互)式文档要基于Markdown格式？<a class="heading-anchor" href="#wei-shi-mo-xiang-ying-jiao-hu-shi-wen-dang-yao-ji-yu-markdown-ge-shi" aria-hidden="true"></a></h2><p>Markdown 是一种纯文本格式的轻量级标记语言，强调可读性高于一切。</p><ul><li>纯文本，所以兼容性极强，速度快，易保存，数据不易丢失，可以用所有文本编辑器编辑。</li><li>可以专注写作而不是排版。用Word写作的时候，经常浪费大量时间去思考排版，</li><li>Markdown 语法简单，只有少量的标记符号，可以很快学会。</li><li>Markdown 的标记语法有极好的可读性。</li></ul><p>使用Markdown格式可以随时随地的编写互动文档，让更多的人都能够参与进来。目前的开源编写互动文档的门槛还是比较高，如果不懂相关技术，是很难入门。</p><ul><li><a href="https://jupyter.org/" target="_blank" rel="noopener">Jupyter Notebook</a>文档是基于 JSON 格式，主要面向开发者的。<ul><li>目的是可读性更高的，可直接执行的代码文档。</li></ul></li><li><a href="https://rmarkdown.rstudio.com/" target="_blank" rel="noopener">R Markdown</a> 文档是基于 markdown 格式，但也是面向R语言开发者的。<ul><li>目的是让Markdown的代码块可以被直接执行，输出结果混合渲染成Html。</li></ul></li></ul><p>而交互式Markdown格式的目的是要让普通人也能快速上手使用。</p><p>比如，对函数图像进行教学演示的交互式markdown，只需要</p><ol><li>定义函数: <code>@func = (x) =&gt; Math.cos(x + @offset)</code></li><li>设定需要演示改变的参数: <code>[Offset: 0.00]{offset: -2pi..2pi by 0.0625pi}</code></li><li>在指定的位置显示函数图像：<code>![Chart]{line=func: 0..2pi by 0.001, width=600, height=300}</code></li></ol><p>绘制余弦曲线图：</p><pre><code>@func = (x) =&gt; Math.cos(x + @offset)</code></pre><p>函数参数:</p><ul><li><span class="AMElement" data-embed="false" data-config="offset: -2pi..2pi by 0.0625pi">Offset: 0.00</span></li></ul><p><span class="AMElement" data-embed="true" data-config="line=func: 0..2pi by 0.001, width=600, height=300">Chart</span></p><p>读者就可以将鼠标移到上方Offset参数上进行拖动来改变参数值从而改变函数图像，也可以直接将函数<code>cos</code>改为<code>sin</code>看看。</p><p><a href="/imarkdown">Interactive Markdown</a> 目前还在内部测试中，语义规范尚未固定。不过，我写了一个玩具可以让您自己的博客使用互动文档，用的是<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo博客生成工具</a>➕️<a href="https://theme-next.org/" target="_blank" rel="noopener">Theme-Next主题</a>，通过<a href="https://github.com/snowyu/hexo-next-imarkdown" target="_blank" rel="noopener">hexo-next-imarkdown</a>插件即可让您的博客支持互动Markdown文档格式，欢迎尝鲜。</p><p>更详尽的<a href="/imarkdown">Interactive Markdown</a>语法请参阅💁🏻‍♂️ <a href="http://riceball.me/imarkdown/reference.html">交互式Markdown文档参考手册</a> .</p><h2 id="wei-lai" class="heading-control">未来<a class="heading-anchor" href="#wei-lai" aria-hidden="true"></a></h2><p>我希望在不久的将来使用<a href="/imarkdown">Interactive Markdown</a> 来编写绘本故事书，<a href="https://medium.com/ai-club-iiitb/text-to-image-synthesis-62eb44e65cd0" target="_blank" rel="noopener">根据文字自动产生图画</a>故事。</p><p>在更远的未来甚至可以开发游戏。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;shi-mo-shi-xiang-ying-jiao-hu-shi-wen-dang&quot; class=&quot;heading-control&quot;&gt;什么是响应(交互)式文档&lt;a class=&quot;heading-anchor&quot; href=&quot;#shi-mo-shi-xiang-ying-jiao-hu-shi-wen-dang&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;什么是响应(交互)式文档，简单的说就是文档内容能够实时响应读者的交互，根据交互实时变化的文档。在技术，教育领域中，为了将知识表述更清楚，常常需要✍文档能“动”起来，最极端的例子应该是🎮️“游戏”。虽然目前还不能让🎮️游戏文档直接“动”起来。不过未来就不一定了。&lt;/p&gt;
&lt;p&gt;我们接下来通过一个简单的响应(交互)式文档例子，来直观感受一下，请看下面。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;hui-zhi-ju-xing-rect-li-zi&quot; class=&quot;heading-control&quot;&gt;绘制矩形(Rect)例子&lt;a class=&quot;heading-anchor&quot; href=&quot;#hui-zhi-ju-xing-rect-li-zi&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Thinking" scheme="https://riceball.me/categories/Thinking/"/>
    
      <category term="Reactive" scheme="https://riceball.me/categories/Thinking/Reactive/"/>
    
      <category term="Document" scheme="https://riceball.me/categories/Thinking/Reactive/Document/"/>
    
      <category term="Markdown" scheme="https://riceball.me/categories/Thinking/Reactive/Document/Markdown/"/>
    
    
      <category term="javascript" scheme="https://riceball.me/tags/javascript/"/>
    
      <category term="interactive" scheme="https://riceball.me/tags/interactive/"/>
    
      <category term="reactive" scheme="https://riceball.me/tags/reactive/"/>
    
      <category term="document" scheme="https://riceball.me/tags/document/"/>
    
      <category term="raphael" scheme="https://riceball.me/tags/raphael/"/>
    
      <category term="markdown" scheme="https://riceball.me/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>CouchDB</title>
    <link href="https://riceball.me/article/couchdb/"/>
    <id>https://riceball.me/article/couchdb/</id>
    <published>2018-10-09T21:30:59.000Z</published>
    <updated>2019-11-25T19:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>CouchDB 是一个面向文档的<code>NoSQL</code>数据库。CouchDB还可以把整个H5网站直接放到数据库中，这称为<code>CouchApp</code>，详见后述。</p><a id="more"></a><h2 id="source-build" class="heading-control">Source Build<a class="heading-anchor" href="#source-build" aria-hidden="true"></a></h2><pre><code class="bash">sudo apt-get --no-install-recommends -y install \    build-essential pkg-config erlang erlang-reltool \    libicu-dev libcurl4-openssl-devsudo apt-get install devscripts libnspr4-dev pkg-kde-toolsgit <span class="hljs-built_in">clone</span> https://github.com/apache/couchdbgit <span class="hljs-built_in">clone</span> https://github.com/apache/couchdb-pkg<span class="hljs-built_in">cd</span> couchdb-pkgmake couch-js-debs PLATFORM=bionic <span class="hljs-comment"># howto use it? still cannot find jsapi.h</span>sudo dpkg -i js/couch-libmozjs185-*.deb<span class="hljs-comment"># build dpkg needed:</span>sudo apt install dh-exec dh-systemd nodejs python-sphinxmake build-couch $(lsb_release -cs) PLATFORM=$(lsb_release -cs)</code></pre><h2 id="gai-nian" class="heading-control">概念<a class="heading-anchor" href="#gai-nian" aria-hidden="true"></a></h2><h3 id="shu-ju-ku-database" class="heading-control">数据库(database)<a class="heading-anchor" href="#shu-ju-ku-database" aria-hidden="true"></a></h3><p>概念比较:</p><table><thead><tr><th>MongoDB</th><th>CouchDB</th></tr></thead><tbody><tr><td>Collection</td><td>Database</td></tr><tr><td>Key/Value</td><td>_id/Document</td></tr></tbody></table><p>在MongoDB中称 <code>database</code> 为 <code>Collection</code>。 一个<code>K/V键值对</code>在<code>CouchDB</code>称为 <code>Document</code>.</p><p>可以查询、创建和删除数据库，数据库的名称只能是小写字母、数字以及特殊字符_$()±/。</p><ul><li><code>GET /_all_dbs</code>: 查询 CouchDB 中所有的数据库名称。该请求返回的是一个 JSON 数组<pre><code class="js">[<span class="hljs-string">"_global_changes"</span>,<span class="hljs-string">"_replicator"</span>,<span class="hljs-string">"_users"</span>]</code></pre></li><li><code>GET /[database-name]</code>: 查询名为databasename的数据库的具体信息.<pre><code class="js">{<span class="hljs-string">"db_name"</span>:<span class="hljs-string">"_users"</span>,<span class="hljs-string">"update_seq"</span>:<span class="hljs-string">"1-g1AAAA"</span>,<span class="hljs-string">"sizes"</span>:{<span class="hljs-string">"file"</span>:<span class="hljs-number">38054</span>,<span class="hljs-string">"external"</span>:<span class="hljs-number">5024</span>,<span class="hljs-string">"active"</span>:<span class="hljs-number">2197</span>},<span class="hljs-string">"purge_seq"</span>:<span class="hljs-number">0</span>,<span class="hljs-string">"other"</span>:{<span class="hljs-string">"data_size"</span>:<span class="hljs-number">5024</span>},<span class="hljs-string">"doc_del_count"</span>:<span class="hljs-number">0</span>,<span class="hljs-string">"doc_count"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"disk_size"</span>:<span class="hljs-number">38054</span>,<span class="hljs-string">"disk_format_version"</span>:<span class="hljs-number">6</span>,<span class="hljs-string">"data_size"</span>:<span class="hljs-number">2197</span>,<span class="hljs-string">"compact_running"</span>:<span class="hljs-literal">false</span>,<span class="hljs-string">"instance_start_time"</span>:<span class="hljs-string">"0"</span>}</code></pre></li><li><code>PUT /[database-name]</code>: 创建名为databasename的数据库。如果数据库创建成功的话，返回 HTTP 状态代码 201 ；如果已有一个同名数据库的话，返回 HTTP 状态代码 412 。</li><li><code>DELETE /[database-name]</code>: 删除名为databasename的数据库。如果数据库删除成功的话，返回 HTTP 状态代码 200 ；如果数据库不存在，返回 HTTP 状态代码 404 。</li></ul><h4 id="nei-bu-shu-ju-ku" class="heading-control">内部数据库<a class="heading-anchor" href="#nei-bu-shu-ju-ku" aria-hidden="true"></a></h4><p>内部数据库以&quot;_&quot;打头。</p><ul><li><code>_users</code> 为用户数据库(authentication)，默认匿名用户可以创建用户。可以在<code>_design/_auth</code>中添加限制，参考后面的代码样例。</li><li><code>_session</code>: 服务器端的用户会话管理。</li><li><code>_config</code> 为系统配置数据库，管理员配置也在其中。</li></ul><h5 id="an-quan-yu-ren-zheng-users" class="heading-control">安全与认证(_users)<a class="heading-anchor" href="#an-quan-yu-ren-zheng-users" aria-hidden="true"></a></h5><p><a href="http://docs.couchdb.org/en/2.1.1/intro/security.html" target="_blank" rel="noopener">http://docs.couchdb.org/en/2.1.1/intro/security.html</a></p><ul><li><code>_id</code> (string): Document ID. Contains user’s login with special prefix Why the <code>org.couchdb.user</code>: prefix?</li><li><code>derived_key</code> (string): PBKDF2 key</li><li><code>name</code> (string): User’s name aka login. Immutable e.g. you cannot rename an existing user - you have to create new one</li><li><code>roles</code> (array of string): List of user roles. CouchDB doesn’t provide any built-in roles, so you’re free to define your own depending on your needs. However, you cannot set system roles like _admin there. Also, only administrators may assign roles to users - by default all users have no roles. 你可以自己定义role，然后在<code>validate_doc_update</code>中去检测角色。</li><li><code>password_sha</code> (string): Hashed password with salt. Used for simple password_scheme</li><li><code>password_scheme</code> (string): Password hashing scheme. May be simple or pbkdf2</li><li><code>salt</code> (string): Hash salt. Used for simple password_scheme</li><li><code>type</code> (string): Document type. Constantly has the value user</li></ul><p>Why the <code>org.couchdb.user</code>: prefix?</p><p>The reason there is a special prefix before a user’s login name is to have namespaces that users belong to. This prefix is designed to prevent replication conflicts when you try merging two or more <code>_user</code> databases.</p><p>For current CouchDB releases, all users belong to the same <code>org.couchdb.user</code> namespace and this cannot be changed. This may be changed in future releases.</p><h3 id="wen-dang-document" class="heading-control">文档（document）<a class="heading-anchor" href="#wen-dang-document" aria-hidden="true"></a></h3><p>文档是 CouchDB 中的核心概念。一个 CouchDB 数据库实际上是一系列文档的集合。每个文档是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如数组和对象。每个文档都有一个全局惟一的标识符（ID）以及一个修订版本号（revision number）。 ID 用来惟一标识一个文档（相当于Key），而修订版本号则用来实现多版本并发控制（Multiversion concurrency control，MVVC）。在 CouchDB 中，文档是以 JSON 对象的形式保存的。文档中至少要包含<code>_id</code>和<code>_rev</code>字段，其中以“_”作为前缀的顶层字段是由 CouchDB 保留使用的。</p><ul><li><p><code>_id</code> : 全局惟一的标识符，用来惟一标识一个文档；</p></li><li><p><code>_rev</code> : 修订版本号，用来实现多版本并发控制（Multiversion concurrency control，MVVC）；</p></li><li><p><code>_attachments</code> : 内嵌型附件，以 base64 编码的格式作为文档的一个字段保存；</p></li><li><p><code>GET /[databasename]/[doc_id]</code></p></li><li><p><code>PUT /[databasename]/[doc_id]</code> 创建或更新文档</p></li><li><p>更新已有的文档:在 PUT 请求内容的文档中需要包含_rev字段，表示文档的修订版本号。 CouchDB 使用该字段来做更新时的冲突检测。如果该字段的值与 CouchDB 中保存的该文档的修订版本号一致，则表明没有冲突，可以进行更新。当更新完成之后，返回 HTTP 状态代码 201 ；否则返回 HTTP 状态代码 409，表示有版本冲突。</p></li><li><p><code>POST /[databasename]</code> 创建文档,<code>_id</code>由系统决定。</p></li><li><p><code>DELETE /[databasename]/[doc_id]?rev=[rev_id]</code> 删除数据库databasename中 ID 为doc_id，并且修订版本号为rev_id的文档。</p></li></ul><p>用文档来描述关系：</p><pre><code class="js"><span class="hljs-comment">// 用内嵌文档 ID 描述多对多关系</span> {  <span class="hljs-string">"_id"</span> : <span class="hljs-string">"user1"</span>,  <span class="hljs-string">"username"</span> : <span class="hljs-string">"Alex"</span>,  <span class="hljs-string">"email"</span> : <span class="hljs-string">"alexcheng1982@gmail.com"</span>,  <span class="hljs-string">"roles"</span>:[<span class="hljs-string">"db_admin"</span>,<span class="hljs-string">"backup_admin"</span>] } {  <span class="hljs-string">"_id"</span> : <span class="hljs-string">"db_admin"</span>,  <span class="hljs-string">"name"</span> : <span class="hljs-string">" 数据库管理员 "</span>,  <span class="hljs-string">"priority"</span> : <span class="hljs-number">2</span> } <span class="hljs-comment">// 用关联文档描述多对多关系</span> {  <span class="hljs-string">"_id"</span> : <span class="hljs-string">"user1"</span>,  <span class="hljs-string">"username"</span> : <span class="hljs-string">"Alex"</span>,  <span class="hljs-string">"email"</span> : <span class="hljs-string">"alexcheng1982@gmail.com"</span> } {  <span class="hljs-string">"_id"</span> : <span class="hljs-string">"db_admin"</span>,  <span class="hljs-string">"name"</span> : <span class="hljs-string">" 数据库管理员 "</span>,  <span class="hljs-string">"priority"</span> : <span class="hljs-number">2</span> } {  <span class="hljs-string">"_id"</span> : <span class="hljs-string">"user_role_001"</span>,  <span class="hljs-string">"user_id"</span> : <span class="hljs-string">"user1"</span>,  <span class="hljs-string">"role_id"</span> : <span class="hljs-string">"db_admin"</span> }</code></pre><h4 id="wen-dang-cha-xun" class="heading-control">文档查询<a class="heading-anchor" href="#wen-dang-cha-xun" aria-hidden="true"></a></h4><p><a href="https://pouchdb.com/2014/04/14/pagination-strategies-with-pouchdb.html" target="_blank" rel="noopener">https://pouchdb.com/2014/04/14/pagination-strategies-with-pouchdb.html</a><br><a href="https://pouchdb.com/guides/queries.html#pouchdb-find" target="_blank" rel="noopener">https://pouchdb.com/guides/queries.html#pouchdb-find</a></p><p>Pouchdb这里推荐是all_docs</p><ul><li><code>GET /[db]/_all_docs</code> is a special case for CouchDB. Instead of the normal Unicode Collation, it uses ASCII collation. 故不推荐使用<a href="https://wiki.apache.org/couchdb/View_collation" target="_blank" rel="noopener">1</a>。</li><li><a href="http://docs.couchdb.org/en/2.0.0/api/database/find.html" target="_blank" rel="noopener">POST /[db]/_find</a>: 可以</li></ul><pre><code class="js">{  <span class="hljs-string">"selector"</span>: {    <span class="hljs-string">"_id"</span>: {<span class="hljs-string">"$gt"</span>: <span class="hljs-string">"产品\u0000"</span>, <span class="hljs-string">"$lt"</span>: <span class="hljs-string">"产品/\uffff"</span>}  }}</code></pre><p><code>_find</code> 是类似MongoDB的查询方式(<a href="https://pouchdb.com/guides/mango-queries.html" target="_blank" rel="noopener">https://pouchdb.com/guides/mango-queries.html</a>).<br>这里被称为<code>Mango queries</code>, 从CouchDB@2.1.1开始支持<code>partial indexes</code>查询以及分页。</p><p>数组的Mango查询类型：</p><pre><code class="js">{  <span class="hljs-string">"selector"</span>: {    <span class="hljs-string">"tags"</span>: {<span class="hljs-attr">$elemMatch</span>: {<span class="hljs-attr">$eq</span>: <span class="hljs-string">'apple'</span>}}  }}<span class="hljs-comment">//等价于</span>{  <span class="hljs-string">"selector"</span>: {    <span class="hljs-string">"tags"</span>: {<span class="hljs-attr">$in</span>: [<span class="hljs-string">'apple'</span>]}  }}</code></pre><p>如果数组类型是<code>json object</code>好像可以加索引(经测试无效，还是不能利用索引！)：<a href="https://stackoverflow.com/questions/35784178/how-to-index-multidimensional-arrays-in-couchdb" target="_blank" rel="noopener">https://stackoverflow.com/questions/35784178/how-to-index-multidimensional-arrays-in-couchdb</a><br>看到了，是Cloudant的扩展，全文检索引擎，索引类型必须为 <code>text</code>. 大致看来需要自己编译couchdb并使用它的dreyfus插件，菜可以和lucene连上。<br><a href="https://developer.ibm.com/dwblog/2015/text-search-apache-couchdb/" target="_blank" rel="noopener">https://developer.ibm.com/dwblog/2015/text-search-apache-couchdb/</a><br><a href="https://github.com/cloudant-labs/dreyfus/wiki/Introduce-dreyfus-into-couchdb" target="_blank" rel="noopener">https://github.com/cloudant-labs/dreyfus/wiki/Introduce-dreyfus-into-couchdb</a><br><a href="https://github.com/apache/couchdb-docker/issues/8" target="_blank" rel="noopener">https://github.com/apache/couchdb-docker/issues/8</a><br><a href="https://github.com/grueni/oi-userland/tree/couchdb-dreyfus" target="_blank" rel="noopener">https://github.com/grueni/oi-userland/tree/couchdb-dreyfus</a><br><a href="https://github.com/neutrinity/ntr-couch-docker" target="_blank" rel="noopener">https://github.com/neutrinity/ntr-couch-docker</a></p><pre><code class="js">{<span class="hljs-string">"Teams"</span>: [  {   <span class="hljs-string">"id"</span>: <span class="hljs-string">"79d25d41d991890350af672e0b76faed"</span>,   <span class="hljs-string">"name"</span>: <span class="hljs-string">"First Team"</span>,   <span class="hljs-string">"level"</span>: <span class="hljs-string">"123"</span>  },  {   <span class="hljs-string">"id"</span>: <span class="hljs-string">"e500c1bf691b9cfc99f05634da80b6d1"</span>,   <span class="hljs-string">"name"</span>: <span class="hljs-string">"Second Team Name"</span>,   <span class="hljs-string">"level"</span>: <span class="hljs-string">""</span>  },  {   <span class="hljs-string">"id"</span>: <span class="hljs-string">"4645e8a4958421f7d843d9b34c4cd9fe"</span>,   <span class="hljs-string">"name"</span>: <span class="hljs-string">"Third Team Name"</span>,   <span class="hljs-string">"level"</span>: <span class="hljs-string">"123"</span>  } ], <span class="hljs-string">"LastTeam"</span>: <span class="hljs-string">"79d25d41d991890350af672e0b76faed"</span>}<span class="hljs-comment">//index:</span>{  <span class="hljs-string">"index"</span>: {    <span class="hljs-string">"fields"</span>: [      {<span class="hljs-string">"name"</span>: <span class="hljs-string">"Teams.[].id"</span>, <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>}    ]  },  <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>}<span class="hljs-comment">//query:</span>{  <span class="hljs-string">"selector"</span>: {    <span class="hljs-string">"Teams"</span>: {<span class="hljs-string">"$elemMatch"</span>: {<span class="hljs-string">"id"</span>: <span class="hljs-string">"79d25d41d991890350af672e0b76faed"</span>}}  },  <span class="hljs-string">"fields"</span>: [    <span class="hljs-string">"_id"</span>,    <span class="hljs-string">"FirstName"</span>,    <span class="hljs-string">"LastName"</span>  ]}</code></pre><p>对数组的查询可以，但是目前没有索引支持！！<br>Currently couchdb find does not support indexing array members (<a href="https://issues.apache.org/jira/browse/COUCHDB-2867" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/COUCHDB-2867</a>). Pouchdb is matching Couchdb’s implementation here.</p><p>用Map/Reduce查询数组：</p><pre><code class="js"><span class="hljs-comment">//创建Map/Reduce索引</span><span class="hljs-keyword">var</span> designDoc = {  <span class="hljs-attr">_id</span>: <span class="hljs-string">'_design/_index'</span>,  <span class="hljs-attr">views</span>: {    <span class="hljs-string">'by_tags'</span>: {      <span class="hljs-attr">map</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(doc.tags)) {          doc.tags.forEach(<span class="hljs-function"><span class="hljs-params">tag</span>=&gt;</span>emit(tag));        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (doc.tags) {          emit(doc.tags)        }      }.toString()    }  }};pouch.put(designDoc).then(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span><span class="hljs-built_in">console</span>.log(r)).catch(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span><span class="hljs-built_in">console</span>.log(e))<span class="hljs-comment">//查询参数：详见后述「视图(View)的查询参数」</span><span class="hljs-comment">//keys 参数: 只获取在数组中的key名称。</span>pouch.query(viewName, {<span class="hljs-attr">keys</span>:[<span class="hljs-string">'apple'</span>], <span class="hljs-attr">inclusive_end</span>: <span class="hljs-literal">false</span>});</code></pre><p>避免使用数组:</p><pre><code>_id:  人/{id}/.tag/applename: appletype: tag</code></pre><p>至于limit的配置只能通过<a href="http://docs.couchdb.org/en/master/config/couchdb.html" target="_blank" rel="noopener">max_document_size</a>.<br>或者 <a href="http://docs.couchdb.org/en/master/config/http.html" target="_blank" rel="noopener">max_http_request_size</a></p><pre><code class="ini"><span class="hljs-section">[couchdb]</span><span class="hljs-attr">max_document_size</span> = <span class="hljs-number">4294967296</span> <span class="hljs-comment">; 4 GB</span><span class="hljs-section">[httpd]</span><span class="hljs-attr">max_http_request_size</span> = <span class="hljs-number">4294967296</span> <span class="hljs-comment">; 4 GB</span></code></pre><p>不过有人在改： <a href="https://github.com/apache/couchdb-couch-mrview/pull/56/files" target="_blank" rel="noopener">https://github.com/apache/couchdb-couch-mrview/pull/56/files</a><br><a href="https://jira.hyperledger.org/browse/FAB-2809" target="_blank" rel="noopener">https://jira.hyperledger.org/browse/FAB-2809</a></p><h3 id="wen-dang-bian-geng-tong-zhi" class="heading-control">文档变更通知<a class="heading-anchor" href="#wen-dang-bian-geng-tong-zhi" aria-hidden="true"></a></h3><p><code>GET /[db]/_changes</code><br><code>POST /[db]/_changes?filter=_doc_ids</code> 如果有大量的<code>doc_ids</code>，那么就只能用POST.</p><pre><code>POST /recipes/_changes?filter=_doc_ids HTTP/1.1Accept: application/jsonContent-Length: 40Content-Type: application/jsonHost: localhost:5984{    &quot;doc_ids&quot;: [        &quot;SpaghettiWithMeatballs&quot;    ]}</code></pre><h4 id="changes-feed" class="heading-control">Changes Feed<a class="heading-anchor" href="#changes-feed" aria-hidden="true"></a></h4><p>文档变更通知的三种方式</p><h5 id="polling" class="heading-control">Polling<a class="heading-anchor" href="#polling" aria-hidden="true"></a></h5><p>A list of changes made to documents in the database, in the order they were made, can be obtained from the database’s _changes resource. You can query the _changes resource by issuing a GET request with the following (optional) parameters:</p><table><thead><tr><th>Parameter</th><th>Value</th><th>Default Value</th><th>Notes</th></tr></thead><tbody><tr><td>since</td><td>seqnum/now</td><td>0</td><td>(1)</td></tr><tr><td>limit</td><td>maxsequences</td><td>none</td><td>(2)</td></tr><tr><td>descending</td><td>boolean</td><td>false</td><td>(3)</td></tr><tr><td>feed</td><td>normal/longpoll/continuous/eventsource</td><td>normal</td><td>(4)</td></tr><tr><td>heartbeat</td><td>milliseconds</td><td>60000</td><td>(5)</td></tr><tr><td>timeout</td><td>milliseconds</td><td>60000</td><td>(6)</td></tr><tr><td>filter</td><td>designdoc/filtername/_view</td><td>none</td><td>(7)</td></tr><tr><td>include_docs</td><td>boolean</td><td>false</td><td>(8)</td></tr><tr><td>style</td><td>all_docs/main_only</td><td>main_only</td><td>(9)</td></tr><tr><td>view</td><td>designdoc/filtername</td><td>none</td><td>(10)</td></tr></tbody></table><p>Notes:</p><ol><li>Start the results from the change immediately after the given sequence number.</li><li>Limit number of result rows to the specified value (note that using 0 here has the same effect as 1).</li><li>Return the change results in descending sequence order (most recent change first)</li><li>Select the type of feed.</li><li>Period in milliseconds after which an empty line is sent in the results. Only applicable for longpoll or continuous feeds. Overrides any timeout to keep the feed alive indefinitely.</li><li>Maximum period in milliseconds to wait for a change before the response is sent, even if there are no results. Only applicable for longpoll or continuous feeds. Note that 60000 is also the default maximum timeout to prevent undetected dead connections.</li></ol><p>You can change the default maximum timeout in your ini-configuration:</p><pre><code class="ini"><span class="hljs-section">[httpd]</span><span class="hljs-attr">changes_timeout</span>=<span class="hljs-comment">#millisecs</span></code></pre><ol start="7"><li>Reference to a filter function from a design document that will filter whole stream emitting only filtered events. See the section in the book for more information.</li><li>Include the associated document with each result. If there are conflicts, only the winning revision is returned.</li><li>Specifies how many revisions are returned in the changes array. The default, main_only, will only return the current “winning” revision; all_docs will return all leaf revisions (including conflicts and deleted former conflicts.)</li><li>Allows to use view functions as filters. It requires to set filter special value _view to enable this feature. Documents counted as “passed” for view filter in case if map function emits at least one record for them.</li></ol><h5 id="longpoll" class="heading-control">longpoll<a class="heading-anchor" href="#longpoll" aria-hidden="true"></a></h5><p>打开连接，等待直到有改变发生后，就立刻连接关闭。适合于低频率的更新。</p><h5 id="continuous" class="heading-control">continuous<a class="heading-anchor" href="#continuous" aria-hidden="true"></a></h5><p>一直打开连接,永不disconnect.</p><p><code>GET /somedatabase/_changes?feed=continuous HTTP/1.1</code></p><pre><code>{&quot;seq&quot;:1,&quot;id&quot;:&quot;fresh&quot;,&quot;changes&quot;:[{&quot;rev&quot;:&quot;1-967a00dff5e02add41819138abb3284d&quot;}]}{&quot;seq&quot;:3,&quot;id&quot;:&quot;updated&quot;,&quot;changes&quot;:[{&quot;rev&quot;:&quot;2-7051cbe5c8faecd085a3fa619e6e6337&quot;}]}{&quot;seq&quot;:5,&quot;id&quot;:&quot;deleted&quot;,&quot;changes&quot;:[{&quot;rev&quot;:&quot;2-eec205a9d413992850a6e32678485900&quot;}],&quot;deleted&quot;:true}... tum tee tum ...{&quot;seq&quot;:6,&quot;id&quot;:&quot;updated&quot;,&quot;changes&quot;:[{&quot;rev&quot;:&quot;3-825cb35de44c433bfb2df415563a19de&quot;}]}</code></pre><h5 id="eventsource" class="heading-control">eventsource<a class="heading-anchor" href="#eventsource" aria-hidden="true"></a></h5><p>The eventsource feed provides push notifications that can be consumed in the form of DOM events in the browser. Refer to the <a href="http://www.w3.org/TR/eventsource/" target="_blank" rel="noopener">W3C eventsource specification</a> for further details. CouchDB honors the Last-Event-ID header, and if it’s present it will take precedence over the since query parameter.</p><pre><code class="js"><span class="hljs-comment">// define the event handling function</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.EventSource) {  <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"/somedatabase/_changes?feed=eventsource"</span>);  source.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{    alert(<span class="hljs-string">'EventSource failed.'</span>);  };  <span class="hljs-keyword">var</span> results = [];  <span class="hljs-keyword">var</span> sourceListener = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{    <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(e.data);    results.push(data);  };  <span class="hljs-comment">// start listening for events</span>  source.addEventListener(<span class="hljs-string">'message'</span>, sourceListener, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// stop listening for events</span>  source.removeEventListener(<span class="hljs-string">'message'</span>, sourceListener, <span class="hljs-literal">false</span>);}</code></pre><ul><li><a href="http://guide.couchdb.org/draft/notifications.html" target="_blank" rel="noopener">http://guide.couchdb.org/draft/notifications.html</a></li><li><a href="http://docs.couchdb.org/en/2.1.1/api/database/changes.html" target="_blank" rel="noopener">http://docs.couchdb.org/en/2.1.1/api/database/changes.html</a> 这个是最新的</li><li><a href="http://docs.couchdb.org/en/1.4.0/changes.html" target="_blank" rel="noopener">http://docs.couchdb.org/en/1.4.0/changes.html</a> 这个写得简单清晰点。</li><li><a href="https://www.npmjs.com/package/couch-streams" target="_blank" rel="noopener">https://www.npmjs.com/package/couch-streams</a></li></ul><h3 id="shi-tu-view-yu-mapreduce-cha-xun" class="heading-control">视图（view） 与 Map/Reduce 查询<a class="heading-anchor" href="#shi-tu-view-yu-mapreduce-cha-xun" aria-hidden="true"></a></h3><p>视图是 CouchDB 中文档的呈现方式。在很多情况下，应用都需要对文档进行一定的处理，包括过滤、组织、聚合和生成报表等。在关系数据库中，这通常是通过 SQL 语句来完成的。 CouchDB 中的视图声明了如何从文档中提取数据，以及如何对提取出来的数据进行处理。</p><p>CouchDB 中有两种视图：永久视图和临时视图。永久视图保存在设计文档的views字段中。临时视图是通过发送 POST 请求到 <code>/[databasename]/_temp_view</code> 来执行的。临时视图只在开发测试中使用，因为它是即时生成的，性能比较差；永久视图的运行结果可以被 CouchDB 缓存，因此一般用在生产环境中。</p><p>视图的运行由专门的视图服务器来完成。 CouchDB 中默认的视图定义语言是 JavaScript 。 CouchDB 中的视图运行使用的是 MapReduce 编程模型。每个视图的定义中至少需要提供 Map 方法，Reduce 方法是可选的。</p><p>Map 方法的参数只有一个，就是当前的文档对象。 Map 方法的实现需要根据文档对象的内容，确定是否要输出结果。如果需要输出的话，可以通过<code>emit</code>来完成。<code>emit</code>方法有两个参数，分别是key和value，分别表示输出结果的键和值。使用什么样的键和值应该根据视图的实际需要来确定。当希望对文档的某个字段进行排序和过滤操作的时候，应该把该字段作为键（key）或是键的一部分；value的值可以提供给 Reduce 方法使用，也可能会出现在最终的结果中。可以作为键的不仅是简单数据类型，也可以是任意的 JSON 对象。比如<code>emit([doc.title, doc.price], doc)</code>中，使用数组作为键。</p><pre><code class="js"><span class="hljs-comment">//map</span><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{  <span class="hljs-comment">//checks whether our document has a date and a title attribute</span>  <span class="hljs-keyword">if</span>(doc.date &amp;&amp; doc.title) {      <span class="hljs-comment">//The most important feature of a view result is that it is sorted by key.</span>      <span class="hljs-comment">//emit key, value</span>      emit(doc.date, doc.title);  }}</code></pre><p>通过 Map 方法输出的结果称为中间结果。中间结果可以通过 Reduce 方法来进一步做聚集操作。聚集操作是对结果中键（key）相同的数据集合来进行的。 Reduce 方法的输入不仅是 Map 方法输出的中间结果，也可以是上一次 Reduce 方法的结果，后面这种情况称为 <code>rereduce</code> 。 Reduce 方法的参数有三个：key、values和rereduce，分别表示键、值和是否是 rereduce 。由于 rereduce 情况的存在，Reduce 方法一般需要处理两种情况：</p><ul><li>传入的参数<code>rereduce</code>的值为false：这表明 Reduce 方法的输入是 Map 方法输出的中间结果。参数key的值是一个数组，对应于中间结果中的每条记录。该数组的每个元素都是一个包含两个元素的数组，第一个元素是在 Map 方法中通过emit输出的键（key），第二个元素是记录所在的文档 ID 。参数values的值是一个数组，对应于 Map 方法中通过emit输出的值（value）。</li><li>传入的参数rereduce的值为true：这表明 Reduce 方法的输入是上次 Reduce 方法的输出。参数key的值为null。参数values的值是一个数组，对应于上次 Reduce 方法的输出结果。</li></ul><pre><code class="js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">keys, values, rereduce</span>) </span>{    <span class="hljs-keyword">return</span> sum(values);}</code></pre><pre><code class="js">{  <span class="hljs-string">"_id"</span>: <span class="hljs-string">"_design/foo"</span>,  <span class="hljs-string">"views"</span>: {    <span class="hljs-string">"bar"</span>: {      <span class="hljs-string">"map"</span>: <span class="hljs-string">"function (doc) { emit(doc.author, 1); }"</span>,      <span class="hljs-string">"reduce"</span>: <span class="hljs-string">"_sum"</span> <span class="hljs-comment">//use the buildin reduce func to speedup.</span>      <span class="hljs-comment">//"reduce": "function (keys, values, rereduce) { return sum(values); }"</span>    }  }}</code></pre><p><a href="http://docs.couchdb.org/en/2.1.0/ddocs/ddocs.html#reducefun-builtin" target="_blank" rel="noopener">http://docs.couchdb.org/en/2.1.0/ddocs/ddocs.html#reducefun-builtin</a></p><h4 id="shi-tu-view-de-cha-xun-can-shu" class="heading-control">视图(View)的查询参数<a class="heading-anchor" href="#shi-tu-view-de-cha-xun-can-shu" aria-hidden="true"></a></h4><p>在查询视图的时候，支持以下的参数查询：</p><ul><li>conflicts (boolean) – Includes conflicts information in response. Ignored if include_docs isn’t true. Default is false</li><li>descending (boolean) – Return the documents in descending by key order. Default is false</li><li>endkey (json) – Stop returning records when the specified key is reached. Optional</li><li>end_key (json) – Alias for endkey param</li><li>endkey_docid (string) – Stop returning records when the specified document ID is reached. Requires endkey to be specified for this to have any effect. Optional</li><li>end_key_doc_id (string) – Alias for endkey_docid param</li><li>group (boolean) – Group the results using the reduce function to a group or single row. Default is false</li><li>group_level (number) – Specify the group level to be used. Optional</li><li>include_docs (boolean) – Include the associated document with each row. Default is false.</li><li>attachments (boolean) – Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.</li><li>att_encoding_info (boolean) – Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.</li><li>inclusive_end (boolean) – Specifies whether the specified end key should be included in the result. Default is true</li><li>key (json) – Return only documents that match the specified key. Optional</li><li>keys (json-array) – Return only documents where the key matches one of the keys specified in the array. Optional</li><li>limit (number) – Limit the number of the returned documents to the specified number. Optional</li><li>reduce (boolean) – Use the reduction function. Default is true</li><li>skip (number) – Skip this number of records before starting to return the results. Default is 0</li><li>sorted (boolean) – Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true</li><li>stable (boolean) – Whether or not the view results should be returned from a stable set of shards. Default is false. Optional</li><li>stale (string) – Allow the results from a stale view to be used. Supported values: ok, update_after and false. ok is equivalent to stable=true&amp;update=false. update_after is equivalent to stable=true&amp;update=lazy. false is equivalent to stable=false&amp;update=true. Optional</li><li>startkey (json) – Return records starting with the specified key. Optional</li><li>start_key (json) – Alias for startkey param</li><li>startkey_docid (string) – Return records starting with the specified document ID. Requires startkey to be specified for this to have any effect. Optional</li><li>start_key_doc_id (string) – Alias for startkey_docid param</li><li>update (string) – Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. Optional</li><li>update_seq (boolean) – Response includes an update_seq value indicating which sequence id of the database the view reflects. Default is false.</li></ul><h3 id="kuo-zhan-gai-nian" class="heading-control">扩展概念<a class="heading-anchor" href="#kuo-zhan-gai-nian" aria-hidden="true"></a></h3><h4 id="fu-jian-attatchment" class="heading-control">附件(attatchment)<a class="heading-anchor" href="#fu-jian-attatchment" aria-hidden="true"></a></h4><p>CouchDB 中也可以保存二进制文件。这些文件是以文档的附件形式存储的。 CouchDB 支持两种形式的附件：一种是内嵌型的，附件是以 base64 编码的格式作为文档的一个字段保存；另一种是独立型，附件是独立于文档保存和管理的。附件的存在使得可以在 CouchDB 中保存 Web 应用中的 HTML、CSS 和 JavaScript 文件。每个附件都包含名称、MIME 类型和数据等三项内容。</p><p>在请求文档的时候，内嵌型附件的实际数据默认是不包含的，包含的只是附件的元数据:</p><pre><code class="js">{   <span class="hljs-string">"_id"</span>: <span class="hljs-string">"testdoc"</span>,   <span class="hljs-string">"_rev"</span>: <span class="hljs-string">"3-1364618102"</span>,   <span class="hljs-string">"_attachments"</span>: {       <span class="hljs-string">"Screenshot.png"</span>: {           <span class="hljs-string">"stub"</span>: <span class="hljs-literal">true</span>,           <span class="hljs-string">"content_type"</span>: <span class="hljs-string">"image/png"</span>,           <span class="hljs-string">"length"</span>: <span class="hljs-number">164279</span>       }   } }</code></pre><p>独立型附件可以在不改变文档的情况下，对附件进行操作。另外，不需要对附件进行 base64 编码。要创建独立型附件，只需要发送 PUT 请求到<code>databasename/doc_id/attachment?rev=rev_id</code>就可以创建或更新一个名为attachment的附件。 PUT 请求的内容类型（Content-Type）和内容指明了附件的类型和数据。</p><h4 id="she-ji-wen-dang-design-document" class="heading-control">设计文档(design document)<a class="heading-anchor" href="#she-ji-wen-dang-design-document" aria-hidden="true"></a></h4><p>设计文档是一类特殊的文档，其 ID 必须以<code>_design/</code>开头。设计文档的存在是使用 CouchDB 开发 Web 应用的基础。在 CouchDB 中，一个 Web 应用是与一个设计文档相对应的。在设计文档中可以包含一些特殊的字段，其中包括：</p><ul><li><code>views</code>: 包含永久的视图定义；</li><li><code>shows</code>: 包含把文档转换成非 JSON 格式的方法；</li><li><code>lists</code>: 包含把视图运行结果转换成非 JSON 格式的方法；</li><li><code>validate_doc_update</code>: 包含验证文档更新是否有效的方法。</li><li><code>updatefun(doc, req)</code>: 服务器端进行<a href="http://docs.couchdb.org/en/2.1.1/ddocs/ddocs.html#update-functions" target="_blank" rel="noopener">更新文档处理器</a>，在这里可以修改文档的值。</li></ul><h5 id="validate_doc_update" class="heading-control"><code>validate_doc_update</code><a class="heading-anchor" href="#validate_doc_update" aria-hidden="true"></a></h5><p><code>function(newDoc, oldDoc, userCtx, secObj)</code></p><p>回调函数参数说明:</p><ul><li><code>newDoc</code>: incoming</li><li><code>oldDoc</code>: 如果是新建则无。</li><li><code>userCtx</code>:当前登录的用户的信息(来自<code>_users</code>数据库)<ul><li>db: 当前数据库名称</li><li>name: 用户名</li><li>roles: 角色列表</li></ul></li><li><code>secObj</code>: Security Object(来自 <code>_security</code> 数据库)<ul><li>admins: Roles/Users with admin privileges<ul><li>roles [array] List of roles with parent privilege</li><li>names [array] List of users with parent privilege</li></ul></li><li>members Roles/Users with non-admin privileges<ul><li>roles [array] List of roles with parent privilege</li><li>names [array] List of users with parent privilege</li></ul></li></ul></li></ul><p>这个例子是 <code>_users</code> 数据库的，用来在注册/编辑/删除系统用户时候对数据进行验证。</p><pre><code class="js">{  <span class="hljs-string">"_id"</span>: <span class="hljs-string">"_design/_auth"</span>,  <span class="hljs-string">"_rev"</span>: <span class="hljs-string">"1-c79bc00c889ce9b912fbde8a3f52de37"</span>,  <span class="hljs-string">"language"</span>: <span class="hljs-string">"javascript"</span>,  <span class="hljs-string">"validate_doc_update"</span>: <span class="hljs-string">"function(newDoc, oldDoc, userCtx, secObj){...see below...}"</span>}</code></pre><pre><code class="js"><span class="hljs-comment">//validate_doc_update</span><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newDoc, oldDoc, userCtx, secObj</span>) </span>{    <span class="hljs-keyword">if</span> (newDoc._deleted === <span class="hljs-literal">true</span>) {        <span class="hljs-comment">// allow deletes by admins and matching users</span>        <span class="hljs-comment">// without checking the other fields</span>        <span class="hljs-keyword">if</span> ((userCtx.roles.indexOf(<span class="hljs-string">'_admin'</span>) !== <span class="hljs-number">-1</span>) ||            (userCtx.name == oldDoc.name)) {            <span class="hljs-keyword">return</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Only admins may delete other user docs.'</span>});        }    }    <span class="hljs-keyword">if</span> (newDoc.type !== <span class="hljs-string">'user'</span>) {        <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span> : <span class="hljs-string">'doc.type must be user'</span>});    } <span class="hljs-comment">// we only allow user docs for now</span>    <span class="hljs-keyword">if</span> (!newDoc.name) {        <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'doc.name is required'</span>});    }    <span class="hljs-keyword">if</span> (!newDoc.roles) {        <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'doc.roles must exist'</span>});    }    <span class="hljs-keyword">if</span> (!isArray(newDoc.roles)) {        <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'doc.roles must be an array'</span>});    }    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>; idx &lt; newDoc.roles.length; idx++) {        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newDoc.roles[idx] !== <span class="hljs-string">'string'</span>) {            <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'doc.roles can only contain strings'</span>});        }    }    <span class="hljs-keyword">if</span> (newDoc._id !== (<span class="hljs-string">'org.couchdb.user:'</span> + newDoc.name)) {        <span class="hljs-keyword">throw</span>({            <span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Doc ID must be of the form org.couchdb.user:name'</span>        });    }    <span class="hljs-keyword">if</span> (oldDoc) { <span class="hljs-comment">// validate all updates</span>        <span class="hljs-keyword">if</span> (oldDoc.name !== newDoc.name) {            <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Usernames can not be changed.'</span>});        }    }    <span class="hljs-keyword">if</span> (newDoc.password_sha &amp;&amp; !newDoc.salt) {        <span class="hljs-keyword">throw</span>({            <span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Users with password_sha must have a salt.'</span> +                <span class="hljs-string">'See /_utils/script/couch.js for example code.'</span>        });    }    <span class="hljs-keyword">if</span> (newDoc.password_scheme === <span class="hljs-string">"pbkdf2"</span>) {        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(newDoc.iterations) !== <span class="hljs-string">"number"</span>) {            <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">"iterations must be a number."</span>});        }        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(newDoc.derived_key) !== <span class="hljs-string">"string"</span>) {            <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">"derived_key must be a string."</span>});        }    }    <span class="hljs-keyword">var</span> is_server_or_database_admin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userCtx, secObj</span>) </span>{        <span class="hljs-comment">// see if the user is a server admin</span>        <span class="hljs-keyword">if</span>(userCtx.roles.indexOf(<span class="hljs-string">'_admin'</span>) !== <span class="hljs-number">-1</span>) {            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// a server admin</span>        }        <span class="hljs-comment">// see if the user a database admin specified by name</span>        <span class="hljs-keyword">if</span>(secObj &amp;&amp; secObj.admins &amp;&amp; secObj.admins.names) {            <span class="hljs-keyword">if</span>(secObj.admins.names.indexOf(userCtx.name) !== <span class="hljs-number">-1</span>) {                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// database admin</span>            }        }        <span class="hljs-comment">// see if the user a database admin specified by role</span>        <span class="hljs-keyword">if</span>(secObj &amp;&amp; secObj.admins &amp;&amp; secObj.admins.roles) {            <span class="hljs-keyword">var</span> db_roles = secObj.admins.roles;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>; idx &lt; userCtx.roles.length; idx++) {                <span class="hljs-keyword">var</span> user_role = userCtx.roles[idx];                <span class="hljs-keyword">if</span>(db_roles.indexOf(user_role) !== <span class="hljs-number">-1</span>) {                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// role matches!</span>                }            }        }        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// default to no admin</span>    }    <span class="hljs-keyword">if</span> (!is_server_or_database_admin(userCtx, secObj)) {        <span class="hljs-keyword">if</span> (oldDoc) { <span class="hljs-comment">// validate non-admin updates</span>            <span class="hljs-keyword">if</span> (userCtx.name !== newDoc.name) {                <span class="hljs-keyword">throw</span>({                    <span class="hljs-attr">forbidden</span>: <span class="hljs-string">'You may only update your own user document.'</span>                });            }            <span class="hljs-comment">// validate role updates</span>            <span class="hljs-keyword">var</span> oldRoles = (oldDoc.roles || []).sort();            <span class="hljs-keyword">var</span> newRoles = newDoc.roles.sort();            <span class="hljs-keyword">if</span> (oldRoles.length !== newRoles.length) {                <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Only _admin may edit roles'</span>});            }            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; oldRoles.length; i++) {                <span class="hljs-keyword">if</span> (oldRoles[i] !== newRoles[i]) {                    <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Only _admin may edit roles'</span>});                }            }        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newDoc.roles.length &gt; <span class="hljs-number">0</span>) {            <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Only _admin may set roles'</span>});        }    }    <span class="hljs-comment">// no system roles in users db</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; newDoc.roles.length; i++) {        <span class="hljs-keyword">if</span> (newDoc.roles[i][<span class="hljs-number">0</span>] === <span class="hljs-string">'_'</span>) {            <span class="hljs-keyword">throw</span>({                <span class="hljs-attr">forbidden</span>:                <span class="hljs-string">'No system roles (starting with underscore) in users db.'</span>            });        }    }    <span class="hljs-comment">// no system names as names</span>    <span class="hljs-keyword">if</span> (newDoc.name[<span class="hljs-number">0</span>] === <span class="hljs-string">'_'</span>) {        <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Username may not start with underscore.'</span>});    }    <span class="hljs-keyword">var</span> badUserNameChars = [<span class="hljs-string">':'</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; badUserNameChars.length; i++) {        <span class="hljs-keyword">if</span> (newDoc.name.indexOf(badUserNameChars[i]) &gt;= <span class="hljs-number">0</span>) {            <span class="hljs-keyword">throw</span>({<span class="hljs-attr">forbidden</span>: <span class="hljs-string">'Character `'</span> + badUserNameChars[i] +                    <span class="hljs-string">'` is not allowed in usernames.'</span>});        }    }}</code></pre><h2 id="couchapp" class="heading-control">CouchApp<a class="heading-anchor" href="#couchapp" aria-hidden="true"></a></h2><p>由于 CouchDB 的 REST API 使用 JSON 作为展现形式，因此使用 CouchDB 的 Web 应用只需要编写浏览器端的代码就可以使用 JavaScript 与 CouchDB 进行交互；而 CouchDB 所支持的附件功能，又使得浏览器端的 HTML、JavaScript 和 CSS 代码可以直接存放在 CouchDB 中。这样 CouchDB 中不但保存了 Web 应用的数据，也保存了 Web 应用的逻辑。也就是说，只需要 CouchDB 就可以构建一个完整的 Web 应用运行环境。</p><ul><li><a href="https://github.com/couchapp/couchapp" target="_blank" rel="noopener">https://github.com/couchapp/couchapp</a></li><li><a href="https://github.com/jo/couchdb-push" target="_blank" rel="noopener">https://github.com/jo/couchdb-push</a> Nodejs</li></ul><p>结合CouchDB自带virtualhosts和pretty-urls，就可以实现将页面url地址重写到root.</p><ul><li><a href="http://docs.couchdb.org/en/1.3.0/pretty_urls.html" target="_blank" rel="noopener">http://docs.couchdb.org/en/1.3.0/pretty_urls.html</a></li><li><a href="https://stackoverflow.com/questions/35643281/rewrite-urls-in-couchdb-pouchdb-server" target="_blank" rel="noopener">https://stackoverflow.com/questions/35643281/rewrite-urls-in-couchdb-pouchdb-server</a></li></ul><h3 id="couchapp" class="heading-control">Couchapp<a class="heading-anchor" href="#couchapp" aria-hidden="true"></a></h3><pre><code class="bash">python2.7&gt; pip install --user couchappcouchapp init myapp<span class="hljs-built_in">cd</span> myapp</code></pre><h4 id="change-your-app-id" class="heading-control">Change your App ID<a class="heading-anchor" href="#change-your-app-id" aria-hidden="true"></a></h4><p>open the <code>_id</code> file: change your app name.</p><h4 id="set-config" class="heading-control">set config<a class="heading-anchor" href="#set-config" aria-hidden="true"></a></h4><p><code>.couchapprc</code>:</p><pre><code class="js">{  <span class="hljs-string">"env"</span> : {    <span class="hljs-string">"default"</span> : {      <span class="hljs-string">"db"</span> : <span class="hljs-string">"http://admin:secret@localhost:5984/test"</span>    },    <span class="hljs-string">"prod"</span> : {      <span class="hljs-string">"db"</span> : <span class="hljs-string">"http://admin:password@myhost.com/mydb"</span>    }  }}</code></pre><p>couchapp push<br>couchapp push prod</p><h4 id="add-some-web-pages" class="heading-control">Add Some Web Pages<a class="heading-anchor" href="#add-some-web-pages" aria-hidden="true"></a></h4><p>Now we are going to add a index page for our CouchApp. So we can place the index.html under _attachments. CouchDB can directly serve our attachments as static files.</p><pre><code class="html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>CouchApp<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello CouchApp!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h4 id="push-your-couchapp" class="heading-control">Push your CouchApp<a class="heading-anchor" href="#push-your-couchapp" aria-hidden="true"></a></h4><p>Now that we have created our basic application, it’s time to push it to our CouchDB server. Our CouchDB server is at the url <a href="http://127.0.0.1:5984" target="_blank" rel="noopener">http://127.0.0.1:5984</a> and we want to push our app in the database testdb:</p><pre><code class="bash">$ couchapp push testdb</code></pre><p>Go on <a href="http://127.0.0.1:5984/testdb/_design/myapp/index.html" target="_blank" rel="noopener">http://127.0.0.1:5984/testdb/_design/myapp/index.html</a>, you will see.</p><h2 id="fauxton" class="heading-control"><a href="https://github.com/apache/couchdb-fauxton/" target="_blank" rel="noopener">Fauxton</a><a class="heading-anchor" href="#fauxton" aria-hidden="true"></a></h2><p>是Couchdb自带的WebUI: <a href="http://127.0.0.1:5984/_utils/index.html" target="_blank" rel="noopener">http://127.0.0.1:5984/_utils/index.html</a></p><p>似乎还没有启用，所以暂时没有语法高亮，但：<br>app/addons/components/components/codeeditor.js</p><p><a href="https://github.com/apache/couchdb-nano" target="_blank" rel="noopener">CouchDB Nano Client NodeJS</a></p><h2 id="couchdb-as-graph" class="heading-control">CouchDB As Graph<a class="heading-anchor" href="#couchdb-as-graph" aria-hidden="true"></a></h2><p><a href="https://stackoverflow.com/questions/25949524/implications-of-modeling-a-graph-in-couchdb" target="_blank" rel="noopener">https://stackoverflow.com/questions/25949524/implications-of-modeling-a-graph-in-couchdb</a></p><p>I’ve been toying with modeling a graph structure (property graph with named relationships) in couchdb and would like to know what are the potential bottlenecks in performance that I will find.</p><p>I’m using the following principles:</p><pre><code>Keep documents small.Try to embed as little as possible.Record all relationships between documents as a new document (a link).</code></pre><p>It seems that all these principles are in contradiction with couchdb’s philosophy. But bare with me.</p><p>With this principles, for example, tagging a person becomes three documents:</p><pre><code class="js">{ <span class="hljs-attr">_id</span>: <span class="hljs-string">'10'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'person'</span>, <span class="hljs-string">'name'</span>: <span class="hljs-string">'John Doe'</span> }{ <span class="hljs-attr">_id</span>: <span class="hljs-string">'20'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'tag'</span>, <span class="hljs-string">'name'</span>: <span class="hljs-string">'Important'</span> }{ <span class="hljs-attr">_id</span>: <span class="hljs-string">'30'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'link'</span>, <span class="hljs-attr">from</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'tag'</span> }</code></pre><p>I have also created the following views in a _design document called links:</p><pre><code class="js">{  <span class="hljs-attr">outgoing</span>: {    <span class="hljs-attr">map</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{      <span class="hljs-keyword">if</span> (doc.type == <span class="hljs-string">'link'</span>) {        emit([doc.from, doc.name], {<span class="hljs-attr">_id</span>: doc.to});      }    }  },  <span class="hljs-attr">incoming</span>: {    <span class="hljs-attr">map</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{      <span class="hljs-keyword">if</span> (doc.type == <span class="hljs-string">'link'</span>) {        emit([doc.to, doc.name], { <span class="hljs-attr">_id</span>: doc.from });      }    }  }}</code></pre><p>I can get all the links incoming or outgoing from a document with these urls:</p><pre><code>http://host/db/_design/links/_view/incoming?startkey=[&quot;10&quot;]&amp;endkey=[&quot;10&quot;,{}]http://host/db/_design/links/_view/outgoing?startkey=[&quot;10&quot;]&amp;endkey=[&quot;10&quot;,{}]</code></pre><p>I can even get all the links by name with these urls:</p><pre><code>http://host/db/_design/links/_view/incoming?startkey=[&quot;10&quot;,&quot;tag&quot;]&amp;endkey=[&quot;10&quot;,&quot;tag&quot;,{}]http://host/db/_design/links/_view/outgoing?startkey=[&quot;10&quot;,&quot;tag&quot;]&amp;endkey=[&quot;10&quot;,&quot;tag&quot;,{}]</code></pre><p>And if I include the include_docs=true parameter I get the documents referenced by the link; either incoming or outgoing. So far so good. There is a graph structure and a way to query it, albeit on a node by node basis.</p><p>Good things about this approach:</p><pre><code>It is a general way of storing all relationships. Not necessarily tags, but every relationship.You can change the tag name quickly, without changing every person tagged.You can merge persons or tags and just update the link documents, which should be very simple.Tagging when using replication does not change the documents being tagged or the tags themselves. Just add or delete a tiny link document.It would be easy to keep a history of tags for each element.</code></pre><p>Bad things, and where I need your help:</p><pre><code>Query for a list of people with their tags is not trivial. In general, querying for a list of documents and their relationships is a very expensive operation that requires many hits.Updating the database and keeping it consistent could be a problem. Maybe this is something that will never go away when using couch.Doing 'maintenance' on the database, like finding orphan links, could be expensive. Perhaps the database requires garbage collection?Visualizing and manipulating this graph structure is neither intuitive nor simple, and applications developed on top of it are responsible for all the graph structure management (which is a bit scary!).</code></pre><p>So back to my questions:</p><pre><code>What are the potencial bottlenecks to expect?Will this approach scale to millions of records?How to do traversing of this structure efficiently without having to do many server hits?</code></pre><p><a href="http://grokbase.com/t/couchdb/user/09735ya0m7/map-reduce-graph-traversal-in-couchdb" target="_blank" rel="noopener">http://grokbase.com/t/couchdb/user/09735ya0m7/map-reduce-graph-traversal-in-couchdb</a></p><p><a href="http://grokbase.com/t/couchdb/user/115gv4yhr6/data-js-a-graph-manipulation-framework-on-top-of-couchdb" target="_blank" rel="noopener">http://grokbase.com/t/couchdb/user/115gv4yhr6/data-js-a-graph-manipulation-framework-on-top-of-couchdb</a></p><p>就是这个： <a href="https://github.com/substance/data" target="_blank" rel="noopener">https://github.com/substance/data</a><br><a href="https://github.com/substance/substance" target="_blank" rel="noopener">https://github.com/substance/substance</a></p><p><a href="http://probablyprogramming.com/2008/07/04/storing-hierarchical-data-in-couchdb" target="_blank" rel="noopener">http://probablyprogramming.com/2008/07/04/storing-hierarchical-data-in-couchdb</a><br><a href="https://stackoverflow.com/questions/6129561/retrieving-hierarchical-nested-data-from-couchdb" target="_blank" rel="noopener">https://stackoverflow.com/questions/6129561/retrieving-hierarchical-nested-data-from-couchdb</a></p><hr><p>CouchBase已经fork了很远以前，查询语言也不一样。</p><p>CouchDB的手机端用PouchDB. CouchBase也有CouchBaseLite（可以同步到CouchDB）.<br>CouchDB在单机时候就要预先订好shard数量。</p><h2 id="couchdb-client" class="heading-control">CouchDB Client<a class="heading-anchor" href="#couchdb-client" aria-hidden="true"></a></h2><ul><li>PouchDB<ul><li><a href="https://github.com/pouchdb/pouchdb/issues/2521" target="_blank" rel="noopener">https://github.com/pouchdb/pouchdb/issues/2521</a></li></ul></li></ul><pre><code class="js"><span class="hljs-keyword">var</span> PouchDB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pouchdb'</span>);<span class="hljs-keyword">var</span> pouch = <span class="hljs-keyword">new</span> PouchDB(<span class="hljs-string">'testdb_changes'</span>);<span class="hljs-keyword">var</span> remotePouch = <span class="hljs-keyword">new</span> PouchDB(<span class="hljs-string">'http://localhost:5984/testdb_changes'</span>);<span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>);pouch.bulkDocs([{<span class="hljs-attr">_id</span>: <span class="hljs-string">'1'</span>}, {<span class="hljs-attr">_id</span>: <span class="hljs-string">'2'</span>}]).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{    pouch.replicate.to(remotePouch).on(<span class="hljs-string">'complete'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">changes</span>) </span>{      resolve(changes);    }).on(<span class="hljs-string">'error'</span>, reject);  });}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">change</span>) </span>{  <span class="hljs-keyword">var</span> lastSeq = change.last_seq;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"lastSeq is: "</span> + lastSeq);  <span class="hljs-keyword">return</span> pouch.put({<span class="hljs-attr">_id</span>: <span class="hljs-string">'3'</span>}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">return</span> pouch.changes({<span class="hljs-attr">since</span>: lastSeq});  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">changes</span>) </span>{    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'local changes are: '</span> + <span class="hljs-built_in">JSON</span>.stringify(changes));    <span class="hljs-keyword">return</span> remotePouch.allDocs();  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'remote pouch contains: '</span> + <span class="hljs-built_in">JSON</span>.stringify(res));    <span class="hljs-keyword">return</span> pouch.allDocs();  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'local pouch contains: '</span> + <span class="hljs-built_in">JSON</span>.stringify(res));  });}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{  <span class="hljs-built_in">console</span>.log(err);});</code></pre><ul><li><a href="https://github.com/pouchdb/pouchdb/issues/5713" target="_blank" rel="noopener">https://github.com/pouchdb/pouchdb/issues/5713</a><ul><li><code>change</code> 事件中有 <code>pending</code> 属性检测同步进度。</li></ul></li></ul><pre><code class="js"><span class="hljs-keyword">var</span> pendingMax = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> batch_size = <span class="hljs-number">1000</span>;    <span class="hljs-comment">// must match your replication options</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProgress</span>(<span class="hljs-params">pending</span>) </span>{  <span class="hljs-keyword">var</span> progress;  pendingMax = pendingMax &lt; pending ? pending + batch_size : pendingMax;  <span class="hljs-comment">// first time capture</span>  <span class="hljs-comment">//pendingMax = pendingMax &lt; pending ? pending : pendingMax;  // wouldn't use batch size in the calculation</span>  <span class="hljs-keyword">if</span> (pendingMax &gt; <span class="hljs-number">0</span>) {    progress = <span class="hljs-number">1</span> - pending/pendingMax;    <span class="hljs-keyword">if</span> (pending === <span class="hljs-number">0</span>) {      pendingMax = <span class="hljs-number">0</span>;    <span class="hljs-comment">// reset for live/next replication</span>    }  } <span class="hljs-keyword">else</span> {    progress = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 100%</span>  }  <span class="hljs-keyword">return</span> progress;}<span class="hljs-keyword">var</span> replication = db.replicate.from(remote, {  <span class="hljs-attr">live</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">retry</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">batches_limit</span>: <span class="hljs-number">10</span>,  <span class="hljs-attr">batch_size</span>: <span class="hljs-number">1000</span>      <span class="hljs-comment">// must match above batch_size</span>}).on(<span class="hljs-string">'change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">info</span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Replication Progress'</span>, getProgress(info.pending));})</code></pre><h3 id="rxdb" class="heading-control">RxDB<a class="heading-anchor" href="#rxdb" aria-hidden="true"></a></h3><ul><li>RxDB: 内部使用PouchDB，<ul><li>不爽的地方：一个Collection就是一个PouchDB数据库。</li><li>RXJS支持。</li></ul></li></ul><p>rxdb 不支持utf8(unicode)字段名。完全没有必要es5部分支持，es6完全支持unicode 标识符：<br><a href="https://mathiasbynens.be/notes/javascript-identifiers" target="_blank" rel="noopener">https://mathiasbynens.be/notes/javascript-identifiers</a><br><a href="https://mathiasbynens.be/notes/javascript-identifiers-es6" target="_blank" rel="noopener">https://mathiasbynens.be/notes/javascript-identifiers-es6</a><br><a href="https://stackoverflow.com/questions/1661197/what-characters-are-valid-for-javascript-variable-names" target="_blank" rel="noopener">https://stackoverflow.com/questions/1661197/what-characters-are-valid-for-javascript-variable-names</a></p><pre><code class="js"><span class="hljs-comment">//plugins/schema-check.js</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFieldNameRegex</span>(<span class="hljs-params">fieldName</span>) </span>{    <span class="hljs-keyword">if</span> (fieldName == <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> ([<span class="hljs-string">'properties'</span>, <span class="hljs-string">'language'</span>].includes(fieldName))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`fieldname is not allowed: <span class="hljs-subst">${fieldName}</span>`</span>);<span class="hljs-comment">/* //comments for support unicode:    const regexStr = '^[a-zA-Z][[a-zA-Z0-9_]*]?[a-zA-Z0-9]$';    const regex = new RegExp(regexStr);    if (!fieldName.match(regex)) {        throw RxError.newRxError(            'fieldnames do not match the regex', {                regex: regexStr,                fieldName            }        );    }*/</span>};</code></pre><p>目前PouchDB有个问题没有解决，直接会导致本地数据库越来越大，同时也难以LRU。<br><a href="https://github.com/pouchdb/pouchdb/issues/802" target="_blank" rel="noopener">https://github.com/pouchdb/pouchdb/issues/802</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CouchDB 是一个面向文档的&lt;code&gt;NoSQL&lt;/code&gt;数据库。CouchDB还可以把整个H5网站直接放到数据库中，这称为&lt;code&gt;CouchApp&lt;/code&gt;，详见后述。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;source-build&quot; class=&quot;heading-control&quot;&gt;Source Build&lt;a class=&quot;heading-anchor&quot; href=&quot;#source-build&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo apt-get --no-install-recommends -y install \
    build-essential pkg-config erlang erlang-reltool \
    libicu-dev libcurl4-openssl-dev
sudo apt-get install devscripts libnspr4-dev pkg-kde-tools
git &lt;span class=&quot;hljs-built_in&quot;&gt;clone&lt;/span&gt; https://github.com/apache/couchdb
git &lt;span class=&quot;hljs-built_in&quot;&gt;clone&lt;/span&gt; https://github.com/apache/couchdb-pkg
&lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; couchdb-pkg
make couch-js-debs PLATFORM=bionic &lt;span class=&quot;hljs-comment&quot;&gt;# howto use it? still cannot find jsapi.h&lt;/span&gt;
sudo dpkg -i js/couch-libmozjs185-*.deb

&lt;span class=&quot;hljs-comment&quot;&gt;# build dpkg needed:&lt;/span&gt;
sudo apt install dh-exec dh-systemd nodejs python-sphinx

make build-couch $(lsb_release -cs) PLATFORM=$(lsb_release -cs)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;gai-nian&quot; class=&quot;heading-control&quot;&gt;概念&lt;a class=&quot;heading-anchor&quot; href=&quot;#gai-nian&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Database" scheme="https://riceball.me/categories/Database/"/>
    
      <category term="NoSQL" scheme="https://riceball.me/categories/Database/NoSQL/"/>
    
      <category term="CouchDB" scheme="https://riceball.me/categories/Database/NoSQL/CouchDB/"/>
    
    
      <category term="nosql" scheme="https://riceball.me/tags/nosql/"/>
    
      <category term="couchdb" scheme="https://riceball.me/tags/couchdb/"/>
    
      <category term="database" scheme="https://riceball.me/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Ionic Framework</title>
    <link href="https://riceball.me/article/ionic-framework/"/>
    <id>https://riceball.me/article/ionic-framework/</id>
    <published>2017-12-07T20:53:56.000Z</published>
    <updated>2019-11-25T21:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ionic-framework" class="heading-control">Ionic Framework<a class="heading-anchor" href="#ionic-framework" aria-hidden="true"></a></h1><p>Ionic 4 已经彻底解耦用户界面和框架,你可以在<code>angular</code>和<code>react</code>(甚至<code>vue</code>)之间选择.</p><pre><code>npm i -g ionic</code></pre><p>已经是用angluar-cli(angular6配套的)。已经使用了angular的route.</p><p><a href="https://update.angular.io" target="_blank" rel="noopener">https://update.angular.io</a> 从老版本Angular升级到Angular6的指南。</p><p>现在可以大致介绍下使用方法。更完整的教程请自行阅读：</p><ul><li><a href="https://yanxiaodi.gitbooks.io/ionic2-guide/content/" target="_blank" rel="noopener">Ionic 2 With TypeScript 入门</a></li><li><a href="https://meiminjun.github.io/2016/08/01/ionic2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A%E4%B8%80%E3%80%8B/" target="_blank" rel="noopener">ionic2学习笔记《一》</a></li></ul><p>如果与上述的教程有冲突，请留意文档时间，以最新的为准。</p><p>环境要求</p><ul><li>Node LTS版本(官方推荐)</li></ul><p>首先安装</p><pre><code>npm install -g ionic cordova</code></pre><h2 id="chuang-jian-ying-yong" class="heading-control">创建应用<a class="heading-anchor" href="#chuang-jian-ying-yong" aria-hidden="true"></a></h2><p><strong>注意：如果是windows下，请勿在cygwin或msys2终端下运行 <code>ionic</code> 命令行工具。</strong></p><p>通过脚手架工具<code>ionic</code>创建您的H5应用。</p><pre><code>ionic start --type=angular MyApp conference</code></pre><blockquote><p>conference 参数的意思是下载 <a href="https://github.com/ionic-team/ionic-conference-app" target="_blank" rel="noopener">tutorial</a> 模板来初始化项目，如果不指定这个参数的话，默认会使用 <a href="https://github.com/ionic-team/ionic-starter-tabs" target="_blank" rel="noopener">tabs</a> 模板。<br>MyApp 可以替换成你的应用程序名称。<br>–type 表示当前生成的是 angular 的应用。<br><code>ionic start --list</code> 可以查看所有starting项目模板。</p></blockquote><p>这个命令将下载项目模板，安装 npm modules，设置 Cordova 的相关信息。</p><p>如果安装npm 模块失败，你可以手动进入项目目录安装：</p><pre><code class="bash"><span class="hljs-built_in">cd</span> MyAppnpm install</code></pre><p>你的项目代码在src目录下。</p><h2 id="zai-liu-lan-qi-yun-hang" class="heading-control">在浏览器运行<a class="heading-anchor" href="#zai-liu-lan-qi-yun-hang" aria-hidden="true"></a></h2><pre><code class="bash"><span class="hljs-built_in">cd</span> MyAppionic serve -l</code></pre><blockquote><p><code>-l</code>(–lab) 参数将在浏览器中模拟多个手机设备。</p></blockquote><p>接下来 CLI 会编译项目，接着浏览器会打开一个地址为 <a href="http://localhost:8100" target="_blank" rel="noopener">http://localhost:8100</a> 的窗口，端口号根据当前PC的实际情况可能会有变化，如果8100被占用了会使用8101等。</p><h2 id="dai-ma-jie-gou" class="heading-control">代码结构<a class="heading-anchor" href="#dai-ma-jie-gou" aria-hidden="true"></a></h2><ul><li>./src/ 当我们运行<code>ionic serve</code>命令的时候，在<code>src/</code>目录下的typescript文件会被译成JavaScript</li><li>./src/index.html 是h5的主入口文件，设置脚本和CSS，运行整个App。</li><li>./src/app/app.module.ts 是angular2 应用的入口。</li><li>./src/app/app.html 是应用的模板文件</li></ul><h2 id="tian-jia-ye-mian" class="heading-control">添加页面<a class="heading-anchor" href="#tian-jia-ye-mian" aria-hidden="true"></a></h2><pre><code>ionic g page login</code></pre><p>Note: 懒加载的Page为独立的Module。<br>Ionic的懒加载Page很愚蠢，是编译时刻由ionic的app-scripts处理的(deep links config)，必须是page.moudle.ts与page.compnent.ts分开文件（否则app-scripts会报错）</p><p>另外tab控件产生的url丑陋： <a href="https://github.com/ionic-team/ionic/issues/9012" target="_blank" rel="noopener">https://github.com/ionic-team/ionic/issues/9012</a></p><p>如果不要<code>IonicPage</code>注解可以这：</p><pre><code class="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deepLinkConfig: DeepLinkConfig = {  links: [    { component: OnlineCoursesPage, name: <span class="hljs-string">'OnlineCourses'</span>, segment: <span class="hljs-string">''</span> },    { component: CartPage, name: <span class="hljs-string">'Cart'</span>, segment: <span class="hljs-string">'cart'</span> },    { component: CheckoutPage, name: <span class="hljs-string">'Checkout'</span>, segment: <span class="hljs-string">'checkout'</span> },    { component: ThankYouPage, name: <span class="hljs-string">'ThankYou'</span>, segment: <span class="hljs-string">'thanks'</span> },    { component: AccountPage, name: <span class="hljs-string">'Account'</span>, segment: <span class="hljs-string">'account'</span> },    { component: RegisterPage, name: <span class="hljs-string">'Register'</span>, segment: <span class="hljs-string">'register'</span> },    { component: ForgotPasswordPage, name: <span class="hljs-string">'ForgotPassword'</span>, segment: <span class="hljs-string">'account'</span> },    { component: ForgotUsernamePage, name: <span class="hljs-string">'ForgotUsername'</span>, segment: <span class="hljs-string">'account'</span> },    { component: OnlineCoursesPage, name: <span class="hljs-string">'OnlineCourses'</span>, segment: <span class="hljs-string">':statename/:licensetypename/online-course-results'</span> },    { component: CorrespondencePage, name: <span class="hljs-string">'Correspondence'</span>, segment: <span class="hljs-string">':statename/:licensetypename/correspondence'</span> },    { component: LiveSeminarsPage, name: <span class="hljs-string">'LiveSeminars'</span>, segment: <span class="hljs-string">':statename/:licensetypename/search-seminars-list'</span> },    { component: LiveWebinarsPage, name: <span class="hljs-string">'LiveWebinars'</span>, segment: <span class="hljs-string">':statename/:licensetypename/webinar'</span> },    { component: LicensingInfoPage, name: <span class="hljs-string">'Licensing'</span>, segment: <span class="hljs-string">':statename/:licensetypename/licensing-info'</span> }  ]};  imports: [    IonicModule.forRoot(MyApp, { locationStrategy: <span class="hljs-string">'path'</span> }, deepLinkConfig)  ],</code></pre><p>目前ionic 在分支core上在重构(使用Web Component)，支持angular5 router: <a href="https://github.com/ionic-team/ionic/tree/core/packages/demos/ng-tab-routing" target="_blank" rel="noopener">https://github.com/ionic-team/ionic/tree/core/packages/demos/ng-tab-routing</a></p><ul><li><a href="https://github.com/apoterenko/ngx-dynamic-template" target="_blank" rel="noopener">https://github.com/apoterenko/ngx-dynamic-template</a></li><li><a href="https://github.com/gund/ng-dynamic-component" target="_blank" rel="noopener">https://github.com/gund/ng-dynamic-component</a></li></ul><p>或不用ionic-cli，改用 angluar-cli:</p><ul><li><a href="https://github.com/ngx-rocket/generator-ngx-rocket" target="_blank" rel="noopener">https://github.com/ngx-rocket/generator-ngx-rocket</a><ul><li>UI: 支持 Bootstrap 4, ionic, angular-material</li><li>mobile: 支持 cordova</li><li>但是lighthouse性能评分极差</li><li>不过ngx可以作为自己的cli 命令行app产生器参考。</li></ul></li><li><a href="https://github.com/Robinyo/ionic-angular-schematics" target="_blank" rel="noopener">https://github.com/Robinyo/ionic-angular-schematics</a><ul><li>绑定在ionic，算是ionic的angular-cli替代。</li><li>有 Dynamic Theme Support 代码可以参考。</li></ul></li></ul><p>ionic 4将使用Web Component(通过stencil编译)的方式，来改变目前绑定在Angular框架的局面，这样ionic的组件就和框架无关了，你可以用在任何框架上面使用， vue, react 都不是问题.</p><h2 id="announcing-pwa-support-in-ionic2" class="heading-control"><a href="http://blog.ionic.io/announcing-pwa-support-in-ionic-2/" target="_blank" rel="noopener">Announcing PWA support in Ionic2</a><a class="heading-anchor" href="#announcing-pwa-support-in-ionic2" aria-hidden="true"></a></h2><p>We also provide the service worker registration code in your index.html file.</p><pre><code class="js"><span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> <span class="hljs-keyword">in</span> navigator) {      navigator.serviceWorker.register(<span class="hljs-string">'service-worker.js'</span>)        .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'service worker installed'</span>))        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Error'</span>, err));}</code></pre><p>To enable the service worker, you can simply uncomment that registration code, and you’ll be ready to go! You’ll find the service-worker.js file in the www folder of your Ionic project.</p><p>For examples of service workers, check out the <a href="https://serviceworke.rs/" target="_blank" rel="noopener">ServiceWorker Cookbook</a> by Mozilla and the Google Chrome team’s <a href="https://github.com/GoogleChrome/samples/tree/gh-pages/service-worker" target="_blank" rel="noopener">repo of example service workers</a>.</p><p>We’re very excited to start supporting PWA’s out of the box with Ionic and plan on steadily improving this support in the future. We are currently considering support for server-side rendering to get a blazing-fast first render and convenient hosting with the Ionic Cloud. Our service worker support will also be evolving in the near future to allow for automatic configuration of service workers. This will give your PWA offline support right out of the box, without you having to write any code. We cannot wait to see the awesome PWAs that you build! Stay tuned to our blog and our docs for updates!</p><h2 id="best-practise" class="heading-control">Best Practise<a class="heading-anchor" href="#best-practise" aria-hidden="true"></a></h2><p>src/app 存放本应用下的公用部分，以及app模块本身。</p><h3 id="main-app-module" class="heading-control">Main App Module<a class="heading-anchor" href="#main-app-module" aria-hidden="true"></a></h3><p>该模块为主页面的入口</p><p>src/app/app.module.ts<br>src/app/app.comonent.ts<br>src/app/app.scss<br>src/app/app.html</p><h3 id="shared-module" class="heading-control">Shared Module<a class="heading-anchor" href="#shared-module" aria-hidden="true"></a></h3><p>在本应用的其它Module中需要用到的模块统一放在此处。</p><p>src/shared/app.imports.ts   本应用内所有要导入的组件，指令，模块，pipe</p><pre><code class="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MODULES = [  SwingModule,  BrowserModule,  HttpClientModule,];<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PROVIDERS = [  AlertService,  ToastService,  AppState,  CameraProvider,  NativeGoogleMapsProvider,  <span class="hljs-comment">// Ionic native specific providers</span>  BarcodeScanner,  Camera,  Diagnostic,  Geolocation,  CardIO,  StatusBar,  SplashScreen,  GoogleMaps,];<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DIRECTIVES = [  SlidingDrawer,  Autosize,];</code></pre><p>src/shared/shared.module.ts</p><pre><code class="ts"><span class="hljs-keyword">import</span> { PipesModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'../pipes/pipes.module'</span>;<span class="hljs-keyword">import</span> { ComponentsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/components.module'</span>;<span class="hljs-keyword">import</span> { DIRECTIVES } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.imports'</span>;<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> { IonicModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'ionic-angular'</span>;<span class="hljs-meta">@NgModule</span>({  declarations: [    DIRECTIVES,  ],  imports: [    IonicModule,    PipesModule,    ComponentsModule,  ],  exports: [    ComponentsModule,    PipesModule,  ]})<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SharedModule { }</code></pre><p>shared/ 这是第三方的库</p><h3 id="microapp" class="heading-control">MicroApp<a class="heading-anchor" href="#microapp" aria-hidden="true"></a></h3><h2 id="capacitor" class="heading-control">Capacitor<a class="heading-anchor" href="#capacitor" aria-hidden="true"></a></h2><p>如果想试用 <code>capacitor</code> 代替 Cordavo：</p><pre><code>npm install --save @capacitor/core @capacitor/cli</code></pre><p>Next init Capacitor by running the following command with your ap information</p><pre><code>npx cap init ionic-capacitor-app com.techiediaries.myapp</code></pre><p>Make sure to use your app name for the first parameter and your app id for the second parameter ( <code>npx cap init [appName] [appId]</code> ).</p><p>This command will add a capacitor.config.json inside your project folder with the following content</p><pre><code class="js">{  <span class="hljs-string">"appId"</span>: <span class="hljs-string">"com.techiediaries.myapp"</span>,  <span class="hljs-string">"appName"</span>: <span class="hljs-string">"ionic-capacitor-app"</span>,  <span class="hljs-string">"bundledWebRuntime"</span>: <span class="hljs-literal">false</span>,  <span class="hljs-string">"webDir"</span>: <span class="hljs-string">"www"</span>}</code></pre><p>Now you need to generate the www folder with the Ionic app built files by running the build command:</p><pre><code>npm run build</code></pre><h3 id="adding-the-android-platform" class="heading-control">Adding the Android Platform<a class="heading-anchor" href="#adding-the-android-platform" aria-hidden="true"></a></h3><p>before you can run your app you need to add a platform either android, ios or web so let’s add the Android platform</p><pre><code class="bash">npx <span class="hljs-built_in">cap</span> add androidnpx <span class="hljs-built_in">cap</span> sync</code></pre><p>You can also use the copy command instead of sync</p><pre><code>npx cap copy</code></pre><p>The difference is that copy will only copy the web assets but sync will also update native dependencies so use it if you have added any native dependencies.</p><p>Now you can open your Android project using the Android Studio using:</p><pre><code>npx cap open</code></pre><p>This will prompt you to choose a platform to open android, ios or web select android for Android.</p><p>If that doesn’t open Android Studio you can simply open Android Studio manually and then File-&gt;Open… command then navigate to your project and open the android folder.</p><p>You can now use Android Studio to launch your app using an emulator or a real device.</p><p>Next we’ll see how to use Capacitor plugins to access native device features such as the Camera and Geolocation.</p><h2 id="wen-ti" class="heading-control">问题<a class="heading-anchor" href="#wen-ti" aria-hidden="true"></a></h2><p><a href="https://leifwells.github.io/2017/08/27/testing-in-ionic-configure-existing-projects-for-testing/" target="_blank" rel="noopener">https://leifwells.github.io/2017/08/27/testing-in-ionic-configure-existing-projects-for-testing/</a><br><a href="https://robferguson.org/blog/2017/11/28/testing-your-ionic-3-app/" target="_blank" rel="noopener">https://robferguson.org/blog/2017/11/28/testing-your-ionic-3-app/</a></p><h3 id="assertshtmlindexhtml-lian-jie-bu-cheng-gong-can-not-unsuccessful-connectwebview" class="heading-control">/asserts/html/index.html 连接不成功(can not unsuccessful connect)，(webview)<a class="heading-anchor" href="#assertshtmlindexhtml-lian-jie-bu-cheng-gong-can-not-unsuccessful-connectwebview" aria-hidden="true"></a></h3><p>里面的脚本太多加载超时导致。在java中加入:</p><pre><code class="java"><span class="hljs-keyword">super</span>.setIntegerProperty(<span class="hljs-string">"loadUrlTimeoutValue"</span>, <span class="hljs-number">700000</span>);</code></pre><p>或者在项目根目录 <code>config.xml</code>的 <code>andorid platform</code> 中加入:</p><pre><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">preference</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loadUrlTimeoutValue"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"700000"</span> /&gt;</span></code></pre><h3 id="ionicangular-de-mei-yi-ge-ban-ben-zong-shi-he-dui-ying-de-angular-ban-ben-bang-ding-de" class="heading-control">ionic-angular 的每一个版本总是和对应的angular版本绑定的<a class="heading-anchor" href="#ionicangular-de-mei-yi-ge-ban-ben-zong-shi-he-dui-ying-de-angular-ban-ben-bang-ding-de" aria-hidden="true"></a></h3><p>不要轻易变动，除非你知道对应的angular版本。</p><pre><code>&quot;ionic-angular&quot;: &quot;^2.0.0-rc.3-201612080433&quot;,&quot;@angular/core&quot;: &quot;2.2.1&quot;,</code></pre><p>否则报错：</p><pre><code>__WEBPACK_IMPORTED_MODULE_0__angular_core__.Version is not a constructor</code></pre><h3 id="can-not-import-constants" class="heading-control">Can not import constants!<a class="heading-anchor" href="#can-not-import-constants" aria-hidden="true"></a></h3><p><a href="https://github.com/driftyco/ionic-app-scripts/issues/439" target="_blank" rel="noopener">https://github.com/driftyco/ionic-app-scripts/issues/439</a></p><p>Ask:<br>In my case i’ve got a regular ionic projekt.<br>i npm install a second project (which is typescript only - no js bundles, no transpiled JS) in my ionic project.<br>the second project contains interfaces, enums, constants… which i share between two projects (node server and ionic app).<br>when i import interfaces -&gt; no problem.<br>when i import constants --&gt; Cannot read property ‘content’ of undefined.</p><p>Answer:<br>Here’s what you would need to do:</p><p>Create the library of Typescript for Ionic<br>Transpile the Typescript to Javascript<br>Use NPM (or NPM link) to get your library in node_modules<br>Code as normal</p><p>We can’t support Typescript from a third party library at this time. It’s gotta be converted to Javascript because that is how libraries are distributed 99% of the time.</p><h3 id="click-delays-dian-ji-yan-chi-wen-ti" class="heading-control">Click Delays 点击延迟问题<a class="heading-anchor" href="#click-delays-dian-ji-yan-chi-wen-ti" aria-hidden="true"></a></h3><p>熟悉前端的应该都知道，某些元素在click事件会有300ms的延迟，在ionic里也是只有button和a可以立即响应的。如果要给其他的元素比如div增加click事件，给该元素加上<code>tappable</code>属性即可解决。</p><h3 id="http-qing-qiu-kua-yu-wen-ti" class="heading-control">http请求跨域问题<a class="heading-anchor" href="#http-qing-qiu-kua-yu-wen-ti" aria-hidden="true"></a></h3><p>在ionic2里使用angular2的HTTP请求api时，如果在浏览器里运行，经常会遇到跨域问题，比如：</p><pre><code>XMLHttpRequest cannot load http://www.xxx.com/clt/jsp/v3/channelContList.jsp?n=25950&amp;WD-UUID=864819028898243&amp;pageidx=1. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:8101' is therefore not allowed access.</code></pre><p>这是因为chrome不允许跨域访问。解决方法很简单，给chrome装一个ripple扩展，然后点击ripple，选择启用，就可以跨域访问了。</p><p>如果是自己同时开发api和app，很有可能api也是部署在本机上，比如api地址是http://localhost/api，<code>ionic serve</code>跑起来后是http://localhost:8100，这样在调用的时候又会遇到Internet Server Error的问题，比如：</p><pre><code>Error code is:xhr_proxy?tinyhippos_apikey=ABC&amp;tinyhippos_rurl=http%3A//localhost%3A30673/ap‌​i/user/Get%3Fjson rippleapi.herokuapp.com Status Code:500 Internal Server Error I'am getting data from my localhost post adress:localhost:30673/api/user/Get'; It is working well in browser . And getting data from localhost:30673/api/user/Get. But in ripple it tries to get data from There: xhr_proxy?tinyhippos_apikey=ABC&amp;tinyhippos_rurl=http%3A//localhost%3A30673/api/u‌​ser/Get%3Fjson rippleapi.herokuapp.com</code></pre><p>解决方法也很简单，ripple设置右上角有一个Cross Domain Proxy，有三个选择，Disabled、Local和Remote，通过字面意思就可以看出来分别对应禁用、本地和远程访问，如果是访问本机的api的话，一般设置为Disabled就可以了。如果访问远程主机的api，一般要设置为Remote或Disabled。</p><h3 id="yin-yong-di-san-fang-js-ku-de-wen-ti" class="heading-control">引用第三方js库的问题<a class="heading-anchor" href="#yin-yong-di-san-fang-js-ku-de-wen-ti" aria-hidden="true"></a></h3><p>开发过程中不可避免的要用到第三方js库，如果直接在TypeScript里写的话，编译器是认不出来的，会报错，编译也通不过。外部的类必须要import进来才可以用。TypeScript需要一个声明文件 d.ts<br>来知道第三方库的接口。可参考 <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Writing%20Definition%20Files.html" target="_blank" rel="noopener">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Writing Definition Files.html</a></p><p>如果用流行的库的话，不用我们自己写d.ts，有个开源的项目已经做好了：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">https://github.com/DefinitelyTyped/DefinitelyTyped</a><br>自己写的话很麻烦，特别是我用了一个项目平台的库，函数也不少，自己写的话也费时间，后来想到一个办法，</p><p>TypeScript的编译器支持自动生成d.ts，可以用命令<code>tsc --declaration my.ts</code>来生成，这个命令是给ts文件生成声明的，但TypeScript原生支持js，可以把第三方的js改后缀名为ts，tsc也可以生成。这里我又遇到一个问题，我的库里又调用了<br>Cordova的一些函数，编译的话tsc找不到，解决办法是复制一份js，将所有认不出的东西都注释掉，再生成就可以了。反正这个命令只是生成一个声明文件，具体的js只要引入进来就可以用。用这个命令很快就可以生成一份声明了，然后在用到的地方用</p><pre><code>/// &lt;reference path=&quot;../sdk.d.ts&quot;/&gt;</code></pre><p>这样的方式引用。注意一定要写在文件第一行。</p><h3 id="kai-fa-mo-shi-xuan-ze" class="heading-control">开发模式选择<a class="heading-anchor" href="#kai-fa-mo-shi-xuan-ze" aria-hidden="true"></a></h3><p>这个问题只是我做的项目的特殊情况，可能大部分人遇不到。我们的平台封装了Cordova的http请求，调用api必须用指定的方法才可以。但在chrome里调试的时候是加载不到Cordova的，于是我想了一个办法，增加一个全局的isDebug变量，封装一个全局的http方法，在debug模式时调用angular2的HTTP来请求，正式运行时才用Cordova的。其他的service都要调用这个方法，就无需关注是什么模式了，如果真机运行的话就改一下isDebug的值就可以了。</p><p>放一段代码：</p><pre><code class="js"><span class="hljs-comment">/// &lt;reference path="../sdk.d.ts"/&gt;</span><span class="hljs-keyword">import</span> {Injectable, Component} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> {HTTP_PROVIDERS, Http, Response} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/http'</span>;<span class="hljs-keyword">import</span> {Headers, RequestOptions} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/http'</span>;<span class="hljs-keyword">import</span> {AppGlobal} <span class="hljs-keyword">from</span> <span class="hljs-string">'../app-global'</span>;  <span class="hljs-number">6</span><span class="hljs-comment">/**  * HttpRequestService  */</span>@Injectable()@Component({ <span class="hljs-attr">providers</span>: [HTTP_PROVIDERS,Http]})<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestService</span> </span>{ <span class="hljs-keyword">constructor</span>(private http: Http) {} <span class="hljs-comment">/**   * get方法 获取json对象   *   * @template T   * @param {string} server   * @param {string} url   * @returns {Promise&lt;T&gt;}   */</span> get4Json&lt;T&gt;(server: string, <span class="hljs-attr">url</span>: string): <span class="hljs-built_in">Promise</span>&lt;T&gt; {   <span class="hljs-keyword">if</span> (AppGlobal.getInstance().isDebug) {     <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get(server + url).toPromise()     .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());   }   <span class="hljs-keyword">else</span> {     <span class="hljs-keyword">let</span> promise: <span class="hljs-built_in">Promise</span>&lt;T&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">(resolve, reject</span>) =&gt;</span> {       <span class="hljs-comment">//由于SDK必须要求传入一个参数数组，因此必须传递一个空数组作为参数</span>       <span class="hljs-keyword">let</span> paramJson = [];       SDKRequest.get4Json(server, url, paramJson, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>) </span>{         resolve(resp);       }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{         reject(error);       });     });     <span class="hljs-keyword">return</span> promise;   } }}</code></pre><p>angular2的http是用的Promise，但平台提供的方法用的callback，于是需要在这里将回调函数的方式改为Promise的方式，不管是不是debug模式都返回一个Promise，这样上层调用的时候就方便了。我是看的这里：</p><p><a href="https://basarat.gitbooks.io/typescript/content/docs/promise.html" target="_blank" rel="noopener">https://basarat.gitbooks.io/typescript/content/docs/promise.html</a></p><p>在angular2的官方文档中，是推荐用Observable模式的，但我还没有搞明白怎么将callback转为Observable，目前也没有时间仔细研究这块，所以还是继续用Promise好了。</p><h3 id="dan-li-mo-shi" class="heading-control">单例模式<a class="heading-anchor" href="#dan-li-mo-shi" aria-hidden="true"></a></h3><p>单例是经常用到的，我参考一个老外的代码用了一个单例，用来保存一些全局变量：</p><pre><code class="js"><span class="hljs-keyword">import</span> {UserInfo} <span class="hljs-keyword">from</span> <span class="hljs-string">'./model/user'</span>;<span class="hljs-comment">/** * AppGlobal 全局定义 单例模式 */</span><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppGlobal</span> </span>{  private <span class="hljs-keyword">static</span> instance: AppGlobal = <span class="hljs-keyword">new</span> AppGlobal();  <span class="hljs-comment">/**是否是调试状态 */</span>  isDebug: boolean = <span class="hljs-literal">true</span>;  server: string = <span class="hljs-keyword">this</span>.isDebug ? <span class="hljs-string">"http://localhost"</span> : <span class="hljs-string">"http://www.xxx.com"</span>;  apiUrl: string = <span class="hljs-string">"/MobileApi/api"</span>;  <span class="hljs-comment">/**当前用户信息 */</span>  currentUserInfo: UserInfo = <span class="hljs-keyword">new</span> UserInfo();  <span class="hljs-comment">/**分页页数 */</span>  pageSize: number = <span class="hljs-number">10</span>;  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword">if</span> (AppGlobal.instance) {      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"错误: 请使用AppGlobal.getInstance() 代替使用new."</span>);    }    AppGlobal.instance = <span class="hljs-keyword">this</span>;  }  <span class="hljs-comment">/**    * 获取当前实例 *    * @static * @returns {AppGlobal}    */</span>  public <span class="hljs-keyword">static</span> getInstance(): AppGlobal { <span class="hljs-keyword">return</span> AppGlobal.instance; }}</code></pre><h3 id="lazy-loading" class="heading-control">Lazy loading<a class="heading-anchor" href="#lazy-loading" aria-hidden="true"></a></h3><p><a href="https://github.com/didinj/ionic3-angular4-sample-app" target="_blank" rel="noopener">https://github.com/didinj/ionic3-angular4-sample-app</a></p><p>每一个页面都是一个 Module，通过pageModule来实现懒加载。<br>Angluar4本身的router loadChildren也是这样做的。</p><h3 id="cheng-xu-de-zi-dong-geng-xin" class="heading-control">程序的自动更新<a class="heading-anchor" href="#cheng-xu-de-zi-dong-geng-xin" aria-hidden="true"></a></h3><p>既然是html自然可以自动更新</p><p>支持Android和iOS:</p><ul><li><a href="https://github.com/nordnet/cordova-hot-code-push" target="_blank" rel="noopener">https://github.com/nordnet/cordova-hot-code-push</a><ul><li><a href="https://github.com/nordnet/cordova-hot-code-push/issues/131" target="_blank" rel="noopener">https://github.com/nordnet/cordova-hot-code-push/issues/131</a> (比较文档)</li></ul></li><li><a href="https://github.com/phonegap/phonegap-plugin-contentsync" target="_blank" rel="noopener">https://github.com/phonegap/phonegap-plugin-contentsync</a></li><li><a href="https://github.com/markmarijnissen/cordova-app-loader" target="_blank" rel="noopener">https://github.com/markmarijnissen/cordova-app-loader</a> (纯js实现)</li></ul><p>只支持 Android 是apk更新:</p><ul><li><a href="https://ionicframework.com/docs/native/app-update/" target="_blank" rel="noopener">https://ionicframework.com/docs/native/app-update/</a></li></ul><p><a href="https://codepureandsimple.com/implementing-cordova-hot-code-push-in-your-ionic-app-247cda24d6d4" target="_blank" rel="noopener">https://codepureandsimple.com/implementing-cordova-hot-code-push-in-your-ionic-app-247cda24d6d4</a></p><p>准备用的是: cordova-hot-code-push</p><pre><code class="bash">ionic start chcp-example blank<span class="hljs-built_in">cd</span> .\chcp-examplenpm install -g lite-serverionic cordova platform add android<span class="hljs-comment"># When prompted to install the @ionic/cli-plugin-cordova, select “Yes”.</span>ionic cordova plugin add cordova-hot-code-push-pluginnpm install -g cordova-hot-code-push-cli</code></pre><pre><code class="bash">~/dev/chcp-example&gt;cordova-hcp initRunning initPlease provide: Enter project name (required):  chcp-examplePlease provide: Amazon S3 Bucket name (required <span class="hljs-keyword">for</span> cordova-hcp deploy):Please provide: Path <span class="hljs-keyword">in</span> S3 bucket (optional <span class="hljs-keyword">for</span> cordova-hcp deploy):Please provide: Amazon S3 region (required <span class="hljs-keyword">for</span> cordova-hcp deploy):  (us-east-1)Please provide: IOS app identifier:Please provide: Android app identifier:Please provide: Update method (required):  (resume) startPlease provide: Enter full URL to directory <span class="hljs-built_in">where</span> cordova-hcp build result will be uploaded:  http://169.254.80.80:3000/updatesProject initialized and cordova-hcp.json file created.If you wish to exclude files from being published, specify them <span class="hljs-keyword">in</span> .chcpignoreBefore you can push updates you need to run <span class="hljs-string">"cordova-hcp login"</span> <span class="hljs-keyword">in</span> project directory</code></pre><p>cordova-hcp.json file in the root of your project :</p><pre><code class="js">{    <span class="hljs-string">"name"</span>: <span class="hljs-string">"chcp-example"</span>,    <span class="hljs-string">"ios_identifier"</span>: <span class="hljs-string">""</span>,    <span class="hljs-string">"android_identifier"</span>: <span class="hljs-string">""</span>,    <span class="hljs-string">"update"</span>: <span class="hljs-string">"start"</span>,    <span class="hljs-string">"content_url"</span>: <span class="hljs-string">"http://169.254.80.80:3000/updates"</span>}</code></pre><p>Edit your <code>config.xml</code> file to turn off automatic download and automatic install. We will do this via application code:</p><pre><code class="xml">&lt;chcp&gt;    &lt;config-file url=”http://169.254.80.80:3000/updates/chcp.json"/    &lt;auto-download enabled=”false” /&gt;    &lt;auto-install enabled=”false” /&gt;&lt;/chcp&gt;</code></pre><p>go to your <code>/chcp-example/src/pages/home/home.html</code> file and set its contents to the following:</p><pre><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">ion-header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ion-navbar</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ion-title</span>&gt;</span>Cordova Hot Code Push Test<span class="hljs-tag">&lt;/<span class="hljs-name">ion-title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ion-navbar</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-header</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ion-content</span> <span class="hljs-attr">padding</span>&gt;</span>    <span class="hljs-comment">{{ foo }}</span> <span class="hljs-comment">{{ bar }}</span><span class="hljs-tag">&lt;/<span class="hljs-name">ion-content</span>&gt;</span></code></pre><p><code>/chcp-example/src/pages/home/home.ts</code></p><pre><code class="ts"><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> { NavController } <span class="hljs-keyword">from</span> <span class="hljs-string">'ionic-angular'</span>;<span class="hljs-meta">@Component</span>({    selector: <span class="hljs-string">'page-home'</span>,    templateUrl: <span class="hljs-string">'home.html'</span>})<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomePage {    foo: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;    bar: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span>;    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> navCtrl: NavController</span>) {}}</code></pre><p>/chcp-example/src/app/app.component.ts:</p><pre><code class="ts"><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> { Platform, ModalController, AlertController } <span class="hljs-keyword">from</span> <span class="hljs-string">'ionic-angular'</span>;<span class="hljs-keyword">import</span> { StatusBar } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ionic-native/status-bar'</span>;<span class="hljs-keyword">import</span> { SplashScreen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ionic-native/splash-screen'</span>;<span class="hljs-keyword">import</span> { HomePage } <span class="hljs-keyword">from</span> <span class="hljs-string">'../pages/home/home'</span>;<span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> chcp: <span class="hljs-built_in">any</span>;<span class="hljs-meta">@Component</span>({    templateUrl: <span class="hljs-string">'app.html'</span>})<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyApp {  rootPage:<span class="hljs-built_in">any</span> = HomePage;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">platform: Platform,  statusBar: StatusBar,  splashScreen: SplashScreen,  <span class="hljs-keyword">private</span> modalCtrl: ModalController,  <span class="hljs-keyword">private</span> alertCtrl: AlertController</span>) {  platform.ready().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {    statusBar.styleDefault();    splashScreen.hide();    <span class="hljs-built_in">window</span>[<span class="hljs-string">"thisRef"</span>] = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">this</span>.fetchUpdate();  });}fetchUpdate() {  <span class="hljs-keyword">const</span> options = {    <span class="hljs-string">'config-file'</span>: <span class="hljs-string">'http://169.254.80.80:3000/updates/chcp.json'</span>  };  chcp.fetchUpdate(<span class="hljs-keyword">this</span>.updateCallback, options);}updateCallback(error, data) {  <span class="hljs-keyword">if</span> (error) {    <span class="hljs-built_in">console</span>.error(error);  } <span class="hljs-keyword">else</span> {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Update is loaded...'</span>);    <span class="hljs-keyword">let</span> confirm = <span class="hljs-built_in">window</span>[<span class="hljs-string">"thisRef"</span>].alertCtrl.create({      title: <span class="hljs-string">'Application Update'</span>,      message: <span class="hljs-string">'Update available, do you want to apply it?'</span>,      buttons: [       {text: <span class="hljs-string">'No'</span>},       {text: <span class="hljs-string">'Yes'</span>,         handler: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {           chcp.installUpdate(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {             <span class="hljs-keyword">if</span> (error) {               <span class="hljs-built_in">console</span>.error(error);               <span class="hljs-built_in">window</span>[<span class="hljs-string">"thisRef"</span>].alertCtrl.create({                 title: <span class="hljs-string">'Update Download'</span>,                 subTitle: <span class="hljs-string">`Error <span class="hljs-subst">${error.code}</span>`</span>,                 buttons: [<span class="hljs-string">'OK'</span>]               }).present();             } <span class="hljs-keyword">else</span> {               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Update installed...'</span>);             }           });         }       }      ]    });    confirm.present();   } }}</code></pre><h4 id="build-and-run-in-the-android-emulator" class="heading-control">Build and Run in the Android Emulator<a class="heading-anchor" href="#build-and-run-in-the-android-emulator" aria-hidden="true"></a></h4><p>From Android Studio, click the Tools menu, point to Android, click Android Virtual Device (AVD) Manager, and then start your virtual device. Open another command line and build the application, run the Hot Code Plugin build, and then run the application in the Android emulator:</p><pre><code class="bash">npm run build --prodcordova-hcp buildcordova <span class="hljs-built_in">emulate</span> android</code></pre><p>Keep your application running in the emulator, but let’s change the <code>/chcp-example/src/pages/home/home.ts</code> variables to the following to increase our chances of getting seed money from some investors:</p><pre><code class="ts">foo: <span class="hljs-built_in">number</span> = <span class="hljs-number">4</span>;bar: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span>;</code></pre><p>After you update your variable values, edit the version number in your <code>package.json</code> file to increment the number to “version”: “0.0.2” and then rebuild the project and use the Hot Code Plugin CLI to rebuild our updates. If you do not update the version number, the code will not get updated, you will not get any money from any VCs, and all of your friends and LinkedIn contacts will laugh at you.</p><p>The updated code will be created in the www folder of your application.</p><pre><code class="bash">npm run build --prodcordova-hcp buildmkdir ../code-servercp -r www ../code-server/updates<span class="hljs-built_in">cd</span> ../code-serverhttp-server</code></pre><h3 id="problems" class="heading-control">Problems<a class="heading-anchor" href="#problems" aria-hidden="true"></a></h3><ul><li><a href="https://forum.ionicframework.com/t/about-to-give-up-with-ionic-3-simple-native-like-chat-page-not-possible/87548/29" target="_blank" rel="noopener">https://forum.ionicframework.com/t/about-to-give-up-with-ionic-3-simple-native-like-chat-page-not-possible/87548/29</a><ul><li><a href="https://github.com/driftyco/ionic/issues/7149#issuecomment-296457305" target="_blank" rel="noopener">https://github.com/driftyco/ionic/issues/7149#issuecomment-296457305</a></li></ul></li></ul><p><a href="https://github.com/alexmady/KeyboardTest" target="_blank" rel="noopener">https://github.com/alexmady/KeyboardTest</a><br><a href="https://github.com/HsuanXyz/ionic3-chat" target="_blank" rel="noopener">https://github.com/HsuanXyz/ionic3-chat</a></p><p><a href="https://github.com/mojofit/imojo" target="_blank" rel="noopener">https://github.com/mojofit/imojo</a><br><a href="https://github.com/mojofit/node-mojo" target="_blank" rel="noopener">https://github.com/mojofit/node-mojo</a></p><p><a href="https://github.com/jdnichollsc/Ionic-ElastiChat-with-Images" target="_blank" rel="noopener">https://github.com/jdnichollsc/Ionic-ElastiChat-with-Images</a><br><a href="https://github.com/terikon/photo-library-demo-ionic2" target="_blank" rel="noopener">https://github.com/terikon/photo-library-demo-ionic2</a><br><a href="https://github.com/driftyco/ionic-starter-super" target="_blank" rel="noopener">https://github.com/driftyco/ionic-starter-super</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ionic-framework&quot; class=&quot;heading-control&quot;&gt;Ionic Framework&lt;a class=&quot;heading-anchor&quot; href=&quot;#ionic-framework&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Ionic 4 已经彻底解耦用户界面和框架,你可以在&lt;code&gt;angular&lt;/code&gt;和&lt;code&gt;react&lt;/code&gt;(甚至&lt;code&gt;vue&lt;/code&gt;)之间选择.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i -g ionic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已经是用angluar-cli(angular6配套的)。已经使用了angular的route.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://update.angular.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://update.angular.io&lt;/a&gt; 从老版本Angular升级到Angular6的指南。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://riceball.me/categories/JavaScript/"/>
    
      <category term="Framework" scheme="https://riceball.me/categories/JavaScript/Framework/"/>
    
      <category term="App" scheme="https://riceball.me/categories/JavaScript/Framework/App/"/>
    
    
      <category term="javascript" scheme="https://riceball.me/tags/javascript/"/>
    
      <category term="framework" scheme="https://riceball.me/tags/framework/"/>
    
      <category term="nodejs" scheme="https://riceball.me/tags/nodejs/"/>
    
      <category term="app" scheme="https://riceball.me/tags/app/"/>
    
      <category term="mobile" scheme="https://riceball.me/tags/mobile/"/>
    
      <category term="creation" scheme="https://riceball.me/tags/creation/"/>
    
  </entry>
  
  <entry>
    <title>从分享经济到共享经济系列(一)——分享经济的前世今生</title>
    <link href="https://riceball.me/article/sharing-economy/"/>
    <id>https://riceball.me/article/sharing-economy/</id>
    <published>2017-04-24T02:38:00.000Z</published>
    <updated>2019-12-10T02:19:29.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fen-xiang-jing-ji-de-qian-shi-jin-sheng" class="heading-control">分享经济的前世今生<a class="heading-anchor" href="#fen-xiang-jing-ji-de-qian-shi-jin-sheng" aria-hidden="true"></a></h1><p>“分享”这一概念是很容易理解的，因为我们打小从幼儿园的时候，就被教育说要主动分享，乐于助人。 “分享”这更是慈善事业中的主旋律。 用一言而概之，就是将自己的(既有资源)，与他人分享。</p><p>“分享经济”这一概念则是最近几年才明确地提出来的。 然而往往却和&quot;公司租赁&quot;混在一块，在我看来，这错得离谱，他们有着本质的不同。 而目前“租赁经济”只不过是披着互联网皮的传统公司租赁模式。</p><p>那么“租赁经济”和“分享经济”最本质的不同之处在哪里？</p><p>虽然“分享经济”看上去和“租赁”差不多，都是“资源”出借的方式。 但是本质的区别在于“租赁模式”是一家公司的将采购（<strong>全新购买</strong>）的资源租赁出去，并从中获得金钱收益的方式，而“分享经济”则是将每一个人(人人)<strong>已有的闲置资源</strong>进行充分利用，不仅仅是租赁（还可以是交换，赠与，甚至买卖的方式），这实质是一种协同消费(collaborative consumption)，也是第一代分享经济的主要特征。</p><p>再从社会效益来看，“租赁经济”并不能起到节能降排的目的，而是恰恰相反，因为它不是在利用现有资源，而是去生产新的投放市场。它的目标只有一个：盈利，甚至可能为了公司的利益目标，去生产资金回笼快的劣质产品，进而危害公共安全。而“分享经济”则能解决社会闲置产能，重新分配商品的使用价值。利用互联网匹配各种闲置产能供给和需求。</p><p>由此我们看到分享经济的<strong>本质特征</strong>是在最终用户之间(P2P)的分享或交换(Share/Exchage)资源(Resource)。</p><ul><li>P2P(Peer to Peer): 最终用户对最终用户</li><li>Share/Exchage: 共享或交换</li><li>Resource(资源): 这里的资源是泛指，包括电子信息和实际资源（产品，时间，技能，金钱等等)</li></ul><h1 id="xian-jie-duan-de-fen-xiang-jing-ji" class="heading-control">现阶段的分享经济<a class="heading-anchor" href="#xian-jie-duan-de-fen-xiang-jing-ji" aria-hidden="true"></a></h1><p>现阶段的<strong>一代分享经济</strong>，是以互联网为信息平台，在各个垂直领域中使得人人能对自己的<strong>信息</strong>和<strong>资源</strong>进行分享。</p><h2 id="xin-xi-fen-xiang" class="heading-control">信息分享<a class="heading-anchor" href="#xin-xi-fen-xiang" aria-hidden="true"></a></h2><p>首当其冲的是信息分享，随着社交网络服务(SNS)的出现，将个人的兴趣、经历、成果或心情分享出去，会让自己得到满足感。 很多人在做或做完某件事以后，往往想要分享给家人和朋友，亦或是陌生人，如果这些人对自己的分享是认可的、开心的或互动的，那么分享者自身也会很开心，这就是分享的动力。</p><ul><li>分享自己知识经验整理成文的这是<strong>博客</strong>。</li><li>通过关注周边发生的新鲜事，再以新奇视角的方式随时随地向公众进行分享，而这成就了<strong>微博(twitter)</strong>。</li><li>通过兴趣、休闲，炫耀，把私密和心情进行身边生活圈子分享，成就了<strong>微信(Facebook)</strong></li><li>把生活经(履)历，心得向特定群体进行分享，成就了<strong>Pinterest</strong></li></ul><h2 id="zi-yuan-fen-xiang" class="heading-control">资源分享<a class="heading-anchor" href="#zi-yuan-fen-xiang" aria-hidden="true"></a></h2><p>接着下来的是资源的分享和交换。</p><p><img src="./share1.png" alt></p><p>“资源&quot;分享的一个典型案例是&quot;AirBnB”，故事是这样开始的，07年在旧金山的两个刚毕业的美国小伙儿为自己的房租发愁，而当时城里正好在举办一个设计展，周边的旅馆都被订满了。 两位年轻人突发奇想，搞来了三张充气床垫放在客厅，建了一个简陋的网站发布信息：宣布任何参会者只要支付每晚80美元的费用，就可以享受到气垫床加早餐（AirBed &amp; Breakfast）的服务，和传统的借宿相比，通过 AirBnB，不再局限于熟人圈子，参与“分享”者的数量大大增加，借宿发生的地理空间也得到极大地拓展，同时借宿过程变得更加便捷，借宿体验变得更加有趣。  AirBnB 也因此成为“分享经济”的典范。</p><p>这实质是<strong>基于P2P租赁的“产品”服务</strong>。  我们要喝牛奶，但不必家家户户都养奶牛，这是显而易见的。 可是只要我们在家里环顾一下，便不难发现我们可没少干“养奶牛”的事。 举个极端的例子，美国有一半的家庭都拥有电钻，而平均每个家庭使用电钻的时间只有6 -13分钟！ 显然， 人们忘记了自己要的是打一个“洞”，而不是拥有一个电钻。 既然某些东西利用率如此之低，那么与其买一个闲在家里，不如临到用时才去借一个。 这种“<strong>使用而非占有</strong>”的观念如今已被越来越多的人接受。 它挑战了传统的建立在“私有独享”基础上的经济模式。</p><p>在家里，不仅有电钻这类使用频率很低的东西，其实还有很多东西人们压根就用不著。 对于这类物品，过去要么只能扔掉，要么当废品廉价卖掉，如果舍不得的话，那就只能堆在家里给自己添堵。 而现在拜互联网所赐出现的许多创新的平台，可以帮助人们更加有效地处理这些二手物品。 比如<strong>基于二手转让或交换的市场再流通</strong>的 Swapub 平台。</p><p><strong>基于&quot;服务技能&quot;的分享协同生活</strong>,可以说是新时代下的&quot;我为人人，人人为我&quot;,早在上世纪80年代，就有人倡议社区居民相互提供服务，每个人的服务时间都记录在一个“时间账户”中，将来需要别人来为自己提供服务的时候，就可以从这个账户中“提取”时间。 如今这一模式已经在社区志愿服务、社区养老等领域广泛开展，在中国的一些城市里也已经出现了一些尝试。</p><p><strong>基于集体智慧的众创众筹</strong>，对于酷爱DIY的创意者，通过众筹平台，把自己的创意变成现实的产品越来越普遍了。 互联网的到来，使得渺小个体也能发出自己的声音，也能被众感知和放大，这也是众智时代的到来。 从国外的kickstarter,india…,到国内的京东众筹，淘宝众筹…无一不在体现着这一趋势。 当然国内，我更多的看到是公司行为，把自己新发布的产品放在众筹上作为一种市场预售罢了。</p><h1 id="fen-xiang-jing-ji-de-she-hui-yi-yi" class="heading-control">分享经济的社会意义<a class="heading-anchor" href="#fen-xiang-jing-ji-de-she-hui-yi-yi" aria-hidden="true"></a></h1><p>“<a href="http://www.yic.cas.cn/kpzx/kpzl/201609/t20160922_4667205.html" target="_blank" rel="noopener">泛太平洋垃圾带</a>”自1997年被发现后，如今它的面积已经达到350万平方公里，相当于法国面积的7倍,而这堆塑料垃圾的面积每年会增加8万平方公里。由此说明，现代社会物质其实已经足够多了，已经达到泛滥的程度，但是过度的消费和不合理的分配导致物资无法惠及每一个人。</p><ul><li>人们不停追逐更新、更好、更便捷的产品所有权，而旧的产品成为垃圾</li><li><code>炫耀性消费</code>和<code>透支消费</code>导致高消费主义的发展，人们被引诱购买名不符价的<strong>狗牌</strong>产品：“爷就是有钱”</li></ul><p>不过人们已经开始逐渐认识到:</p><blockquote><p>“幸福并非来自物欲，而是来自感同身受。当我们在迟暮之年回首自己的人生经历时，在我们的记忆中突颖而出的很少会是关于物质利益、名誉或是财富方面的。触动我们内心深处的时刻就是那些同感激荡的时刻，来自于我们自身的超然感觉以及对他人通过奋斗获得成功的满足感的体会，仿佛那是我们自己的成功一样。” - <a href="https://book.douban.com/subject/25986746/" target="_blank" rel="noopener">零边际成本社会</a></p></blockquote><p>而随着社交网络服务(SNS)的发展进一步推动了“分享”文化的普及。 对于生活在互联网时代的人来说，在社交网路上发表自己的观点(照片,视频)或转发内容的行为近乎成为了一种本能，而正是这种“本能”的分享为“分享经济”的快速扩散打下了结实的基础。</p><p>随着年轻人越来越关心地球环境和资源的有效利用，习惯消费二手物品，更愿意过轻资产的生活，在这些的人眼中，成功的标志正在发生变化。 在分享经济领域，目前最活跃的市场是汽车和房产，这两样一般是家中最值钱的东西，通常被传统观念认作是最能体现身份地位的东西，但如今，越来越多的人选择分享它们而不是拥有或独有。 当然，很多人是出于现实经济的考虑。</p><p>分享经济创造大量的经济商业上的机会的同时，也产生了许多积极的社会效应。 其中最重要的一点就是恢复日益匮乏的社区感。 如今，整个社会都在进入一个更加开放和高度流动的现代社会。 人们纷纷离开原本的社区，进入到陌生的社区中生活。 分享经济可以增强社区凝聚力和活力，阻止了传统社区无社交的尴尬。</p><p>分享经济将会创造一个更加开放多元分享合作的社会(社区)，在这样的社会中，整个社会经济体系中的权力不再集中于少数供应商、生产商手中，因为通过共享经济，人们有条件有能力依靠自己解决更多的问题，满足自己更多的需求，也创造出更多的合作模式。</p><p>在传统商业模式的逻辑中，每个人都是社会经济体系中固定的一环，彼此的角色是对立的，要么是消费者，要么是生产者；这些角色之间的权力关系往往是不平等的，中间商可以压榨剥削小农，生产商可以欺瞒诱导顾客；这些角色彼此之间的关系是竞争的，我的获益多了，你的利益就会少了。 而在共享经济中，人们满足需求的方式可以是赠送、可以是交换、可以循环利用，可以临时借用，可以共同创造，可以共同使用，彼此的关系是利益共享的，我的获益多了，你的获益也不会减少。</p><p>越来越多的人将从雇佣就业走向创业式就业，从公司管理走向平台化的协同，从全职工作走向兼职工作，从机械的流水线作业走向自由灵活的“云上”作业，从办公室与工厂走向更个性化的居家与旅途。 与此同时，分享经济将重塑社会组织，“公司+员工”将在越来越多的领域被“平台+个人”所替代。 分享经济的发展让参与者比较自由地进入或退出社会生产过程，减轻了个人对组织的依赖程度，个人的创新创业潜力将从办公室、流水线的束缚中释放出来。 越来越多的个人将不再依附于某个特定的企业或机构，分享经济平台将成为灵活就业、个人创业、社会交往的空间。 个性化服务与生产自然也不再话下。</p><p>而这一切需要某种能让参与各方都能得到信任平台，这个平台也只有是各方共建的平台才能办到。</p><h1 id="xian-jie-duan-fen-xiang-jing-ji-ping-tai-de-wen-ti" class="heading-control">现阶段分享经济平台的问题<a class="heading-anchor" href="#xian-jie-duan-fen-xiang-jing-ji-ping-tai-de-wen-ti" aria-hidden="true"></a></h1><p>现阶段的<strong>一代分享经济</strong>平台，只是传统商业模式下的各个垂直领域封闭的个体经济平台，各自跑马圈地。 谋求各自利益最大化而封闭，自然就谈不上“分享“和”共赢“。</p><p>以微信为例，如果你想在微信上看到淘宝链接的信息，那是很麻烦的一件事情，你点连接，看不到任何内容，即使你用浏览器打开，也看不到，你必须手工选择复制粘贴淘宝链接地址到浏览器，所以出现了所谓的“淘口令”，当然淘宝也没少干封杀微信的傻事，不过没人在乎。</p><p>而再以淘宝来说，T宝最开始是提供开放的API接口的，但是自从15年开始，API不再开放了,大部分转为开始收费，哪怕是页面公开的产品信息，如果通过API调用获取也要收费，所以大家开始页面爬虫抓取。 14年的时候比价网比比皆是，到如今所剩无几。 一边说让天下没有难做的生意，一边却想方设法阻碍信息的分享和流通。</p><p>再说目前各个平台的EULA（最终用户许可协议），其实就是网络用户的使用合同，既然是合同，当然需要符合中国《合同法》与《消费者权益保护法》中关于格式条款的规定。 但遗憾的是，没有任何一家互联网公司能够达到上述法律的要求。 最近淘宝又更新了用户协议，规定在淘宝、支付宝平台的非活跃用户在一定时间之后将会进行销号处理(不同意请主动销号)，淘宝帐号还好，支付宝帐号如果有余额的话，对于6个月内无交易的用户，并且因为某些原因无法配合（核实身份），那么支付宝就可以有权注销该用户，真是霸道的条款，平台能没收用户的财产？</p><p><a href="https://render.alipay.com/p/f/fd-iztow1fi/index.html" target="_blank" rel="noopener">支付宝服务协议</a>:</p><blockquote><p>如您自开立支付宝账户之日起6个月内无主动交易，则向您重新核实身份之前，支付宝将有权暂停或者注销该支付宝账户。</p></blockquote><p>因为平台上保存有用户数据，于是他们决定用户数据的如何使用，而非基于用户自己的决定（授权），这些用户数据真的是平台的？如果是，那么这意味着平台拥有用户的财产，这显然荒谬，实际上，这应该是用户委托平台保管用户数据。 平台只应该是数据托管方。什么时候见过没有用户授权就可以乱动用户财产？</p><p>在拿众筹举例，《星际公民》算是游戏众筹的一个奇迹。 自从 2012 年著名众筹网站 Kickstarter 发起第一轮众筹起，三年时间，这个游戏在各种平台上已经募集了超过 8500 万美元，折合人民币超过 5 亿元。 而《魔兽世界》十年来的全部研发加诸多资料片的费用才不过 1 亿美元。 然而众筹投资者得到的是什么？除了跳票和玩游戏半成品，其他什么权益也没有。因此这样的众筹，引来一堆的骗子项目。 这实质上应该归属礼品经济，而非产品销售，因为这个时候产品并没有开始研发，对于是否能真的拿到产品，以及什么的产品，需要自行承担研发风险，这实际上就是P2P风投。 但是投资用户却没有相应的比例的收益，最多能免费先玩一玩，这样的投资者，哪里去找！</p><p>再说说信任，当前，几乎所有提供分享经济服务的平台在应对信任问题时，都采取了“<code>评分</code>”机制。 租借双方都必须填写详细的个人数据，在分享活动结束后，可以给对方评分。 但是这样的“评分”仅限于平台内部，当然，这个“评分”也不会有任何的分享，或者保证不被串改，删除。 你只能信任平台，信任平台的员工。</p><p>那么到底下一代分享经济（共享经济）如何实现，什么样的平台才能完全避免上述问题？</p><p>欲知后事如何，且听下回分解。待后续(TO BE CONTIUNED)…</p><h1 id="ming-xie" class="heading-control">鸣谢<a class="heading-anchor" href="#ming-xie" aria-hidden="true"></a></h1><p>感谢朋友们提供的宝贵意见，特别感谢同事周悦的一幅图及钓鱼的例子（略有改动），尤其是<a href="http://www.zhuangbiaowei.com" target="_blank" rel="noopener">庄表伟</a>，在对本文的提纲上给于我很多宝贵意见。谢谢朋友们。还有朋友提到文章篇幅过长，这也是个问题，所以我决定分成系列篇，本文以及接下来的部分还要作大量的修改。</p><h1 id="can-kao" class="heading-control">参考<a class="heading-anchor" href="#can-kao" aria-hidden="true"></a></h1><ul><li><a href="https://en.wikipedia.org/wiki/Sharing_economy" target="_blank" rel="noopener">Sharing_economy</a></li><li><a href="https://book.douban.com/subject/25986746/" target="_blank" rel="noopener">零边际成本社会</a></li><li><a href="http://blog.sina.com.cn/s/blog_7a9c67890102vdf0.html" target="_blank" rel="noopener">《零边际成本社会》读后感</a></li><li><a href="https://book.douban.com/subject/26465430/" target="_blank" rel="noopener">共享经济时代</a></li><li><a href="http://wiki.mbalib.com/wiki/%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89" target="_blank" rel="noopener">高消费主义</a></li><li><a href="https://en.wikipedia.org/wiki/Great_Pacific_garbage_patch" target="_blank" rel="noopener">太平洋垃圾帶（岛）</a></li><li><a href="http://www.yic.cas.cn/kpzx/kpzl/201609/t20160922_4667205.html" target="_blank" rel="noopener">海洋在流泪！海洋塑料垃圾触目惊心</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fen-xiang-jing-ji-de-qian-shi-jin-sheng&quot; class=&quot;heading-control&quot;&gt;分享经济的前世今生&lt;a class=&quot;heading-anchor&quot; href=&quot;#fen-xiang-jing-ji-de-qian-shi-jin-sheng&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;“分享”这一概念是很容易理解的，因为我们打小从幼儿园的时候，就被教育说要主动分享，乐于助人。 “分享”这更是慈善事业中的主旋律。 用一言而概之，就是将自己的(既有资源)，与他人分享。&lt;/p&gt;
&lt;p&gt;“分享经济”这一概念则是最近几年才明确地提出来的。 然而往往却和&amp;quot;公司租赁&amp;quot;混在一块，在我看来，这错得离谱，他们有着本质的不同。 而目前“租赁经济”只不过是披着互联网皮的传统公司租赁模式。&lt;/p&gt;
&lt;p&gt;那么“租赁经济”和“分享经济”最本质的不同之处在哪里？&lt;/p&gt;
&lt;p&gt;虽然“分享经济”看上去和“租赁”差不多，都是“资源”出借的方式。 但是本质的区别在于“租赁模式”是一家公司的将采购（&lt;strong&gt;全新购买&lt;/strong&gt;）的资源租赁出去，并从中获得金钱收益的方式，而“分享经济”则是将每一个人(人人)&lt;strong&gt;已有的闲置资源&lt;/strong&gt;进行充分利用，不仅仅是租赁（还可以是交换，赠与，甚至买卖的方式），这实质是一种协同消费(collaborative consumption)，也是第一代分享经济的主要特征。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thinking" scheme="https://riceball.me/categories/Thinking/"/>
    
      <category term="Internet" scheme="https://riceball.me/categories/Thinking/Internet/"/>
    
      <category term="Sharing Economy" scheme="https://riceball.me/categories/Thinking/Internet/Sharing-Economy/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="internet" scheme="https://riceball.me/tags/internet/"/>
    
      <category term="creation" scheme="https://riceball.me/tags/creation/"/>
    
      <category term="share" scheme="https://riceball.me/tags/share/"/>
    
      <category term="economy" scheme="https://riceball.me/tags/economy/"/>
    
      <category term="blockchain" scheme="https://riceball.me/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>从分享经济到共享经济系列(二)——下一代的分享经济:共享经济</title>
    <link href="https://riceball.me/article/sharing-economy2/"/>
    <id>https://riceball.me/article/sharing-economy2/</id>
    <published>2017-04-24T02:38:00.000Z</published>
    <updated>2019-12-10T07:22:39.912Z</updated>
    
    <content type="html"><![CDATA[<p>接前文：<a href="./share-economy">从分享经济到共享经济——分享经济的前世今生</a></p><h1 id="xia-yi-dai-de-fen-xiang-jing-ji-gong-xiang-jing-ji" class="heading-control">下一代的分享经济:共享经济<a class="heading-anchor" href="#xia-yi-dai-de-fen-xiang-jing-ji-gong-xiang-jing-ji" aria-hidden="true"></a></h1><p>设想下什么样的平台才能满足如下的需求：</p><h2 id="ge-xing-hua-sheng-chan" class="heading-control">个性化生产<a class="heading-anchor" href="#ge-xing-hua-sheng-chan" aria-hidden="true"></a></h2><p>当我构思出一种高度安全汽车概念，于是我在平台建立一个新项目，说明这个项目由来，以及这个项目的关键点：</p><p>一个球形的汽车，车身主要由“弹性柔韧泡沫塑料车体”和“弹性柔韧轻型支架”组成，发动机和转轴部分被隔离在单独的空间，当有危险时候，载人部分球形空间可以与之完全脱离…</p><p><img src="./car.jpg" alt="car"></p><p>在设定项目启动条件以及分赃比例(3331)后，成功创建项目。 而后平台将该项目发送到生产“弹性柔韧”的高强度材料厂商，以及发动机、转轴的厂家,还有关注新汽车的人上。</p><p>几天后，生产“弹性柔韧”的高强度材料厂商开始进入项目。 同时研发各类发动机的厂商或个人也开始进入，有的愿意参与研发。感兴趣的人们也开始在项目上投资和挑选自己喜爱的：从形状大小，再到材料和发动机，并开始PK（阐述理由，尽力拉票）。</p><p>平台开始统计, 各类组合(如：发动机A+材料B)的个数，确定前n名（投资金额满足）作为实验机。 也有人对落选的样机情有独钟，他们开始自己增加投资金额，确保他们的样机也能参与试作。 最终有52个通过参与试作。 这个时候<code>创意</code>结束。</p><p>接着开始紧张的<code>研发</code>过程…,最终研发结束，试作原型出炉。</p><p>然后试作原型在经过汽车质量检测部门的严格测试后，又在不同路面，天气，交通情况下做了测试，最后又淘汰了12个，剩下40个。</p><p>然后进入预售阶段，平台上经营汽车内饰和外观的商家开始进入，人们通过平台对车的内饰和外观做了不同的选择，有的在这个阶段也参与到项目里来，有的进行来投资，有的承诺会进行售后维修…</p><h2 id="ge-xing-hua-fu-wu" class="heading-control">个性化服务<a class="heading-anchor" href="#ge-xing-hua-fu-wu" aria-hidden="true"></a></h2><p>今天是一个周末，我一起床就收到朋友从平台发来的组织去钓鱼的活动，我点击参与了这个活动，一个小时候，就会有专车服务将会将我准时送往活动地点。 接下来我接到了平台推送来的消息：家里的智能冰箱空了，平台问我是否需要配送一些食品，我选择后约了下午6点以后送来。</p><p>收拾完毕，在前往活动地点的路上，社区给我发来一条通知，说今天晚上社区停气，我想了想就干脆决定跟朋友晚上一起聚餐，不回家做饭了，我发起一条聚餐活动，并邀请朋友参加，接下来在平台上选择并预约了一个餐厅，并且在app上修改了送货到家的预约时间。</p><h2 id="gong-xiang-jing-ji-ping-tai" class="heading-control">共享经济平台<a class="heading-anchor" href="#gong-xiang-jing-ji-ping-tai" aria-hidden="true"></a></h2><p>下一代的共享经济平台，实质上是一个对等社会平台网络，它是打通各个垂直领域，进行生产资料共享合作共赢的一个平台，可以说是全球的分布式经济系统，打通各个环节而不是处处设置门槛，让自动化流转更加便捷，使得各类创新的智能服务呈出不穷。这实际上就是新形式下全新的互联网。</p><p>针对参与各方的开放，信任，权益的公平分配是下一代分享经济急需解决的主要问题。 那么如何能让各方都参与共建和共享利益呢？</p><p>在我看来，作为一个没有任何背景，任何机构担保的项目，要让人用，最首先要解决的就是：信任。</p><h3 id="xin-ren" class="heading-control">信任<a class="heading-anchor" href="#xin-ren" aria-hidden="true"></a></h3><p>只有当我们在对待某些事情上达成一致，形成共识，才能有建立信任的基础。而事实上我们是有些共识的基础的：</p><p>我们都相信:</p><ul><li>人人都是平等</li><li>谁也不信谁 Do not trust anyone</li></ul><p>这些共识的基础总结起来就是：</p><ul><li>去信任化: 谁也不信谁</li><li>人人平等</li><li>共识共产共治共赢</li></ul><h4 id="di-yi-gong-shi-kai-yuan" class="heading-control">第一共识:开源<a class="heading-anchor" href="#di-yi-gong-shi-kai-yuan" aria-hidden="true"></a></h4><p>为什么说共享经济的第一共识是开源（开放源代码）？简单来说：</p><ul><li>开源才能保障人人共有共享</li><li>开源才可以保障对共识规则的审核落实（代码的执行逻辑就是共识规则）</li><li>开源也是IT软件行业彻底开放的象征。</li></ul><p>具体来说，“<strong>开源</strong>”是分享经济的最佳载体，没有之一。 因为“<strong>开源</strong>”的本质就是在共享“技术”，而“技术”是生产资料的组成部分，这就是由市场驱动而“自发形成”的生产资料的“公有制”，<strong>开源</strong>才能够真正的让大家共同拥有一个平台。</p><p>2015年，谷歌开源了深度学习系统TensorFlow;随后facebook也将其最新的人工智能相关技术开源了…对诸多的高科技企业来说，“开源”活动已蔚然成风。 实际上，不仅仅是软件公司兴起开源运动，就硬件领域也兴起了Arduino这样的开源硬件。 <strong>开源</strong>已经是科技企业的一个潮流，想要成为某领域内的领头羊，以自己的技术为核心构建强大的生态系统是唯一的选择。 当年谷歌因为是手机操作系统的后来者，选择将android系统开源，如今该操作系统的市场份额将近90%，而作为智能手机操作系统的先行者微软(当年的多普达手机可是比苹果更早进入智能手机市场)，一直想复制他们在pc领域内的授权模式，到今天连1%的份额都难以守住,如今的微软也从拒绝开源，转变为拥抱开源，早在2014微软就将.Net给开源了。 就连在电子货币方面，也是开源独领风骚，比特币(Bitcoin)大家耳熟能详，在开源模式运作下的又一杰作(哪怕它只是一个实验，种种的不完善，居然也得到如此多的人支持)，目前的各种开源区块链(Blockchain)技术都是基于此。</p><ol><li>开源解决各方（包括最终用户）的最初信任的问题</li></ol><p>还记得去年因为信息泄露而导致山东女孩徐玉玉死亡的事情么，现在，盗窃信息已经不算什么，在更新的<a href="https://docs.alipay.com/policies/privacy/alipay" target="_blank" rel="noopener">《支付宝隐私权政策》</a>中已经明目张胆在收集并传递信息：“<strong>要向支付宝关联公司和合作伙伴收集其合法留存的您的行为信息、交易信息…</strong>”,而你无权禁止他们收集你的信息，你只可以发短信退订广告，对用户的信息滥用以至于此。</p><ol start="2"><li>开源才能保证这是残各方自己拥有的自建平台</li></ol><p>但是<strong>开源</strong>的只是万里长征的第一步，如果<strong>运作</strong>不开源，那么还是无法确保各方利益的真实执行。这需要一个各方满意并且各方看得见的<strong>运作</strong>机制。 这种机制必须允许保证各个参与者在平台上贡献的资源进行论功行赏，从而最终达到自洽和自我进化。</p><h4 id="di-er-gong-shi-qu-zhong-xin-hua-qu-xin-ren-hua-p2p" class="heading-control">第二共识: 去中心化(去信任化,P2P)<a class="heading-anchor" href="#di-er-gong-shi-qu-zhong-xin-hua-qu-xin-ren-hua-p2p" aria-hidden="true"></a></h4><p><img src="./central-vs-decentral.jpg" alt></p><p>以前信息是放在中心平台,平台负责管理,你完全不清楚平台是如何存储和管理您的数据，平台方以及平台维护者完全可以绕过您而任意滥用您的数据。而去中心化，首先是指信息的去中心化，数据在自己的手里，任何使用都经过自己的允许，其次才是指平台的去中心化。</p><p>TO BE CONTINUE.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接前文：&lt;a href=&quot;./share-economy&quot;&gt;从分享经济到共享经济——分享经济的前世今生&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;xia-yi-dai-de-fen-xiang-jing-ji-gong-xiang-jing-ji&quot; class=&quot;heading-control&quot;&gt;下一代的分享经济:共享经济&lt;a class=&quot;heading-anchor&quot; href=&quot;#xia-yi-dai-de-fen-xiang-jing-ji-gong-xiang-jing-ji&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;设想下什么样的平台才能满足如下的需求：&lt;/p&gt;
&lt;h2 id=&quot;ge-xing-hua-sheng-chan&quot; class=&quot;heading-control&quot;&gt;个性化生产&lt;a class=&quot;heading-anchor&quot; href=&quot;#ge-xing-hua-sheng-chan&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当我构思出一种高度安全汽车概念，于是我在平台建立一个新项目，说明这个项目由来，以及这个项目的关键点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thinking" scheme="https://riceball.me/categories/Thinking/"/>
    
      <category term="Internet" scheme="https://riceball.me/categories/Thinking/Internet/"/>
    
      <category term="Sharing Economy" scheme="https://riceball.me/categories/Thinking/Internet/Sharing-Economy/"/>
    
    
      <category term="thinking" scheme="https://riceball.me/tags/thinking/"/>
    
      <category term="internet" scheme="https://riceball.me/tags/internet/"/>
    
      <category term="creation" scheme="https://riceball.me/tags/creation/"/>
    
      <category term="share" scheme="https://riceball.me/tags/share/"/>
    
      <category term="economy" scheme="https://riceball.me/tags/economy/"/>
    
      <category term="blockchain" scheme="https://riceball.me/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>MQTT 服务 - IoT界的消息订阅发布服务</title>
    <link href="https://riceball.me/article/mqtt/"/>
    <id>https://riceball.me/article/mqtt/</id>
    <published>2017-03-21T03:35:00.000Z</published>
    <updated>2019-11-22T06:56:43.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mqtt-fu-wu-iot-jie-de-xiao-xi-ding-yue-fa-bu" class="heading-control">MQTT 服务 - IoT界的消息订阅发布<a class="heading-anchor" href="#mqtt-fu-wu-iot-jie-de-xiao-xi-ding-yue-fa-bu" aria-hidden="true"></a></h1><p>关于消息推送服务PaaS云，这才发现国内几乎所有的消息推送服务都是基于广告，对用户画像，打标签，针对用户推送，没有纯粹的基于订阅发布消息推送服务，难怪免费居多，相当于你帮他们植入了常驻设备的推送后门。</p><p>只有自驾了。我选择了MQTT。</p><p>MQTT本是用于物联网设备的消息推送协议，具有体积小，协议简单，通信高效省电的特点。用在手机设备最好不过。</p><h2 id="mqtt-xie-yi-jian-dan-jie-shao" class="heading-control">MQTT 协议简单介绍<a class="heading-anchor" href="#mqtt-xie-yi-jian-dan-jie-shao" aria-hidden="true"></a></h2><p>MQTT 协议使用最少的方法指示要在特定主题(Topic)上实施的操作，进而实施发布/订阅模式。<br>MQTT是发布订阅(Publish/Subscribe)模式的消息协议，与HTTP协议请求响应(Request/Response)模式是不同的。</p><h3 id="xiao-xi-yu-zhu-ti-topic" class="heading-control">消息与主题 Topic<a class="heading-anchor" href="#xiao-xi-yu-zhu-ti-topic" aria-hidden="true"></a></h3><p>MQTT发布者与订阅者之间通过”主题”(Topic)进行消息推送，主题(Topic)格式类似URL或文件路径，通过&quot;/&quot;分隔层级，例如:</p><pre><code>sensor/1/temperaturechat/room/subjectpresence/user/fengsensor/1/#sensor/+/temperatureuber/drivers/joe/inbox</code></pre><p>MQTT主题(Topic)支持’+’, ‘#’的通配符，’+’通配一个层级，’#’通配多个层级(必须在末尾)。<br>MQTT消息发布者(Publisher)只能向特定’名称主题’(不支持通配符)发布消息，订阅者(Subscriber)<br>通过订阅’过滤主题’(支持通配符)来匹配消息。</p><p>注意：必须要转义’+’, ‘#’。</p><p>MQTT支持推送消息的QoS(服务质量)。在MQTT 中有三个等级的 QoS：</p><ul><li>QoS 0: 该等级表示“最多一次”交付（最佳状况）。 消息不会得到确认，因而，这是一种一劳永逸的方法。</li><li>QoS 1: 该等级表示“至少一次”交付。 用户可能不止一次获得消息，但是允许收到的人确认已经收到。</li><li>QoS 2: 该等级表示“刚好一次”交付。最慢但是最有保障的服务质量等级。确保用户只收到一次消息，并包含四个阶段的交付握手。该等级最慢，但是最安全。</li></ul><h4 id="mqtt-yi-yuan-xiao-xi-last-will" class="heading-control">MQTT遗愿消息(Last Will)<a class="heading-anchor" href="#mqtt-yi-yuan-xiao-xi-last-will" aria-hidden="true"></a></h4><p>MQTT客户端向服务器端CONNECT请求时，可以设置是否发送遗愿消息(Will Message)标志，和遗愿消息主题(Topic)与内容(Payload)。</p><p>MQTT客户端异常下线时(客户端断开前未向服务器发送DISCONNECT消息)，MQTT消息服务器会发布遗愿消息。</p><h4 id="mqtt-bao-liu-xiao-xi-retained-message" class="heading-control">MQTT保留消息(Retained Message)<a class="heading-anchor" href="#mqtt-bao-liu-xiao-xi-retained-message" aria-hidden="true"></a></h4><p>MQTT客户端向服务器发布(PUBLISH)消息时，可以设置保留消息(Retained Message)标志。保留消息(Retained Message)会驻留在消息服务器，后来的订阅者订阅主题时仍可以接收该消息。</p><p>保留消息(Retained Message)有两种清除方式:</p><ul><li>客户端向有保留消息的主题发布一个空消息:</li><li>消息服务器设置保留消息的超期时间。</li></ul><h4 id="gong-xiang-ding-yue-shared-subscription" class="heading-control">共享订阅(Shared Subscription)<a class="heading-anchor" href="#gong-xiang-ding-yue-shared-subscription" aria-hidden="true"></a></h4><p>共享订阅是非标准MQTT约定，不过大多数开源MQTT服务器已经实现。共享订阅(Shared Subscription)支持在多订阅者间采用分组负载平衡方式派发消息:<br>也就是订阅相同共享订阅(Shared Subscription)的客户根据负载平衡方式只有1人收到。这个场景可以用于：集群执行分布式任务（1个人接了活，其他人就不要接了）。</p><pre><code>                            ---------                            |       | --Msg1--&gt; Subscriber1Publisher--Msg1,Msg2,Msg3--&gt;|  EMQ  | --Msg2--&gt; Subscriber2                            |       | --Msg3--&gt; Subscriber3                            ---------</code></pre><p>共享订阅支持两种使用方式:</p><table><thead><tr><th>订阅前缀</th><th>使用示例</th></tr></thead><tbody><tr><td><code>$queue/</code></td><td><code>mosquitto_sub -t ‘$queue/topic’</code></td></tr><tr><td><code>$share/&lt;group&gt;/</code></td><td><code>mosquitto_sub -t ‘$share/group/topic’</code></td></tr></tbody></table><h4 id="ben-di-ding-yue-local-subscription" class="heading-control">本地订阅(Local Subscription)<a class="heading-anchor" href="#ben-di-ding-yue-local-subscription" aria-hidden="true"></a></h4><p>本地订阅也是非标准MQTT约定。</p><p>本地订阅(Local Subscription)只在本节点创建订阅与路由表，不会在集群节点间广播全局路由，非常适合物联网数据采集应用:</p><pre><code class="bash">mosquitto_sub -t <span class="hljs-string">'$local/topic'</span>mosquitto_pub -t <span class="hljs-string">'topic'</span></code></pre><p>使用方式: 订阅者在主题(Topic)前增加’$local/’前缀。</p><h3 id="mqtt-hui-hua-clean-session" class="heading-control">MQTT会话(Clean Session)<a class="heading-anchor" href="#mqtt-hui-hua-clean-session" aria-hidden="true"></a></h3><p>MQTT支持Session(会话)，当MQTT客户端向服务器发起CONNECT请求时，可以通过’Clean Session’标志设置会话。</p><ul><li>‘Clean Session’设置为0，表示创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销。</li><li>‘Clean Session’设置为1，表示创建一个新的临时会话，在客户端断开时，会话自动清除销毁。</li></ul><p>MQTT 方法定义很简单：</p><ul><li>连接 - 建立与 MQTT 经纪人（Broker）之间的连接。</li><li>断开连接 - 断开与 MQTT 经纪人（Broker）之间的连接。</li><li>发布 - 在 MQTT 经纪人（Broker）上发布主题。</li><li>订阅 - 从 MQTT 经纪人（Broker）上订阅主题。</li><li>退订 - 从 MQTT 经纪人（Broker）上退订主题。</li></ul><h2 id="open-source-mqtt-server" class="heading-control">Open Source MQTT Server<a class="heading-anchor" href="#open-source-mqtt-server" aria-hidden="true"></a></h2><ul><li><a href="https://vernemq.com" target="_blank" rel="noopener">VerneMQ</a> Erlang</li><li><a href="http://emqtt.com" target="_blank" rel="noopener">EMQ</a> Erlang<ul><li>文档：<a href="http://emqtt.com/docs/v2/getstarted.html" target="_blank" rel="noopener">http://emqtt.com/docs/v2/getstarted.html</a></li></ul></li><li><a href="https://github.com/mcollina/mosca" target="_blank" rel="noopener">Mosca</a> NodeJS</li><li><a href="https://github.com/eclipse/mosquitto" target="_blank" rel="noopener">Mosquitto</a> C</li></ul><h3 id="emq" class="heading-control">EMQ<a class="heading-anchor" href="#emq" aria-hidden="true"></a></h3><p>支持MQTT 3.1.1协议。<br>EMQ 2.0消息服务器默认占用的TCP端口包括:</p><ul><li>1883  MQTT协议端口</li><li>8883  MQTT(SSL)端口</li><li>8083  MQTT(WebSocket), HTTP API端口</li><li>18083 Dashboard管理控制台端口</li></ul><p><a href="https://github.com/emqtt/emq-docker" target="_blank" rel="noopener">https://github.com/emqtt/emq-docker</a><br><a href="https://github.com/eclipse/paho.mqtt.android" target="_blank" rel="noopener">https://github.com/eclipse/paho.mqtt.android</a></p><ul><li>用户登陆绑定</li><li>用户权限绑定，只能订阅或者发送本组织下的</li></ul><h2 id="ke-hu-duan" class="heading-control">客户端<a class="heading-anchor" href="#ke-hu-duan" aria-hidden="true"></a></h2><h3 id="android" class="heading-control">Android<a class="heading-anchor" href="#android" aria-hidden="true"></a></h3><p><a href="http://www.eclipse.org/paho/clients/android/" target="_blank" rel="noopener">Eclipse Paho Android Service</a></p><h4 id="install" class="heading-control">Install<a class="heading-anchor" href="#install" aria-hidden="true"></a></h4><pre><code class="java">repositories {    maven {        url <span class="hljs-string">"https://repo.eclipse.org/content/repositories/paho-releases/"</span>    }}dependencies {    compile <span class="hljs-string">'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.1.0'</span>    compile <span class="hljs-string">'org.eclipse.paho:org.eclipse.paho.android.service:1.1.1'</span>}</code></pre><p>The Paho Android Service needs the following permissions to work:</p><pre><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.WAKE_LOCK"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></code></pre><h4 id="usage" class="heading-control">Usage<a class="heading-anchor" href="#usage" aria-hidden="true"></a></h4><pre><code class="java">Log.i(LOGTAG, <span class="hljs-string">"MQTT Start"</span>);<span class="hljs-comment">//如果是走 "ssl://192.168.0.13:8883"</span><span class="hljs-keyword">final</span> MqttAndroidClient mqttAndroidClient = <span class="hljs-keyword">new</span> MqttAndroidClient(  getApplicationContext(), <span class="hljs-string">"tcp://192.168.0.13:1883"</span>, clientId);<span class="hljs-comment">//设置回调，在这里接收订阅的消息</span>mqttAndroidClient.setCallback(<span class="hljs-keyword">new</span> MqttCallbackExtended() {  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectComplete</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> reconnect, String serverURI)</span> </span>{      <span class="hljs-keyword">if</span> (reconnect) {          Log.i(LOGTAG, <span class="hljs-string">"Reconnected to : "</span> + serverURI);          <span class="hljs-comment">// if Clean Session is true, we need to re-subscribe</span>          <span class="hljs-comment">// subscribe('SampleTopic');</span>      } <span class="hljs-keyword">else</span> {          Log.i(LOGTAG, <span class="hljs-string">"Connected to: "</span> + serverURI);      }  }  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectionLost</span><span class="hljs-params">(Throwable cause)</span> </span>{      Log.i(LOGTAG, <span class="hljs-string">"The Connection was lost."</span>);  }  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageArrived</span><span class="hljs-params">(String topic, MqttMessage message)</span> <span class="hljs-keyword">throws</span> Exception </span>{      Log.i(LOGTAG, <span class="hljs-string">"Incoming message: "</span> + <span class="hljs-keyword">new</span> String(message.getPayload()));  }  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deliveryComplete</span><span class="hljs-params">(IMqttDeliveryToken token)</span> </span>{  }});MqttConnectOptions mqttConnectOptions = <span class="hljs-keyword">new</span> MqttConnectOptions();mqttConnectOptions.setAutomaticReconnect(<span class="hljs-keyword">true</span>);mqttConnectOptions.setCleanSession(<span class="hljs-keyword">false</span>);mqttConnectOptions.setUserName(<span class="hljs-string">"USERNAME"</span>);mqttConnectOptions.setPassword(<span class="hljs-string">"PASSWORD"</span>.toCharArray());<span class="hljs-keyword">try</span> {  <span class="hljs-comment">//第二个参数是可选的object,可以传递给回调函数</span>  client.connect(mqttConnectOptions, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> IMqttActionListener() {    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(IMqttToken mqttToken)</span> </span>{      Log.i(LOGTAG, <span class="hljs-string">"Client connected"</span>);      Log.i(LOGTAG, <span class="hljs-string">"Topics="</span>+mqttToken.getTopics());      subscribe(<span class="hljs-string">'sampleTopic'</span>);    }    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(IMqttToken arg0, Throwable arg1)</span> </span>{      <span class="hljs-comment">// TODO Auto-generated method stub</span>      Log.i(LOGTAG, <span class="hljs-string">"Client connection failed: "</span>+arg1.getMessage());    }  });}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(String topic)</span></span>{  <span class="hljs-keyword">try</span> {    mqttAndroidClient.subscribe(topic, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> IMqttActionListener() {      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(IMqttToken asyncActionToken)</span> </span>{          Log.i(LOGTAG, <span class="hljs-string">"Subscribed!"</span>);      }      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(IMqttToken asyncActionToken, Throwable exception)</span> </span>{          Log.i(LOGTAG, <span class="hljs-string">"Failed to subscribe"</span>);      }    });    <span class="hljs-comment">// THIS DOES NOT WORK!</span>    mqttAndroidClient.subscribe(topic, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> IMqttMessageListener() {      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageArrived</span><span class="hljs-params">(String topic, MqttMessage message)</span> <span class="hljs-keyword">throws</span> Exception </span>{          <span class="hljs-comment">// message Arrived!</span>          System.out.println(<span class="hljs-string">"InMessage: "</span> + topic + <span class="hljs-string">" : "</span> + <span class="hljs-keyword">new</span> String(message.getPayload()));      }    });  } <span class="hljs-keyword">catch</span> (MqttException ex){    System.err.println(<span class="hljs-string">"Exception whilst subscribing"</span>);    ex.printStackTrace();  }}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsubscribe</span><span class="hljs-params">(String topic)</span></span>{  <span class="hljs-keyword">try</span> {    mqttAndroidClient.unsubscribe(topic, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> IMqttActionListener() {      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(IMqttToken asyncActionToken)</span> </span>{          Log.i(LOGTAG, <span class="hljs-string">"unsubscribed!"</span>);      }      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(IMqttToken asyncActionToken, Throwable exception)</span> </span>{          Log.i(LOGTAG, <span class="hljs-string">"Failed to unsubscribed"</span>);      }    });  } <span class="hljs-keyword">catch</span> (MqttException ex){    System.err.println(<span class="hljs-string">"Exception whilst subscribing"</span>);    ex.printStackTrace();  }}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishMessage</span><span class="hljs-params">(String topic, String msg)</span></span>{  <span class="hljs-keyword">try</span> {    MqttMessage message = <span class="hljs-keyword">new</span> MqttMessage();    message.setQos(<span class="hljs-number">0</span>);    message.setRetained(<span class="hljs-keyword">false</span>);    message.setPayload(msg.getBytes());    mqttAndroidClient.publish(topic, message);    Log.i(LOGTAG, <span class="hljs-string">"Message Published"</span>);    <span class="hljs-keyword">if</span>(!mqttAndroidClient.isConnected()){      Log.i(LOGTAG, mqttAndroidClient.getBufferedMessageCount() + <span class="hljs-string">" messages in buffer."</span>);    }  } <span class="hljs-keyword">catch</span> (MqttPersistenceException e) {    <span class="hljs-comment">// TODO Auto-generated catch block</span>    e.printStackTrace();  } <span class="hljs-keyword">catch</span> (MqttException e) {    <span class="hljs-comment">// TODO Auto-generated catch block</span>    System.err.println(<span class="hljs-string">"Error Publishing: "</span> + e.getMessage());    e.printStackTrace();  }}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>{  <span class="hljs-keyword">try</span> {      IMqttToken disconToken = client.disconnect();      disconToken.setActionCallback(<span class="hljs-keyword">new</span> IMqttActionListener() {          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(IMqttToken asyncActionToken)</span> </span>{              <span class="hljs-comment">// we are now successfully disconnected</span>          }          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(IMqttToken asyncActionToken,                                Throwable exception)</span> </span>{              <span class="hljs-comment">// something went wrong, but probably we are disconnected anyway</span>          }      });  } <span class="hljs-keyword">catch</span> (MqttException e) {      e.printStackTrace();  }}</code></pre><p>Demo:</p><ul><li><a href="https://github.com/eclipse/paho.mqtt.android/tree/develop/paho.mqtt.android.example" target="_blank" rel="noopener">简单DEMO</a></li><li><a href="https://github.com/eclipse/paho.mqtt.android/tree/develop/org.eclipse.paho.android.sample" target="_blank" rel="noopener">复杂DEMO</a></li></ul><h4 id="ios" class="heading-control">IOS<a class="heading-anchor" href="#ios" aria-hidden="true"></a></h4><p><a href="https://github.com/ckrey/MQTT-Client-Framework" target="_blank" rel="noopener">MQTT Client Framework</a></p><pre><code class="objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"MQTTClient.h"</span></span>MQTTSession *session = [[MQTTSession alloc] init];<span class="hljs-comment">//specifies the protocol to be used.</span><span class="hljs-comment">//The value of the Protocol Level field for the version 3.1.1 of the protocol is 4.</span><span class="hljs-comment">//The value for the version 3.1 is 3.</span>session.protocolLevel = <span class="hljs-number">4</span>;session.clientId = <span class="hljs-string">@"clientId"</span>;session.cleanSessionFlag = <span class="hljs-literal">NO</span>;session.userName = <span class="hljs-string">@"myname"</span>;session.password = <span class="hljs-string">@"secret"</span>;[session connectToHost:<span class="hljs-string">@"192.168.0.1"</span> port:<span class="hljs-number">1883</span> usingSSL:<span class="hljs-literal">NO</span>];</code></pre><p>启用SSL use a custom security</p><pre><code class="objc">NSString* certificate = [[NSBundle bundleForClass:[MQTTSession class]] pathForResource:@"certificate" ofType:@"cer"];session.securityPolicy = [MQTTSSLSecurityPolicy policyWithPinningMode:MQTTSSLPinningModeCertificate];session.securityPolicy.pinnedCertificates = @[ [NSData dataWithContentsOfFile:certificate] ];session.securityPolicy.allowInvalidCertificates = YES;[session connectToHost:@"192.168.0.1" port:8883 usingSSL:YES];//Use  client certificates:NSString *path = [[NSBundle bundleForClass:[MQTTClientTests class]] pathForResource:parameters[@„client"] ofType:@"p12"];session.certificates = [MQTTSession clientCertsFromP12:path passphrase:@„secret“];[session connectToHost:@"192.168.0.1" port:8883 usingSSL:YES];</code></pre><pre><code class="objc">[session publishData:[<span class="hljs-string">@"Sample Data"</span> dataUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>]    topic:<span class="hljs-string">@"example/data"</span>    <span class="hljs-keyword">retain</span>:<span class="hljs-literal">NO</span>    qos:<span class="hljs-number">0</span>];[session subscribeToTopic:<span class="hljs-string">@"example/#"</span> atLevel:<span class="hljs-number">2</span>]; <span class="hljs-comment">//atLevel is QoS level</span>[session unsubscribeTopic:<span class="hljs-string">@"example/#"</span>];[session close];</code></pre><p>Demo: <a href="https://github.com/ckrey/MQTTChat" target="_blank" rel="noopener">https://github.com/ckrey/MQTTChat</a></p><h4 id="nodejs" class="heading-control">Nodejs<a class="heading-anchor" href="#nodejs" aria-hidden="true"></a></h4><pre><code>npm install mqtt</code></pre><p><a href="https://github.com/mqttjs/MQTT.js" target="_blank" rel="noopener">https://github.com/mqttjs/MQTT.js</a></p><pre><code class="coffee">mqtt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mqtt'</span>)<span class="hljs-comment"># 如果是websocket,对于emqtt必须加 path: '/mqtt'</span><span class="hljs-comment"># client  = mqtt.connect('ws://127.0.0.1:8083', path: '/mqtt', clientId: 'MQTTCLI1', clean:false,username:'',password:'')</span>client  = mqtt.connect(<span class="hljs-string">'mqtt://127.0.0.1'</span>, clientId: <span class="hljs-string">'MQTTCLI1'</span>, clean:<span class="hljs-literal">false</span>,username:<span class="hljs-string">''</span>,password:<span class="hljs-string">''</span>)client.<span class="hljs-literal">on</span> <span class="hljs-string">'connect'</span>, <span class="hljs-function">-&gt;</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'connect'</span>)  client.subscribe <span class="hljs-string">'presence'</span>, <span class="hljs-function"><span class="hljs-params">(err, granted)</span>-&gt;</span>    <span class="hljs-keyword">return</span> client.end() <span class="hljs-keyword">if</span> err    <span class="hljs-built_in">console</span>.log <span class="hljs-string">'subscribe ok'</span>, granted    <span class="hljs-comment"># client.publish 'presence', 'Hello mqtt', (err)-&gt;</span>    <span class="hljs-comment">#   console.log 'publish'</span>    <span class="hljs-comment">#   console.log 'pub', err if err</span>client.<span class="hljs-literal">on</span> <span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">(error)</span>-&gt;</span>  <span class="hljs-built_in">console</span>.log error<span class="hljs-comment"># received messages:</span>client.<span class="hljs-literal">on</span> <span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(topic, message)</span>-&gt;</span>  <span class="hljs-comment"># message is Buffer</span>  <span class="hljs-built_in">console</span>.log(topic, message.toString())  <span class="hljs-comment"># client.end()</span></code></pre><p>SSL:</p><pre><code class="js"><span class="hljs-keyword">var</span> mqtt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mqtt'</span>)<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<span class="hljs-keyword">var</span> KEY = fs.readFileSync(path.join(__dirname, <span class="hljs-string">'/tls-key.pem'</span>))<span class="hljs-keyword">var</span> CERT = fs.readFileSync(path.join(__dirname, <span class="hljs-string">'/tls-cert.pem'</span>))<span class="hljs-keyword">var</span> TRUSTED_CA_LIST = fs.readFileSync(path.join(__dirname, <span class="hljs-string">'/crt.ca.cg.pem'</span>))<span class="hljs-keyword">var</span> PORT = <span class="hljs-number">8443</span><span class="hljs-keyword">var</span> HOST = <span class="hljs-string">'stark'</span><span class="hljs-keyword">var</span> options = {  <span class="hljs-attr">port</span>: PORT,  <span class="hljs-attr">host</span>: HOST,  <span class="hljs-attr">key</span>: KEY,  <span class="hljs-attr">cert</span>: CERT,  <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// The CA list will be used to determine if server is authorized</span>  <span class="hljs-attr">ca</span>: TRUSTED_CA_LIST}<span class="hljs-keyword">var</span> client = mqtt.connect(options)client.subscribe(<span class="hljs-string">'messages'</span>)client.publish(<span class="hljs-string">'messages'</span>, <span class="hljs-string">'Current time is: '</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())client.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">topic, message</span>) </span>{  <span class="hljs-built_in">console</span>.log(message)})client.on(<span class="hljs-string">'connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Connected'</span>)})</code></pre><p>Demo: <a href="https://github.com/mqttjs/MQTT.js/tree/master/examples" target="_blank" rel="noopener">https://github.com/mqttjs/MQTT.js/tree/master/examples</a><br>Using mqtt as iOS push mechanism without APNS: <a href="https://github.com/Guou/Demo-mqtt-push" target="_blank" rel="noopener">https://github.com/Guou/Demo-mqtt-push</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mqtt-fu-wu-iot-jie-de-xiao-xi-ding-yue-fa-bu&quot; class=&quot;heading-control&quot;&gt;MQTT 服务 - IoT界的消息订阅发布&lt;a class=&quot;heading-anchor&quot; href=&quot;#mqtt-fu-wu-iot-jie-de-xiao-xi-ding-yue-fa-bu&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;关于消息推送服务PaaS云，这才发现国内几乎所有的消息推送服务都是基于广告，对用户画像，打标签，针对用户推送，没有纯粹的基于订阅发布消息推送服务，难怪免费居多，相当于你帮他们植入了常驻设备的推送后门。&lt;/p&gt;
&lt;p&gt;只有自驾了。我选择了MQTT。&lt;/p&gt;
&lt;p&gt;MQTT本是用于物联网设备的消息推送协议，具有体积小，协议简单，通信高效省电的特点。用在手机设备最好不过。&lt;/p&gt;
&lt;h2 id=&quot;mqtt-xie-yi-jian-dan-jie-shao&quot; class=&quot;heading-control&quot;&gt;MQTT 协议简单介绍&lt;a class=&quot;heading-anchor&quot; href=&quot;#mqtt-xie-yi-jian-dan-jie-shao&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Thinking" scheme="https://riceball.me/categories/Thinking/"/>
    
      <category term="Architecture" scheme="https://riceball.me/categories/Thinking/Architecture/"/>
    
      <category term="MQTT" scheme="https://riceball.me/categories/Thinking/Architecture/MQTT/"/>
    
    
      <category term="mqtt" scheme="https://riceball.me/tags/mqtt/"/>
    
      <category term="network" scheme="https://riceball.me/tags/network/"/>
    
      <category term="pubsub" scheme="https://riceball.me/tags/pubsub/"/>
    
      <category term="push" scheme="https://riceball.me/tags/push/"/>
    
      <category term="message" scheme="https://riceball.me/tags/message/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Tips</title>
    <link href="https://riceball.me/article/ubuntu-tips/"/>
    <id>https://riceball.me/article/ubuntu-tips/</id>
    <published>2017-02-26T03:35:00.000Z</published>
    <updated>2019-11-22T06:56:43.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-16-10" class="heading-control">Ubuntu 16.10<a class="heading-anchor" href="#ubuntu-16-10" aria-hidden="true"></a></h1><p>Ubuntu 现在基本可以替代Windows做日常使用的主力——只要不玩游戏。不过对SSD还是要需要调教一二。使用 Linux 还有一个好处是可以自带策略路由，对于域名IP流量精确转发，变得so easy。</p><p>这里记录下 Ubuntu 16.10 以上版本的安装tips.</p><h2 id="shell" class="heading-control">Shell<a class="heading-anchor" href="#shell" aria-hidden="true"></a></h2><p>我比较习惯 zsh, 下载安装zsh:</p><pre><code class="bash">$&gt; sudo apt install zsh$&gt; sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span>$&gt; <span class="hljs-built_in">echo</span> <span class="hljs-string">"source <span class="hljs-variable">$HOME</span>/.profile"</span> &gt;&gt; ~/.zshrc$&gt; chsh /usr/bin/zsh$&gt; <span class="hljs-built_in">echo</span> <span class="hljs-string">"export LC_ALL=en_US.UTF-8"</span>&gt;&gt; ~/.profile</code></pre><p>然后修改.zshrc文件，添加你自己的pulgins：</p><pre><code>plugins=(ubuntu git github git-flow cp systemd docker gem meteor rvm ruby perl python pip rsync sbt gradle nvm npm node coffee yarn go golang)</code></pre><h2 id="ssd-ci-pan" class="heading-control">SSD 磁盘<a class="heading-anchor" href="#ssd-ci-pan" aria-hidden="true"></a></h2><p>SSD磁盘的挂载和使用需要一些小技巧来延长SSD的使用寿命。</p><h3 id="trim" class="heading-control">Trim<a class="heading-anchor" href="#trim" aria-hidden="true"></a></h3><p>SSD 磁盘挂载需要启用trim指令，Liunx的磁盘系统支持两类trim（但注意不是所有的磁盘系统都支持）。</p><ul><li>discard 参数: 持续 trim(删除立刻trim)</li><li>fstrim: 后台trim(定期cron.weekly中执行一次)</li></ul><table><thead><tr><th>File system</th><th>Continuous TRIM(discard option)</th><th>Periodic TRIM(fstrim)</th></tr></thead><tbody><tr><td>Ext3</td><td>No</td><td>?</td></tr><tr><td>Ext4</td><td>Yes</td><td>Yes</td></tr><tr><td>Btrfs</td><td>Yes</td><td>Yes</td></tr><tr><td>JFS</td><td>Yes</td><td>Yes</td></tr><tr><td>XFS</td><td>Yes</td><td>Yes</td></tr><tr><td>F2FS</td><td>Yes</td><td>Yes</td></tr><tr><td>VFAT</td><td>Yes</td><td>No</td></tr><tr><td>ntfs-3g</td><td>No</td><td>Yes</td></tr></tbody></table><p>我自己用的是Ext4以及Btrfs(支持ssd参数优化)。另外如果是用笔记本的话，可以适当将写commit的时间延长（秒为单位）。添加<code>noatime</code>/<code>relatime</code>参数(在读取文件的时候禁止/减少写入)以便于提升SSD的读取性能（尽管Linux内核2.6.30以上为默认）。</p><pre><code class="bash">✗ cat /etc/fstab<span class="hljs-comment"># /etc/fstab: static file system information.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Use 'blkid' to print the universally unique identifier for a</span><span class="hljs-comment"># device; this may be used with UUID= as a more robust way to name devices</span><span class="hljs-comment"># that works even if disks are added and removed. See fstab(5).</span><span class="hljs-comment">#</span><span class="hljs-comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span>UUID=XXXX-XXX-XXXX-XXX /               ext4    defaults,noatime,discard,commit=300,errors=remount-ro 0       1UUID=XXXX-XXX-XXXX-XXX /home           btrfs   defaults,noatime,discard,commit=120,ssd 0       2UUID=XXXXXX            /dos            ntfs    defaults,noatime,nls=utf8,uid=1000,gid=1000,commit=120 0       2UUID=XXXX-XXXX         /boot/efi       vfat    defaults,noatime,<span class="hljs-built_in">umask</span>=0077      0       1UUID=XXXX-XXX-XXXX-XXX none            swap    sw              0       0</code></pre><p>注：</p><ul><li>查看磁盘分区的UUID,使用<code>blkid</code>指令。</li><li>启用<code>dicard</code>参数可能会牺牲一点ssd写入的速度。<br>× <code>/boot/efi</code>几乎不会被写，别加discard,否则可能引发故障</li></ul><p>启用trim前，请务必检查自己的ssd（尤其是2010年前的）是否支持trim,否则可能会造成数据丢失，使用<code>lsblk</code>指令：</p><pre><code class="bash"><span class="hljs-comment">#&gt; lsblk -D</span>NAME        DISC-ALN DISC-GRAN DISC-MAX DISC-ZEROnvme0n1          512      512B       2T         0├─nvme0n1p1        0      512B       2T         0├─nvme0n1p2        0      512B       2T         0</code></pre><p>如果 <code>DISC-GRAN</code> 和 <code>DISC-MAX</code> 列的值<code>非0</code>就表示支持trim.</p><h3 id="xian-zhi-jiao-huan-fen-qu" class="heading-control">限制交换分区<a class="heading-anchor" href="#xian-zhi-jiao-huan-fen-qu" aria-hidden="true"></a></h3><p>Linux使用交换文件的趋向由一个数值(swappiness)来控制，设置数值越低，需要更多的系统负载来启用交换分区。该值在0-100之间，默认为60，对于桌面应用来说太高了，仅仅适用与服务器。而对于SSD就太糟糕了。</p><p>查看当前的<code>swappiness</code>设置：</p><pre><code class="bash">$&gt; cat /proc/sys/vm/swappiness60</code></pre><p>然后修改： /etc/sysctl.conf 文件，增加：</p><pre><code># Sharply reduce the inclination to swapvm.swappiness=10</code></pre><h3 id="qi-yong-tmp-mu-lu-ram-pan" class="heading-control">启用/tmp目录RAM盘<a class="heading-anchor" href="#qi-yong-tmp-mu-lu-ram-pan" aria-hidden="true"></a></h3><pre><code class="bash">sudo cp /usr/share/systemd/tmp.mount /etc/systemd/system/tmp.mountsudo systemctl <span class="hljs-built_in">enable</span> tmp.mountsudo systemctl start tmp.mount</code></pre><h2 id="dnsmasq" class="heading-control">dnsmasq<a class="heading-anchor" href="#dnsmasq" aria-hidden="true"></a></h2><p>ubuntu自带，用于域名解析，并且是自动加在 /etc/resolve.conf中（127.0.1.1）是随NetworkManager启动的，dnsmasq的配置在 /etc/NetworkManager/dnsmasq.d/<br>需要加上对上游DNS服务器的查询，否则你可能会发现DOMAIN NOT FOUND：</p><pre><code class="bash">$&gt;cat /etc/resolv.dnsmasq.conf<span class="hljs-comment"># Google's nameservers, for example</span>nameserver 8.8.8.8nameserver 8.8.4.4$&gt;cat /etc/NetworkManager/dnsmasq.d/resolv.confresolv-file=/etc/resolv.dnsmasq.conf<span class="hljs-comment">#启用 /etc/hosts</span>$&gt;cat /etc/NetworkManager/dnsmasq.d/host.confaddn-hosts=/etc/hosts$&gt;sudo systemctl restart NetworkManager</code></pre><h2 id="ipset" class="heading-control">ipset<a class="heading-anchor" href="#ipset" aria-hidden="true"></a></h2><p>ipset 配合 iptables 可实现基于域名的策略路由。</p><p>ipset 可以将一组ip放入到一个集合中供iptables进行处理。这样可以很好的解决大量ip规则的匹配性能问题。</p><p>当然，首先你要安装: <code>sudo apt install ipset</code></p><h3 id="hei-ming-dan-fang-shi" class="heading-control">黑名单方式<a class="heading-anchor" href="#hei-ming-dan-fang-shi" aria-hidden="true"></a></h3><p>Dnsmasq 从 2.66 版本之后就支持将域名的查询结果放进 ipset 中，这样就可以对这些域名对应的 IP<br>使用 iptables 处理。</p><p>只转发名单内的IP, 可以配合gfwlist对指定的域名IP做重定向处理</p><p>下载: <a href="https://github.com/cokebar/gfwlist2dnsmasq/releases" target="_blank" rel="noopener">gfwlist_ipset.conf</a>文件，放在: /etc/NetworkManager/dnsmasq.d/ 目录中即可。</p><p>你需要修改文件中的域名服务器地址，最简单的方法是在代理服务器上自建一个域名服务器（用非标准端口）。</p><pre><code class="yaml"><span class="hljs-comment">#使用不受污染干扰的DNS解析该域名 可以将此IP改为自己使用的DNS服务器</span><span class="hljs-string">server=/google.com/127.0.0.1#5353</span><span class="hljs-comment">#将解析出来的IP保存到名为gfwlist的ipset表中</span><span class="hljs-string">ipset=/google.com/gfwlist</span></code></pre><p>或者，你可以<a href="https://github.com/cokebar/gfwlist2dnsmasq" target="_blank" rel="noopener">下载执行这个脚本</a>自动抓取gfwlist转换为：dnsmasq_gfwlist_ipset.conf</p><pre><code class="bash">$&gt; sudo bash gfwlist2dnsmasq.sh -d your-dns-server-ip -p your-dns-server-port -s gfwlist  -f /etc/NetworkManager/dnsmasq.d/gfwlist_ipset.conf</code></pre><p>然后创建<code>gfwlist</code>ipset规则集:</p><pre><code class="bash">ipset -N gfwlist <span class="hljs-built_in">hash</span>:ip</code></pre><h3 id="bai-ming-dan-fang-shi" class="heading-control">白名单方式<a class="heading-anchor" href="#bai-ming-dan-fang-shi" aria-hidden="true"></a></h3><p>收集国内IP，除了国内IP放行外，其它IP一律转发。</p><ul><li>获取国内 IP 列表</li></ul><p>接下来我们需要获取中国的 IP 列表。这里我们放在了 <code>~/chnroute/</code>目录下：</p><pre><code class="bash">CHNROUTE_DIR=<span class="hljs-variable">$HOME</span>/chnroutemkdir <span class="hljs-variable">$CHNROUTE_DIR</span>curl <span class="hljs-string">'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'</span> | grep ipv4 | grep CN | awk -F\| <span class="hljs-string">'{ printf("%s/%d\n", $4, 32-log($5)/log(2)) }'</span> &gt; <span class="hljs-variable">$CHNROUTE_DIR</span>/chnroute.txt</code></pre><p>这是来自 <a href="https://github.com/shadowsocks/ChinaDNS" target="_blank" rel="noopener">ChinaDNS</a> 的指令。</p><p>创建ipset并导入：</p><pre><code class="bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># Setup the ipset</span>ipset -N chnroute <span class="hljs-built_in">hash</span>:net maxelem 65536<span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> $(cat <span class="hljs-string">'$HOME/chnroute/chnroute.txt'</span>); <span class="hljs-keyword">do</span>  ipset add chnroute <span class="hljs-variable">$ip</span><span class="hljs-keyword">done</span></code></pre><p>注意：这里<code>ipset类型</code>必须是hash:net,而不是hash:ip。因为 chnroute.txt 是一个 IP 段列表，而中国持有的 IP 数量巨大，所以如果使用 hash:ip 来导入会内存溢出。</p><h2 id="shadowsocks-libev" class="heading-control">shadowsocks-libev<a class="heading-anchor" href="#shadowsocks-libev" aria-hidden="true"></a></h2><pre><code>apt install shadowsocks-libev</code></pre><pre><code class="bash">$&gt; cat /etc/shadowsocks-libev/config.json{    <span class="hljs-string">"server"</span>:<span class="hljs-string">"[123.22.33.13]"</span>, <span class="hljs-comment"># your shadowsocks server ip</span>    <span class="hljs-string">"server_port"</span>:1293,    <span class="hljs-string">"local_port"</span>:1080,    <span class="hljs-string">"password"</span>:<span class="hljs-string">"12345"</span>,    <span class="hljs-string">"timeout"</span>:60,    <span class="hljs-string">"method"</span>:<span class="hljs-string">"aes-256-cfb"</span>}</code></pre><p>启用 shadowsocks-libev.service 之前，需要做些修改，将服务改为透明转发<code>ss-redir</code>：</p><pre><code class="bash">$&gt;cat /lib/systemd/system/shadowsocks-libev.service[Service]Type=simpleEnvironmentFile=/etc/default/shadowsocks-libevUser=rootLimitNOFILE=32768<span class="hljs-comment"># modify ss-server to ss-redir</span>ExecStart=/usr/bin/ss-redir -a <span class="hljs-variable">$USER</span> -c <span class="hljs-variable">$CONFFILE</span> <span class="hljs-variable">$DAEMON_ARGS</span>$&gt;systemctl <span class="hljs-built_in">enable</span> shadowsocks-libev$&gt;systemctl daemon-reload$&gt;systemctl start shadowsocks-libev</code></pre><h2 id="iptables" class="heading-control">iptables<a class="heading-anchor" href="#iptables" aria-hidden="true"></a></h2><p>下面开始在iptables上做转发：</p><p>首先为shadowsocks创建NAT表:</p><pre><code class="bash"><span class="hljs-comment"># create a nat named SHADOWSOCKS:</span>iptables -t nat -N SHADOWSOCKS<span class="hljs-comment"># Ignore your shadowsocks server's addresses</span><span class="hljs-comment"># It's very IMPORTANT, just be careful.</span>iptables -t nat -A SHADOWSOCKS -d [your-shadowsocks-server-ip] -j RETURN<span class="hljs-comment"># 忽略局域网：</span><span class="hljs-comment"># Ignore LANs and any other addresses you'd like to bypass the proxy</span><span class="hljs-comment"># See Wikipedia and RFC5735 for full list of reserved networks.</span><span class="hljs-comment"># See ashi009/bestroutetb for a highly optimized CHN route list.</span>iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURNiptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURNiptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURNiptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURNiptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURNiptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURNiptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURNiptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN</code></pre><h3 id="hei-ming-dan" class="heading-control">黑名单<a class="heading-anchor" href="#hei-ming-dan" aria-hidden="true"></a></h3><pre><code class="bash"><span class="hljs-comment"># Anything matched gfwlist ipset should be redirected to shadowsocks's local port</span>iptables -t nat -A SHADOWSOCKS -p tcp -m <span class="hljs-built_in">set</span> --match-set gfwlist dst -j REDIRECT --to-ports 1080<span class="hljs-comment"># Apply the rules</span>iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS</code></pre><h3 id="bai-ming-dan" class="heading-control">白名单<a class="heading-anchor" href="#bai-ming-dan" aria-hidden="true"></a></h3><pre><code class="bash"><span class="hljs-comment"># Allow connection to chinese IPs</span>iptables -t nat -A SHADOWSOCKS -p tcp -m <span class="hljs-built_in">set</span> --match-set chnroute dst -j RETURN<span class="hljs-comment"># Others Redirect to Shadowsocks</span>iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-port 1080<span class="hljs-comment"># Apply the rules</span>iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS</code></pre><h3 id="qing-chu-iptables-gui-ze" class="heading-control">清除iptables规则<a class="heading-anchor" href="#qing-chu-iptables-gui-ze" aria-hidden="true"></a></h3><pre><code class="bash"><span class="hljs-meta">#!/bin/bash</span>iptables -t nat -D OUTPUT -p tcp -j SHADOWSOCKSiptables -t nat -F SHADOWSOCKSiptables -t nat -X SHADOWSOCKS<span class="hljs-comment"># 如果是黑名单:</span>ipset destroy gfwlist<span class="hljs-comment"># 如果是白名单:</span>ipset destroy chnroute</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ubuntu-16-10&quot; class=&quot;heading-control&quot;&gt;Ubuntu 16.10&lt;a class=&quot;heading-anchor&quot; href=&quot;#ubuntu-16-10&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Ubuntu 现在基本可以替代Windows做日常使用的主力——只要不玩游戏。不过对SSD还是要需要调教一二。使用 Linux 还有一个好处是可以自带策略路由，对于域名IP流量精确转发，变得so easy。&lt;/p&gt;
&lt;p&gt;这里记录下 Ubuntu 16.10 以上版本的安装tips.&lt;/p&gt;
&lt;h2 id=&quot;shell&quot; class=&quot;heading-control&quot;&gt;Shell&lt;a class=&quot;heading-anchor&quot; href=&quot;#shell&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我比较习惯 zsh, 下载安装zsh:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://riceball.me/categories/Linux/"/>
    
      <category term="Ubuntu" scheme="https://riceball.me/categories/Linux/Ubuntu/"/>
    
    
      <category term="network" scheme="https://riceball.me/tags/network/"/>
    
      <category term="linux" scheme="https://riceball.me/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://riceball.me/tags/ubuntu/"/>
    
      <category term="dnsmasq" scheme="https://riceball.me/tags/dnsmasq/"/>
    
      <category term="iptables" scheme="https://riceball.me/tags/iptables/"/>
    
      <category term="iproute2" scheme="https://riceball.me/tags/iproute2/"/>
    
      <category term="dns" scheme="https://riceball.me/tags/dns/"/>
    
      <category term="ipset" scheme="https://riceball.me/tags/ipset/"/>
    
      <category term="shadowsocks" scheme="https://riceball.me/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>SaaS平台之殇</title>
    <link href="https://riceball.me/article/open-saas/"/>
    <id>https://riceball.me/article/open-saas/</id>
    <published>2016-09-17T20:00:00.000Z</published>
    <updated>2019-11-22T06:56:43.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="saas-ping-tai-zhi-shang" class="heading-control">SaaS平台之殇<a class="heading-anchor" href="#saas-ping-tai-zhi-shang" aria-hidden="true"></a></h1><h2 id="bei-jing" class="heading-control">背景<a class="heading-anchor" href="#bei-jing" aria-hidden="true"></a></h2><p>商业应用的集中式托管可以追溯到20世纪60年代的时分系统中。SaaS通常使用多租架构为多个商业组织和用户提供服务。</p><p>在多租环境中的相对低廉的用户服务开通（创建新客户），使得一些软件即服务供应商可以用免费模式来提供应用。在这种模式下，基本功能免费，增强功能或更大的范围则是要收费的。当然，也有完全对用户完全免费的SaaS，而他们的收入则产生于其它相关来源例如：广告。</p><p>SaaS的本质是将规模经济应用到软件应用的运营上。故其规模决定了其发展。而影响企业用户决定是否采用SaaS的一个最关键因素就是<code>数据</code>。</p><h2 id="shang-wen-ti" class="heading-control">殇 - 问题<a class="heading-anchor" href="#shang-wen-ti" aria-hidden="true"></a></h2><p>数据的安全，以及数据的归属（政策法规上的搜索/占有保障法律并不保护服务存储的数据）。最终导致结果是，对数据的访问，以及进一步的对该数据的不当使用，仅仅由假定是诚信的第三方或他们自己的承诺书来限制（你没法知道他们到底是否违背了他们的承诺）。</p><ul><li>数据安全</li><li>数据实际属于SaaS服务提供商</li><li>服务终止</li><li>数据滥用:<ul><li>供应商工作/研发人员可以任意浏览/修改数据。</li><li>代码漏洞或后门</li></ul></li><li>数据丢失或篡改<ul><li><a href="http://www.rainstor.com/assets/downloads/SaaS_Data_Escrow_International_Report.pdf" target="_blank" rel="noopener">Clearpace Software Ltd. 发起的研究</a>显示85%的参与者想要获得他们的软件即服务数据的一个副本。<br>1/3的这些参与者想要每天获取一份副本。</li></ul></li><li>供应商破产</li><li>用户无知情权，监督权，数据归属权</li></ul><p>愚以上为制约SaaS发展规模的主要原因。</p><h2 id="kai-yuan-saas-ping-tai" class="heading-control">开源 SaaS 平台<a class="heading-anchor" href="#kai-yuan-saas-ping-tai" aria-hidden="true"></a></h2><p>借助开源 SaaS 平台联盟，借助最新的技术手段，借助开源社区的监督和研发，可以做到：</p><ul><li>无后门</li><li>更安全</li><li>更大程度限制运营人员</li><li>保障用户的知情权，监督权，数据归属权</li><li>规模集约化运营</li></ul><p><img src="./alliance-platform-rule.png" alt="alliance-platform-rule"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;saas-ping-tai-zhi-shang&quot; class=&quot;heading-control&quot;&gt;SaaS平台之殇&lt;a class=&quot;heading-anchor&quot; href=&quot;#saas-ping-tai-zhi-shang&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;bei-jing&quot; class=&quot;heading-control&quot;&gt;背景&lt;a class=&quot;heading-anchor&quot; href=&quot;#bei-jing&quot; aria-hidden=&quot;true&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;商业应用的集中式托管可以追溯到20世纪60年代的时分系统中。SaaS通常使用多租架构为多个商业组织和用户提供服务。&lt;/p&gt;
&lt;p&gt;在多租环境中的相对低廉的用户服务开通（创建新客户），使得一些软件即服务供应商可以用免费模式来提供应用。在这种模式下，基本功能免费，增强功能或更大的范围则是要收费的。当然，也有完全对用户完全免费的SaaS，而他们的收入则产生于其它相关来源例如：广告。&lt;/p&gt;
&lt;p&gt;SaaS的本质是将规模经济应用到软件应用的运营上。故其规模决定了其发展。而影响企业用户决定是否采用SaaS的一个最关键因素就是&lt;code&gt;数据&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thinking" scheme="https://riceball.me/categories/Thinking/"/>
    
      <category term="Cloud Computing" scheme="https://riceball.me/categories/Thinking/Cloud-Computing/"/>
    
      <category term="SaaS" scheme="https://riceball.me/categories/Thinking/Cloud-Computing/SaaS/"/>
    
    
      <category term="cloud computing" scheme="https://riceball.me/tags/cloud-computing/"/>
    
      <category term="open source" scheme="https://riceball.me/tags/open-source/"/>
    
      <category term="saas" scheme="https://riceball.me/tags/saas/"/>
    
      <category term="software as a service" scheme="https://riceball.me/tags/software-as-a-service/"/>
    
  </entry>
  
</feed>
